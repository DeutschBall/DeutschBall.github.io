<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/8/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/02/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">CSAPP-chapter12 线程并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 01:00:00" itemprop="dateCreated datePublished" datetime="2022-06-02T01:00:00+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-15 16:59:27" itemprop="dateModified" datetime="2022-06-15T16:59:27+08:00">2022-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="csapp-chapter12-线程并发">CSAPP-chapter12 线程并发</h1>
<h2 id="线程模型">线程模型</h2>
<p>引入线程概念之后,进程的职能只剩下组织资源.线程负责程序的执行</p>
<p>同一个进程的线程之间有共享也有私有资源</p>
<h3 id="线程私有资源">线程私有资源:</h3>
<p>1.线程ID,tid</p>
<p>2.线程栈及其栈顶指针</p>
<p>3.程序计数器PC,rip</p>
<p>4.程序状态字PSW,flags</p>
<p>5.通用目的寄存器</p>
<blockquote>
<p>上述五个合起来叫做 线程上下文</p>
</blockquote>
<h3 id="线程共享资源">线程共享资源</h3>
<p>进程用户虚拟地址空间中除了线程栈的其他部分</p>
<p>1.堆</p>
<p>2.只读代码段</p>
<p>3.全局变量区,.data,.bss</p>
<p>4.共享库</p>
<p>5.打开的文件</p>
<blockquote>
<p>实际上同一个进程的各个线程栈之间不设防,即可以通过全局变量指针等方法,使得一个线程可以访问修改另一个线程的栈空间</p>
</blockquote>
<h3 id="线程的特点">线程的特点</h3>
<p>每个进程执行伊始都是单一线程的,即主线程</p>
<p>从主线程创建的其他线程或者其他线程创建的线程都是<strong>对等线程</strong></p>
<p>即一个进程的所有线程都是对等线程.一个进程的线程之间没有父子关系一说.所有线程组成一个线程池.任何一个线程都可以杀死任何一个对等线程.</p>
<h3 id="posix线程">POSIX线程</h3>
<blockquote>
<p>POSIX:可移植操作系统接口</p>
</blockquote>
<p>线程概念落地实现,后面的实验都基于POSIX线程</p>
<p>源代码可以去看glibc库</p>
<p>在使用POSIX线程库函数时,需要动态链接<code>libpthread.so</code>库,因为gcc不会自动链接该库</p>
<p>比如<code>gcc main.c -lpthread -o main</code></p>
<h4 id="线程例程">线程例程</h4>
<p>线程是程序的一次执行,更准确的说法是函数的一次执行</p>
<p>线程的代码和局部数据被封装在一个函数中,如果只是从main函数中像以前一样调用改函数,则该函数就是一个普通函数.如果在main函数中创建一个新线程,让该新线程去执行该函数,则该函数此时就是"线程例程"</p>
<p>线程的使用方法与进程大不相同,多进程时,fork之后立刻产生新进程,用起来总是感觉别扭,区分不同的进程甚至需要在进程内部使用<code>getpid</code>等函数获得pid然后进行条件判断.</p>
<p>线程的使用是基于函数的,让一个线程去执行一个函数,使用更加自然.</p>
<h4 id="线程句柄pthread_t">线程句柄<code>pthread_t</code></h4>
<p><code>glibc-2.9\nptl\sysdeps\unix\sysv\linux\alpha\bits\pthreadtypes.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程标识符,本质为无符号长整形unsigned long</p>
</blockquote>
<p><code>pthread_t tid;</code>用于保存线程tid</p>
<h4
id="获取当前线程idpthread_self">获取当前线程id,<code>pthread_self</code></h4>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# gcc main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# ./main</span><br><span class="line"><span class="keyword">in</span> main,tid=139945163630400</span><br><span class="line"><span class="keyword">in</span> func,tid=139945163630400</span><br></pre></td></tr></table></figure>
<p>每次运行,tid都是不同的数值,但是<code>main</code>和<code>func</code>两个函数中打印的tid都是相同的</p>
<p>因为func不是新线程执行的,它仍然是main线程执行的.</p>
<h4 id="创建线程pthread_create">创建线程<code>pthread_create</code></h4>
<p><code>pthread.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new thread, starting with execution of START-ROUTINE</span></span><br><span class="line"><span class="comment">   getting passed ARG.  Creation attributed come from ATTR.  The new</span></span><br><span class="line"><span class="comment">   handle is stored in *NEWTHREAD.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(   <span class="type">pthread_t</span> *__restrict __newthread,</span></span><br><span class="line"><span class="params">			               __const <span class="type">pthread_attr_t</span> *__restrict __attr,</span></span><br><span class="line"><span class="params">			               <span class="type">void</span> *(*__start_routine) (<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">			               <span class="type">void</span> *__restrict __arg)</span> <span class="comment">//到此函数参数表已经结束,后面是Function Attributes修饰</span></span><br><span class="line">                         __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个新线程,从<code>START_ROUTINE</code>函数,带着<code>ARG</code>参数
开始执行.</p>
<blockquote>
<p>线程函数的参数只能有一个,是一个</p>
</blockquote>
<p>以参数ATTR为线程属性</p>
<p>新的线程句柄以参数NEWTHREAD返回</p>
<p>如果创建新线程成功则函数返回0,否则返回数字代表错误原因</p>
</blockquote>
<blockquote>
<p>关于参数的<code>__restrict</code>修饰符</p>
<blockquote>
<p><code>__restrict</code></p>
<p>Like the <strong><code>__declspec</code> ( <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/restrict?view=msvc-170"><code>restrict</code></a>
)</strong> modifier, the <strong><code>__restrict</code></strong>
keyword (two leading underscores '_') indicates that a symbol isn't
aliased in the current scope</p>
</blockquote>
<p>类似于<code>__declspec</code>修饰符,<code>__restrict</code>关键字(两个下划线作为前缀),指明本符号在当前作用域内没有别名</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349726808">C/C++关键字之restrict -
知乎 (zhihu.com)</a></p>
<p>restrict关键字用于修饰指针(C99标准)。</p>
<p>通过加上restrict关键字，编程者可提示编译器：<strong>在该指针的生命周期内，其指向的对象不会被别的指针所引用</strong></p>
</blockquote>
<blockquote>
<p>关于函数属性的<code>__nonull</code>修饰符<a
target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html">Function
Attributes - Using the GNU Compiler Collection (GCC)</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonnull (`arg-index`, ...)</span><br></pre></td></tr></table></figure>
<p>The <code>nonnull</code> attribute specifies that some function
parameters should be non-null pointers. For instance, the
declaration:</p>
<p>nonnull 属性表明,一些函数参数应该是非空指针.比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern void *</span><br><span class="line">my_memcpy (void *dest, const void *src, size_t len)</span><br><span class="line">        __attribute__((nonnull (1, 2)));</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>causes the compiler to check that, in calls to
<code>my_memcpy</code>, arguments dest and src are non-null. If the
compiler determines that a null pointer is passed in an argument slot
marked as non-null, and the -Wnonnull option is enabled, a warning is
issued. The compiler may also choose to make optimizations based on the
knowledge that certain function arguments will not be null.</p>
<p><code>__attribute__((nonnull (1, 2)))</code>将会让编译器检查,对于函数my_memcpy,第一个参数dest和第二个参数src应该是非空指针.</p>
<p>如果编译器发现一个被标记为非空的参数实际上传了一个空指针,并且-Wnonnull
编译选项开启,那么编译器将会警告.</p>
<p>编译器还可能根据参数被修饰为非空进行一些优化</p>
<p>If no argument index list is given to the <code>nonnull</code>
attribute, all pointer arguments are marked as non-null.</p>
<p>如果没有给nonnull属性指明参数下标表,那么所有函数参数都将被标记为非空.</p>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __attribute__((nonnull)) func(<span class="type">char</span> *s)&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func(<span class="literal">NULL</span>);		<span class="comment">//传递空指针作为参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# gcc main.c -Wall -o main 		<span class="comment">#-Wall开启所有警告</span></span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:4:5: warning: argument 1 null <span class="built_in">where</span> non-null expected [-Wnonnull]</span><br><span class="line">    4 |     func(NULL);</span><br><span class="line">      |     ^~~~</span><br><span class="line">main.c:2:31: note: <span class="keyword">in</span> a call to <span class="keyword">function</span> ‘func’ declared ‘nonnull’</span><br><span class="line">    2 | void __attribute__((nonnull)) func(char *s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>编译警告func的参数应该非空</p>
</blockquote>
<blockquote>
<p>关于函数属性<code>__THROW</code>修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __THROW __attribute__ ((__nothrow__ __LEAF))</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nothrow</span><br></pre></td></tr></table></figure>
<p>The <code>nothrow</code> attribute is used to inform the compiler
that a function cannot throw an exception. For example, most functions
in the standard C library can be guaranteed not to throw an exception
with the notable exceptions of <code>qsort</code> and
<code>bsearch</code> that take function pointer arguments. The
<code>nothrow</code> attribute is not implemented in GCC versions
earlier than 3.3.</p>
</blockquote>
<p>nothrow属性用来通知编译器,函数不会抛出异常</p>
<p>比如,C标准库中的大多数函数都保证不会抛出qsort和bsearch使用函数指针作为参数的错误;</p>
<p>在GCC3.3之前没有该属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Calls to external functions with this attribute must return to the
current compilation unit only by return or by exception handling. In
particular, leaf functions are not allowed to call callback function
passed to it from the current compilation unit or directly call
functions exported by the unit or longjmp into the unit. Leaf function
might still call functions from other compilation units and thus they
are not necessarily leaf in the sense that they contain no function
calls at all.</p>
<p>The attribute is intended for library functions to improve dataflow
analysis. The compiler takes the hint that any data not escaping the
current compilation unit can not be used or modified by the leaf
function. For example, the <code>sin</code> function is a leaf function,
but <code>qsort</code> is not.</p>
<p>Note that leaf functions might invoke signals and signal handlers
might be defined in the current compilation unit and use static
variables. The only compliant way to write such a signal handler is to
declare such variables <code>volatile</code>.</p>
<p>The attribute has no effect on functions defined within the current
compilation unit. This is to allow easy merging of multiple compilation
units into one, for example, by using the link time optimization. For
this reason the attribute is not allowed on types to annotate indirect
calls.</p>
</blockquote>
<p>总之表示声明为leaf的函数不会调用其他函数</p>
</blockquote>
<p>综上,<code>pthread_create</code>函数要求,第一个参数tid,第三个参数,例程函数指针非空.四个参数指针指向的内容在本线程执行过程中不能被其他线程引用.<code>pthread_create</code>函数不会抛出异常,<code>pthread_create</code>函数只会调用例程函数,不会调用其他函数(至于例程函数会不会调用其他函数我不管)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//return NULL之后本线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid1=%ld\n&quot;</span>,tid1);</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid2=%ld\n&quot;</span>,tid2);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);<span class="comment">//主线程等待对等线程结束之后才结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/pthread]</span><br><span class="line">└─<span class="meta"># gcc main.c -o main -lpthread</span></span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/pthread]</span><br><span class="line">└─# ./main</span><br><span class="line">in main,tid1=<span class="number">140685510317888</span></span><br><span class="line">in main,tid2=<span class="number">140685510313536</span></span><br><span class="line">in func,tid=<span class="number">140685510313536</span></span><br></pre></td></tr></table></figure>
<p>func和main函数所在的线程id确实不同了</p>
<h4 id="终止线程pthread_exit">终止线程<code>pthread_exit</code></h4>
<p>线程的终止方式有两种: 一是顶层线程例程return,隐式终止</p>
<blockquote>
<p>"顶层线程例程"的意思是,</p>
<p>线程例程是一个函数,该函数可以调用其他函数,这些被调用的函数也属于本线程,但是最高层的那个函数(也就是pthread_create时指定的函数)返回时才算线程的结束</p>
</blockquote>
<p>二是显示使用<code>pthread_exit</code>函数结束</p>
<blockquote>
<p>如果main函数所在的主线程使用<code>pthread_exit</code>,则主线程会等待所有对等线程终止之后才会终止主线程和整个进程</p>
</blockquote>
<p>线程函数的返回值怎么让其他线程知道呢?</p>
<blockquote>
<p>比如main线程创建了一个对等线程去执行func函数,假设func函数有返回值,怎么让main知道这个返回值呢?</p>
</blockquote>
<p>使用<code>pthread_exit</code>函数解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Terminate calling thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The registered cleanup handlers are called via exception handling</span></span><br><span class="line"><span class="comment">   so we cannot mark this function with __THROW.*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *__retval)</span> __<span class="title function_">attribute__</span> <span class="params">((__noreturn__))</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>终止线程</p>
<p>清理程序以异常处理进行,因此我们不能将该函数标记为<code>__THROW</code></p>
<blockquote>

</blockquote>
</blockquote>
<p>返回值通过指针参数<code>void *__retval</code>传递</p>
<h4
id="杀死对等线程pthread_cancel">杀死对等线程<code>pthread_cancel</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cancel THREAD immediately or at the next possibility.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> __th)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSAPP:马上终止线程"或者下一个可能的时候"?没使用过该函数</p>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;*((<span class="type">long</span>*)times);++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ gcc main.c -O0 -o main -lpthread</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167</span><br></pre></td></tr></table></figure>
<p>前两次运行没等对等线程开始执行,<code>main</code>线程就将其杀掉了</p>
<p>第三次对等线程执行到i=167左右时,<code>main</code>线程执行到<code>pthread_cancel(tid)</code>将对等线程杀掉了</p>
<h4 id="杀死全部对等进程exit">杀死全部对等进程<code>exit</code></h4>
<p>如果有一个对等线程调用<code>exit</code>函数,则立刻杀死所有对等线程并终止进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;++i)&#123;<span class="comment">//空转浪费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">thread 140558930863680 created</span><br><span class="line"><span class="keyword">in</span> func,tid=140558930863680</span><br></pre></td></tr></table></figure>
<p>由于对等线程提前执行<code>exit</code>,此时主线程还没有来得及打印<code>printf("main exit\n");</code>进程就结束了</p>
<h4
id="回收已终止线程资源pthread_join">回收已终止线程资源<code>pthread_join</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make calling thread wait for termination of the thread TH.  The</span></span><br><span class="line"><span class="comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span></span><br><span class="line"><span class="comment">   is not NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_join</span> <span class="params">(<span class="type">pthread_t</span> __th, <span class="type">void</span> **__thread_return)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使调用线程等待TH线程的结束</p>
<p>如果指定了<code>__thread_return</code>参数并且不为空,则使用<code>_thread_return</code>参数承接<code>TH</code>线程的退出状态</p>
<p>该函数是一个取消点,因此不用<code>__THROW</code>标记</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;*((<span class="type">long</span>*)times);++i)&#123;<span class="comment">//空转消耗时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);<span class="comment">//此时主线程等待对等线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld joined\n&quot;</span>,tid);</span><br><span class="line"></span><br><span class="line">    status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit&quot;</span>);<span class="comment">//主函数不再等待对等线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">thread 140127873893952 created</span><br><span class="line"><span class="keyword">in</span> func,tid=140127873893952</span><br><span class="line">thread 140127873893952 joined</span><br><span class="line">thread 140127873893952 created</span><br><span class="line">main <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>在<code>pthread_join(tid,NULL)</code>处,主线程会等待tid线程结束然后继续执行</p>
<p>后来又创建了线程但是没有等待它结束,主线程率先结束,相当于调用了<code>exit</code>函数,直接结束了所有对等线程,因此后来的对等线程没有执行<code>func</code>中的<code>printf</code></p>
<h4 id="分离线程pthread_detach">分离线程<code>pthread_detach</code></h4>
<p>一个线程在创建之后,其相对于对等线程</p>
<p>1.可结合的(joinable)</p>
<p>2.分离的(detached)</p>
<blockquote>
<p>注意两种状态的叫法</p>
<p>一个是"可"结合的,而不是说"结合的",因为结合的意思是被对等进程使用<code>pthread_join</code>回收掉了</p>
<p>"分离的"意思是已经分离,原来的对等线程无法管理它</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.</span></span><br><span class="line"><span class="comment">   The resources of TH will therefore be freed immediately when it</span></span><br><span class="line"><span class="comment">   terminates, instead of waiting for another thread to perform PTHREAD_JOIN</span></span><br><span class="line"><span class="comment">   on it.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_detach</span> <span class="params">(<span class="type">pthread_t</span> __th)</span> __THROW;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>pthread_detach</code>函数表明,TH线程将永远不会"加入"调用线程</p>
<p>因此当TH线程结束时,其资源将会被立刻回收,而不必再等待被对等线程调用<code>pthread_join</code>回收</p>
</blockquote>
<h4 id="初始化线程pthread_once">初始化线程<code>pthread_once</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Guarantee that the initialization function INIT_ROUTINE will be called</span></span><br><span class="line"><span class="comment">   only once, even if pthread_once is executed several times with the</span></span><br><span class="line"><span class="comment">   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or</span></span><br><span class="line"><span class="comment">   extern variable initialized to PTHREAD_ONCE_INIT.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initialization functions might throw exception which is why</span></span><br><span class="line"><span class="comment">   this function is not marked with __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *__once_control,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> (*__init_routine) (<span class="type">void</span>))</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化线程例程的相关状态</p>
<p>具体作用目前未知</p>
<h2 id="单处理器机器上多线程同步问题">单处理器机器上多线程同步问题</h2>
<h3 id="变量在内存中的位置">变量在内存中的位置</h3>
<table>
<thead>
<tr>
<th>变量类型</th>
<th style="text-align: left;">共享情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局变量或者全局位置的静态变量</td>
<td style="text-align: left;">共享</td>
</tr>
<tr>
<td>线程函数内静态变量</td>
<td style="text-align: left;">共享</td>
</tr>
<tr>
<td>线程函数内的普通局部变量</td>
<td style="text-align: left;">不共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *)</span>&#123;</span><br><span class="line">    <span class="type">int</span> local_in_func=<span class="number">20</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_in_func=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld,&amp;global=%p,&amp;local_in_func=%p,&amp;static_in_func=%p\n&quot;</span>,pthread_self(),&amp;global,&amp;local_in_func,&amp;static_in_func);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;++i)&#123;</span><br><span class="line">			<span class="comment">//空转耗时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid=%ld exit\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid=%ld,&amp;global=%p\n&quot;</span>,pthread_self(),&amp;global);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ gcc -O0 main.c -o main -lpthread</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"><span class="keyword">in</span> main,tid=140195300874048,&amp;global=0x558b84485048</span><br><span class="line"><span class="keyword">in</span> func,tid=140195300869696,&amp;global=0x558b84485048,&amp;local_in_func=0x7f81c31b7e48,&amp;static_in_func=0x558b8448504c</span><br><span class="line"><span class="keyword">in</span> func,tid=140195292476992,&amp;global=0x558b84485048,&amp;local_in_func=0x7f81c29b6e48,&amp;static_in_func=0x558b8448504c</span><br><span class="line">tid=140195300869696 <span class="built_in">exit</span></span><br><span class="line">tid=140195292476992 <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果表明<code>&amp;global</code>都是同一个地址,<code>&amp;static_in_func</code>都是同一个地址,<code>&amp;local_in_func</code>是每个线程各有一个地址</p>
<h3 id="同步错误">同步错误</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt=<span class="number">0</span>;<span class="comment">//volatile修饰,避免将cnt放在寄存器中,编译器不要对本变量做优化</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *vargp)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters=*((<span class="type">long</span>*)vargp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;niters;++i)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;expect a number as argument\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt!=(<span class="number">2</span>*niters))&#123;<span class="comment">//检查此时cnt的值是否等于二倍的niters</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%ld,What happened?\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nothing happened.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单核ubuntu虚拟机上的运行结果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530223552070.png"
alt="image-20220530223552070" />
<figcaption aria-hidden="true">image-20220530223552070</figcaption>
</figure>
<p>指定命令行参数为1e8则期望的cnt应该被两个线程轮流增加直到2e8,但是实际上cnt=142026321或者153306108甚至两次执行结果都不一样</p>
<p>为什么会发生这种事情呢?</p>
<p>反汇编观察<code>func</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:080484B0                 assume cs:_text</span><br><span class="line">.text:080484B0                 ;org 80484B0h</span><br><span class="line">.text:080484B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing</span><br><span class="line">;注意ds段寄存器指向.data全局变量节,cnt就在这里</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.text:08048564 ; Attributes: bp-based frame</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564 ; void *func(void *)</span><br><span class="line">.text:08048564                 public func</span><br><span class="line">.text:08048564 func            proc near               ; DATA XREF: main+43↓o</span><br><span class="line">.text:08048564                                         ; main+67↓o</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564 var_8           = dword ptr -8</span><br><span class="line">.text:08048564 var_4           = dword ptr -4</span><br><span class="line">.text:08048564 arg_0           = dword ptr  8</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564                 push    ebp</span><br><span class="line">.text:08048565                 mov     ebp, esp</span><br><span class="line">.text:08048567                 sub     esp, 10h</span><br><span class="line">.text:0804856A                 mov     eax, [ebp+arg_0] ; 参数vargp的地址放到eax寄存器</span><br><span class="line">.text:0804856D                 mov     eax, [eax]      ; 参数vargp的值放到eax寄存器</span><br><span class="line">.text:0804856F                 mov     [ebp+var_4], eax ; vargp-&gt;var_4</span><br><span class="line">.text:08048572                 mov     [ebp+var_8], 0  ; 0-&gt;var_8,可以猜测对应long i=0,循环变量</span><br><span class="line">.text:08048579                 jmp     short loc_804858C ; &quot;跳进循环&quot;</span><br><span class="line">.text:0804857B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804857B</span><br><span class="line">.text:0804857B loc_804857B:                            ; CODE XREF: func+2E↓j</span><br><span class="line">.text:0804857B                 mov     eax, ds:cnt     ; 三句话,让位于ds段的cnt加个1</span><br><span class="line">.text:08048580                 add     eax, 1</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax</span><br><span class="line">.text:08048588                 add     [ebp+var_8], 1  ; 循环变量加1</span><br><span class="line">.text:0804858C</span><br><span class="line">.text:0804858C loc_804858C:                            ; CODE XREF: func+15↑j</span><br><span class="line">.text:0804858C                 mov     eax, [ebp+var_8] ; 循环变量var_8值放到eax寄存器</span><br><span class="line">.text:0804858F                 cmp     eax, [ebp+var_4] ; 循环变量值与var_4中存放的vargp的值进行比较</span><br><span class="line">.text:08048592                 jl      short loc_804857B ; 如果var_8&lt;var_4即i&lt;vargp则重复循环</span><br><span class="line">.text:08048594                 mov     eax, 0</span><br><span class="line">.text:08048599                 leave</span><br><span class="line">.text:0804859A                 retn</span><br><span class="line">.text:0804859A func            endp</span><br></pre></td></tr></table></figure>
<p>注意这迷人的三句话<del>让男人给我花了十八万</del></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0804857B                 mov     eax, ds:cnt     ; 三句话,让位于ds段的cnt加个1</span><br><span class="line">.text:08048580                 add     eax, 1</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax</span><br></pre></td></tr></table></figure>
<p>假设,现在cnt=10,</p>
<p>线程1执行了<code>.text:0804857B                 mov     eax, ds:cnt</code>之后歇逼了(时间片用完了,发生调度,属于概率事件),保存好线程上下文(包括eax寄存器,保存的eax值为eax=10),然后控制交给线程2</p>
<p>线程2也执行了<code>.text:0804857B                 mov     eax, ds:cnt</code>,之后线程2没有歇逼,又执行完了下面两句话,把三句话说全了,然后歇逼,控制交给线程1</p>
<p>此时cnt=11</p>
<p>线程1恢复了上下文,<code>eax=10</code>,然后执行剩下的两句话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:08048580                 add     eax, 1		;eax=11</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax	;eax=11-&gt;cnt</span><br></pre></td></tr></table></figure>
<p>执行完了之后发现cnt=11</p>
<p>刚才已经等于11了,这一波操作之后还是11,相当于线程1啥也没干,失去一次增加cnt的机会</p>
<p>如果线程1完全执行完了才执行线程2,自然不会有上述错误</p>
<p>发生错误的原因是,两个线程有机会同时访问修改共享变量(一个躺在共享变量上睡觉,另一个修改共享变量)</p>
<p>那么解决方法也是显然的,<strong>让共享变量某一时刻只能被一个线程访问.</strong></p>
<p>这种可能被多个线程访问的共享变量叫做"<strong>临界区</strong>",怎样解决单处理机上的同步错误呢?使用信号量</p>
<h3 id="进程图">进程图</h3>
<p>刚才发生的同步错误,用进程图描述更加直观</p>
<p><code>func</code>干的事情可以描述为这么几部分:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">临界区前	Hi</span><br><span class="line">临界区开始	</span><br><span class="line">	加载cnt到eax	Li</span><br><span class="line">	eax+<span class="number">1</span>-&gt;eax	 Ui</span><br><span class="line">	eax写回cnt	Si</span><br><span class="line">临界区结束</span><br><span class="line">临界区后	Ti</span><br></pre></td></tr></table></figure>
<p>分别编上号,角标<code>i</code>表示线程<code>i</code></p>
<p>那么一个线程的执行过程可以用数轴表示,正方向表示时间推移</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530230823320.png"
alt="image-20220530230823320" />
<figcaption aria-hidden="true">image-20220530230823320</figcaption>
</figure>
<p>那么两个线程并发执行过程可以用二维坐标系表示,x轴和y轴各表示一个线程的时间轴</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530230930124.png"
alt="image-20220530230930124" />
<figcaption aria-hidden="true">image-20220530230930124</figcaption>
</figure>
<p>其中节点均表示两个线程完成某些步骤之后的状态,线段表示状态转移</p>
<p>在临界区中的状态标记为危险区</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530233515036.png"
alt="image-20220530233515036" />
<figcaption aria-hidden="true">image-20220530233515036</figcaption>
</figure>
<blockquote>
<p>危险区的意思是,两个线程同时访问临界区</p>
</blockquote>
<p>要状态转移到终点位置并且不能经过危险区,贴着危险区的边走也是可以的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530234418812.png"
alt="image-20220530234418812" />
<figcaption aria-hidden="true">image-20220530234418812</figcaption>
</figure>
<h2 id="信号量">信号量</h2>
<p><code>semaphore</code></p>
<p>信号量是非负整数值的全局变量,只能由两种特殊操作来处理,P(proberen测试)操作和V(verhogen增加)操作</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531000855604.png"
alt="image-20220531000855604" />
<figcaption aria-hidden="true">image-20220531000855604</figcaption>
</figure>
<p>P和V中的操作都是一条龙,不允许中断</p>
<p>P和V保证信号量是一个非负值,这个性质叫做"信号量不变性"</p>
<h3 id="posix接口">Posix接口</h3>
<h4 id="sem_t"><code>sem_t</code></h4>
<p>信号量的定义</p>
<p><code>/bits/semaphore.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZEOF_SEM_T	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_SEM_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>sem_t</code>是一个32字节的字符数组和长整型的联合体</p>
<h4 id="初始化信号量sem_init">初始化信号量<code>sem_init</code></h4>
<p><code>semaphore.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it</span></span><br><span class="line"><span class="comment">   with other processes.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *__sem, <span class="type">int</span> __pshared, <span class="type">unsigned</span> <span class="type">int</span> __value)</span></span><br><span class="line">     __THROW;</span><br></pre></td></tr></table></figure>
<p>信号量以指针<code>sem_t *__sem</code>传参,</p>
<p><code>int __pshared</code>总是0,</p>
<p><code>unsigend int __value</code>表示信号量的初始值(最大值)</p>
<h4
id="pv操作sem_waitsem_post">PV操作<code>sem_wait&amp;sem_post</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wait for SEM being posted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *__sem)</span>;</span><br><span class="line"><span class="comment">/* Post SEM.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_post</span> <span class="params">(<span class="type">sem_t</span> *__sem)</span> __THROW;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p><code>sem_wait</code>相当于<code>P</code>操作</p>
<p><code>sem_post</code>相当于<code>V</code>操作</p>
<h3 id="信号量实现互斥">信号量实现互斥</h3>
<h4 id="信号量互斥锁的区别">信号量,互斥锁的区别</h4>
<p>每个共享变量与一个信号量s联系起来,当线程访问共享变量时,用<code>sem_wait(&amp;s)</code>和<code>sem_post(&amp;s)</code>包裹访问临界区的操作.</p>
<p>如果这样用信号量则s的值要么是0(表示临界区没有被访问)要么是1(表示已经有线程在临界区中睡觉或者执行了)</p>
<p>由于s的值只有两种因此s又叫做"<strong>二元信号量binary
semaphore</strong>"</p>
<p>用于临界区互斥的二元信号量叫做"<strong>互斥锁mutex</strong>"</p>
<p>信号量还可以统计资源数量</p>
<p>比如某种设备有8个,就用s=8表示该种资源的最大值,这种用法的信号量叫做"<strong>计数信号量</strong>"</p>
<h4 id="信号量解决同步错误">信号量解决同步错误</h4>
<p>还是同步错误时的例子,用信号量应该这样修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;<span class="comment">//声明一个信号量,名字叫做mutex显然作为互斥锁使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *vargp)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters=*((<span class="type">long</span>*)vargp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;niters;++i)&#123;</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//进入临界区之前首先访问并修改互斥锁</span></span><br><span class="line">        cnt++;<span class="comment">//访问临界区操作</span></span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//离开临界区之后立刻还原互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//注册一个最大值为1的信号量即互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;expect a number as argument\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt!=(<span class="number">2</span>*niters))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%ld,What happened?\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nothing happened.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;mutex);<span class="comment">//进入临界区之前首先访问并修改互斥锁</span></span><br><span class="line">cnt++;<span class="comment">//访问临界区操作</span></span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//离开临界区之后立刻还原互斥锁</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>举个例子推导互斥锁的工作原理</p>
<p>假设线程1在访问临界区cnt时睡觉了,此时线程1已经执行过<code>sem_wait(&amp;mutex)</code>,这是<strong>一个一条龙操作</strong>,即保证一旦线程1开始执行<code>sem_wait(&amp;mutex)</code>则线程1对cpu的控制至少要持续到该操作结束.</p>
<p><code>sem_wait(&amp;mutex)</code>之后,mutex=0,表征当前临界区中已有线程访问.</p>
<p>那么线程2会在<code>sem_wait(&amp;mutex)</code>这一步等待,直到线程1释放互斥锁</p>
</blockquote>
<p>在单处理器机器(虚拟机给一个只有一个核的处理器)上的运行结果:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531005828633.png"
alt="image-20220531005828633" />
<figcaption aria-hidden="true">image-20220531005828633</figcaption>
</figure>
<p>治好了老咳喘</p>
<h4
id="使用信号量互斥锁之后的进程图">使用信号量(互斥锁)之后的进程图</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531005043807.png"
alt="image-20220531005043807" />
<figcaption aria-hidden="true">image-20220531005043807</figcaption>
</figure>
<p>刚才我们分析过,贴着不安全区的边也是可以的,但是使用信号量解决互斥问题时,贴着不安全区的边也不行.因为临界区中的状态点处互斥锁值为-1,表示两个线程都获得了互斥锁,这意味着</p>
<p><code>sem_wait(&amp;mutex)</code>可以被两个线程"同时"执行,</p>
<p>这意味着其中一个线程首先执行<code>sem_wait(&amp;mutex)</code>到一半的时候睡觉了,轮到另一个线程执行<code>sem_wait(&amp;mutex)</code></p>
<p>而<code>sem_wait(&amp;mutex)</code>被实现为一个不可中断的一条龙操作</p>
<p>因此不可能出现<code>mutex=-1</code>的情况</p>
<h2 id="经典ipc问题">经典IPC问题</h2>
<h3 id="哲学家就餐问题还没想明白">哲学家就餐问题(还没想明白)</h3>
<blockquote>
<p>要我说,都饿死才好,thus我就不用考一个67分的马原儿了</p>
</blockquote>
<p>说了这么一个事情</p>
<p>五个憨批哲学家在一起吃面条子,圆桌子上只有五根儿筷子.人要吃饭的时候要用两根筷子.人不吃饭的时候要么在胡思乱想,要么在挨饿.</p>
<p>哲学家的三种状态:</p>
<p>1.进食,正在占用左右的筷子</p>
<p>2.思考,进食完毕之后立刻放下筷子,思考,思考状态不需要进食</p>
<p>3.饥饿,思考完毕之后立刻进入饥饿状态,一旦条件允许应立刻进食</p>
<p>哲学家会做的事情:</p>
<p>1.首先思考</p>
<p>2.获得桌面控制权<code>mutex</code>锁,这个控制权某时刻只允许做多由一个人掌控.如果获得不了则在<code>mutex</code>的等待队列挂着.</p>
<blockquote>
<p>这里mutex的作用是只允许某时刻桌子上有一个人放下或者拿起筷子</p>
</blockquote>
<p>3.获得<code>mutex</code>之后,立刻设置自己为饥饿状态</p>
<p>4.检查左右是否有人在吃饭,如果有则自己不能吃.否则设置自己的状态为进食,并且给</p>
<p>不管有没有吃到饭,检查一次就立刻放开<code>mutex</code>锁</p>
<p>5.如果第4步</p>
<p>2.然后设置自己为饥饿状态</p>
<p>3.检查左右是否有人进食,如果有则说明自己的筷子不够,保持饥饿状态,放权</p>
<ol start="4" type="1">
<li></li>
</ol>
<p>怎么安排让吃饭不打架并且让效率最高呢?</p>
<blockquote>
<p>假算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		think();</span><br><span class="line">		take_fork(i);<span class="comment">//线程不安全的take_fork函数</span></span><br><span class="line">		take_fork((i+<span class="number">1</span>)%N);</span><br><span class="line">		eat();</span><br><span class="line">		put_fork(i);</span><br><span class="line">		put_fork((i+<span class="number">1</span>)%N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然是存在同步问题的,三号线程执行<code>take_fork(3)</code>和二号线程执行<code>take_fork(3)</code>是存在线程同步问题的.有可能被同时执行,这就相当于一根筷子被两个人拿着</p>
<p>改进</p>
<p>方便安排期间,整个桌子看成一个大临界区,某一时刻只允许一个哲学家进食.用一个互斥锁<code>mutex</code>就可以实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">philosopher</span><span class="params">(<span class="type">void</span>*para)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=*(<span class="type">int</span>*)para;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		think();</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//桌子上锁</span></span><br><span class="line">		eat();</span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//桌子下锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是这时候桌子上无根筷子的拜访就没有意义了,反正只允许一个哲学家进食,他想用哪根就用哪根</p>
<p>这样可以保证不打架,但是实际上5根筷子最多允许同一时刻两个哲学家进食,因此这种方法的并行性并不好</p>
</blockquote>
<h3 id="生产者消费者问题">生产者消费者问题</h3>
<p>生产者线程和消费者线程共享一个n个槽的有限缓冲区,生产者反复产生新的项目并将其插入缓冲区中.</p>
<p>消费者不断从缓冲区按照FIFO规则取出这些项目,然后消费之</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531080219711.png"
alt="image-20220531080219711" />
<figcaption aria-hidden="true">image-20220531080219711</figcaption>
</figure>
<p>缓冲区用一个大小为<code>n</code>的<code>int</code>型队列表示,每个int表示一个空槽</p>
<p>那么可以实现一个队列,<code>push</code>相当于生产者动作,<code>pop</code>是消费者动作.用信号量保证互斥问题</p>
<h4 id="缓冲区数据结构">缓冲区数据结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;Queue;		<span class="comment">//普通队列,不同步</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_init</span><span class="params">(Queue*,<span class="type">int</span>)</span>;<span class="comment">//初始化一个队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_destroy</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue*,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(Queue*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Queue <span class="built_in">queue</span>;<span class="comment">//临界区</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;<span class="comment">//临界区互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> cnt_used;<span class="comment">//已使用槽数</span></span><br><span class="line">    <span class="type">sem_t</span> cnt_unused;<span class="comment">//空槽数</span></span><br><span class="line">&#125;Safe_Queue;<span class="comment">//同步队列,封装了一个成员对象Queue queue</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_init</span><span class="params">(Safe_Queue*,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_destory</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_empty</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_full</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue*,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_pop</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_length</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="函数实现">函数实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct&#123;</span></span><br><span class="line"><span class="comment">//     int *buf;</span></span><br><span class="line"><span class="comment">//     int n;</span></span><br><span class="line"><span class="comment">//     int front;</span></span><br><span class="line"><span class="comment">//     int rear;</span></span><br><span class="line"><span class="comment">// &#125;Queue;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_init</span><span class="params">(Queue* this,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    this-&gt;n=n+<span class="number">1</span>;<span class="comment">//实际上要多开一个槽,因为front==rear的时候表示缓冲区空</span></span><br><span class="line">    this-&gt;buf=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    this-&gt;front=this-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_destroy</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(this-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;front==this-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (this-&gt;rear+<span class="number">1</span>)%this-&gt;n==this-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    this-&gt;buf[(++this-&gt;rear)%(this-&gt;n)]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=this-&gt;buf[(++this-&gt;front)%(this-&gt;n)];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (this-&gt;rear+this-&gt;n-this-&gt;front)%this-&gt;n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct&#123;</span></span><br><span class="line"><span class="comment">//     Queue queue;</span></span><br><span class="line"><span class="comment">//     sem_t mutex;//临界区互斥锁</span></span><br><span class="line"><span class="comment">//     sem_t cnt_used;//已使用槽数</span></span><br><span class="line"><span class="comment">//     sem_t cnt_unused;//空槽数</span></span><br><span class="line"><span class="comment">// &#125;Safe_Queue;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_init</span><span class="params">(Safe_Queue* this,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    queue_init(&amp;this-&gt;<span class="built_in">queue</span>,n);</span><br><span class="line">    sem_init(&amp;this-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;this-&gt;cnt_unused,<span class="number">0</span>,n);</span><br><span class="line">    sem_init(&amp;this-&gt;cnt_used,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_destory</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    queue_destroy(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_empty</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    status=empty(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_full</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    status=full(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> status;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;<span class="comment">//生产者向队列中push元素</span></span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_unused);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_used);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_pop</span><span class="params">(Safe_Queue* this)</span>&#123;<span class="comment">//消费者从队列中pop元素</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_used);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    x=pop(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_unused);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_length</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    l=length(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试非同步队列">测试非同步队列</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line">Queue <span class="built_in">queue</span>;</span><br><span class="line"><span class="type">int</span> cnt_push=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!full(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        push(&amp;<span class="built_in">queue</span>,<span class="number">1</span>);</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//此句话需要保证互斥打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in thread %ld,queue length=%d\n&quot;</span>,pthread_self(),length(&amp;<span class="built_in">queue</span>));</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    queue_init(&amp;<span class="built_in">queue</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    queue_destroy(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531093702627.png"
alt="image-20220531093702627" />
<figcaption aria-hidden="true">image-20220531093702627</figcaption>
</figure>
<p>如果queue是线程同步的,一定不会出现两个相同的length</p>
<p>出现这种情况的原因是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    this-&gt;buf[(++this-&gt;rear)%(this-&gt;n)]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>length=90时</p>
<p>线程1取得<code>this-&gt;rear</code>并放到寄存器之后并没有立刻自增写回,而是在此时睡觉,</p>
<p>导致线程2也取得和线程1相同的<code>this-&gt;rear</code>放到寄存器,</p>
<p>线程2将寄存器中的<code>this-&gt;rear</code>快照自增后写回到临界区<code>buf</code>中,此时<code>length=91</code>,线程2打印91</p>
<p>线程1醒了,其睡觉前保存的线程上下文中<code>this-&gt;rear</code>是一开始的状态,线程1也将寄存器中的<code>this-&gt;rear</code>快照自增然后写回临界区buf,此时<code>length=91</code>,线程1打印91</p>
<p>这时两个线程对寄存器中<code>this-&gt;rear</code>的快照自增然后写回,实际上写到了<code>buf</code>的同一位置,并且导致<code>this-&gt;rear</code>只增加了1</p>
<h4 id="测试同步队列">测试同步队列</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line">Safe_Queue safe_queue;</span><br><span class="line"><span class="type">int</span> cnt_push=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">safe_func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!safe_full(&amp;safe_queue))&#123;</span><br><span class="line">        safe_push(&amp;safe_queue,<span class="number">1</span>);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in thread %ld,safe_queue length=%d\n&quot;</span>,pthread_self(),safe_length(&amp;safe_queue));</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    safe_init(&amp;safe_queue,<span class="number">100</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,safe_func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,safe_func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    safe_destory(&amp;safe_queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用同步队列就不会有刚才的错误</p>
<h4 id="多个信号量">多个信号量?</h4>
<p>在<code>Safe_Queue</code>的<code>push</code>函数的实现中用到了多个信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_unused);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不能直接写成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只考虑了临界区有没有线程在访问,没有考虑临界区还有没有空槽,如果临界区都写满了,即使没有线程在临界区中,也不应该继续写入</p>
<p>那为啥记录空槽数要用信号量?用一个普通的整数变量不可以吗?</p>
<p>即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!cnt_unused);</span><br><span class="line">    --cnt_unused;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    ++cnt_used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设<code>cnt_unused=1</code>,</p>
<p>此时<code>while(!cnt_unused);</code>完全有可能被两个线程同时判定失效,跳过循环,执行<code>--cnt_unused;</code>,导致<code>cnt_unused=0</code>或者<code>-1</code></p>
<p>显然空槽数量为一个非负数,这是不合法的</p>
<p>因此要限制某时刻最多只有一个线程访问<code>cnt_unused</code>,因此用信号量实现</p>
<h3 id="读者写者问题">读者写者问题</h3>
<p>同一个文件(或者说共享变量,临界区)被两种性质的线程访问:</p>
<p>只读线程:该种线程只是读取共享变量,不做修改</p>
<p>读写线程:该种线程会修改共享变量</p>
<p>显然共享变量允许被多个线程观摩但是只能允许同一时刻被一个线程修改.在被修改的时候不允许被其他任何读或者写的线程访问.</p>
<p>还要考虑一个读和写优先级的问题</p>
<p><strong>如果读优先</strong></p>
<p>如果当前有只读线程正在访问临界区,则后来的只读线程无需等待,直接进入临界区</p>
<p>如果当前有只读线程正在访问临界区,则后来的读写线程需要等待所有的只读线程读取完毕,临界区没有任何线程时才能进入临界区.即使在等待前面的只读线程时被后面的只读线程插队并被迫增加等待时间也没办法</p>
<p>如果当前有读写线程正在访问临界区,则当其读写完毕之后,首先允许只读线程进入临界区,如果没有只读线程才会允许读写线程进入临界区</p>
<p><strong>如果写优先</strong></p>
<p>如果当前有只读线程正在访问临界区,当其读完毕后首先允许读写线程进入临界区,如果没有读写线程在排队才会允许只读线程进入临界区</p>
<p>如果当前读写线程正在访问临界区,当其写完毕退出临界区后,立即允许下一个读写线程进入临界区,如果没有读写线程在排队,才会允许读线程进入临界区</p>
<h4 id="读优先">读优先</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> my_time=<span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;the buffer at first&quot;</span>;<span class="comment">//全局数组作为临界区</span></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> w;</span><br><span class="line"><span class="type">int</span> cnt_reader=<span class="number">0</span>;<span class="comment">//记录临界区中的读者数量</span></span><br><span class="line"><span class="comment">//由于临界区中至多有一个写者,因此不需要记录写者数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="type">int</span> read_time=my_time;</span><br><span class="line">    <span class="keyword">while</span>(--read_time)&#123;</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//此处上锁的作用是,要修改cnt_reader的值和作家的锁</span></span><br><span class="line">        ++cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">            sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//mutex的作用更像是一个闸机,限制一人一杆</span></span><br><span class="line">        do_read();</span><br><span class="line">        <span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        --cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="type">int</span> write_time=my_time;</span><br><span class="line">    <span class="keyword">while</span>(--write_time)&#123;</span><br><span class="line">        sem_wait(&amp;w);</span><br><span class="line">        <span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(temp,<span class="string">&quot;buffer that modified by writer thread %ld&quot;</span>,pthread_self());</span><br><span class="line">        do_write(temp);</span><br><span class="line">        sem_post(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    my_time=atoi(argv[<span class="number">1</span>]);<span class="comment">//使用命令行参数决定循环次数上限,防止程序一直运行</span></span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    cnt_reader=<span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        pthread_create(&amp;rtid[i],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;wtid[i],<span class="literal">NULL</span>,writer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        pthread_join(rtid[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(wtid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="作家">作家</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;w);</span><br><span class="line"><span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(temp,<span class="string">&quot;buffer that modified by writer thread %ld&quot;</span>,pthread_self());</span><br><span class="line">do_write(temp);</span><br><span class="line">sem_post(&amp;w);</span><br></pre></td></tr></table></figure>
<p><code>w</code>是一个针对作家的互斥锁,不光读者用w来排挤作家,作家也用w排挤作家</p>
<p>当w为0的时候作家打死也不允许进入临界区.</p>
<p>读者和作家都有权力修改w的值,</p>
<p>作家修改w避免其他作家进入临界区这个好理解,就是防止同一个临界区有两个作家打架</p>
<p>当有一个读者进入临界区时就会修改w为0,此时只允许其他读者进入临界区,不允许作家进入</p>
<p>当最后一个读者退出临界区时才会放开w=1,允许卑微的作家进入临界区</p>
<h5 id="读者">读者</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;mutex);<span class="comment">//此处上锁的作用是,要修改cnt_reader的值和作家的锁</span></span><br><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">    sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//mutex的作用更像是一个闸机,限制一人一杆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_read();<span class="comment">//读取临界区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;w);</span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>读者有两次关于<code>mutex</code>的上锁和开锁,其作用可以举一个例子进行类比</p>
<blockquote>
<p>坐地铁时我们要刷卡或者刷二维码过闸机,每次只允许一个人刷卡过闸机,一人一杆,过了闸机就意味着有权力做地铁了,<code>++cnt_reader</code>就相当于把自己放到了地铁上</p>
<p>这里的mutex就起到了闸机的作用,限制读线程一个一个修改<code>cnt_reader</code>,防止两个线程同时修改<code>cnt_reader</code>但是最终<code>cnt_reader</code>只增加了1这种情况.</p>
<blockquote>
<p>更直观的,如果不用mutex锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">    sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_read();<span class="comment">//读取临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程1将<code>cnt_reader</code>放到寄存器中还没来得及将自增写回到<code>cnt_reader</code>就睡了一觉,线程2读取到的是线程1写回之前的<code>cnt_reader</code>,两个线程读取到了相同的<code>cnt_reader</code>,自增后写回的也是相同的<code>cnt_reader</code>,导致两个线程同时挤进临界区但是读者计数器只增加了1</p>
</blockquote>
</blockquote>
<p>这种情况下写者可能用数量灌死读者,让读者永远没有读的机会</p>
<p>试想如果只有一个读者线程,成百上千个写者线程,假设读者线程首先进入临界区,此时读者持有w锁,这使得所有写者无能狂怒,均卡在<code>sem_wait(&amp;w);</code>这个位置</p>
<p>然后读者终于出了临界区,释放了w锁,此时在等待w锁的写者1已经成百上千,其中有一个幸运儿被选中获得了w锁进入临界区,这又使得剩下的写者和这一个读者无能狂怒,都卡在<code>sem_wait(&amp;w);</code>这个位置</p>
<p>当写者1写完出了临界区,他释放了w锁,此时w锁的等待队列中有成百上千的写者和一个读者.但是<code>sem_wait(&amp;w);</code>并不知道是读者还是写者在等待w,它会随便挑一个正在等待<code>w</code>的线程分配w锁.</p>
<p>显然一个读者是抢不过成千上万个写者的.</p>
<p>这个可怜的读者只有很小的几率能够进入临界区去读这些作家的著作了</p>
<p>但是只要读者数量多点儿,稍微有点儿规模就没有作家的事了</p>
<p>读者1进入临界区之后给所有读者开了绿色通道,读者鱼贯而入,当首先进入临界区的读者1出了临界区时,还会有读者2守着临界区的大门不让作家进来.</p>
<p>甚至当读者1兜兜转转又站在临界区大门口时,临界区中还有读者n把这门.如此形成一道密不透风的墙,作家永远没有进入临界区的机会</p>
<blockquote>
<p>这让我想到保卫萝卜中用冰花阵一直冻住怪物直到刮痧刮死</p>
<p>冰花绽放的一秒相当于读者持有w锁,冰花凋谢相当于读者释放w锁</p>
<p>冰花的cd相当于读者本次出了临界区到下一次进入临界区之前的时间空当</p>
<p>冰花阵无间隙绽放相当于w锁一直被众多读者线程持有,永远轮不到写者持有w锁</p>
</blockquote>
<h4 id="写优先">写优先</h4>
<h5 id="作家-1">作家</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span>*p)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(temp,<span class="string">&quot;modified by thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="type">int</span> mytime=max_time;</span><br><span class="line">    <span class="keyword">while</span>(--mytime)&#123;</span><br><span class="line">        sem_wait(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">        cnt_writer++;<span class="comment">//记录过了闸机的写者数量</span></span><br><span class="line">        <span class="keyword">if</span>(cnt_writer==<span class="number">1</span>)&#123;</span><br><span class="line">            sem_wait(&amp;rsem);<span class="comment">//只要是有一个写者,写者就要控制读者的锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">        sem_wait(&amp;wsem);<span class="comment">//等待临界区清空时(上一个临界区中的线程可能是写者也可能是读者),允许一个写者控制写者锁,进入临界区</span></span><br><span class="line"></span><br><span class="line">        my_write(temp);<span class="comment">//访问临界区</span></span><br><span class="line">        </span><br><span class="line">        sem_post(&amp;wsem);<span class="comment">//本写者释放写者锁,允许下一个写者进入临界区,但是读者不可以,因为rsem锁尚未被释放</span></span><br><span class="line">        sem_wait(&amp;y);<span class="comment">//本写者要再次经过闸机离开了,需要对共享变量cnt_writer保护</span></span><br><span class="line">        cnt_writer--;</span><br><span class="line">        <span class="keyword">if</span>(cnt_writer==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;rsem);<span class="comment">//最后一个写者离开时才放开读者锁rsem,此时读者才被允许进入临界区</span></span><br><span class="line">        &#125;   </span><br><span class="line">        sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个作家线程要考虑的事情:</p>
<p>1.首先要作家线程一个一个经过闸机,记录已经通过闸机,站在临界区门口的作家数量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     sem_wait(&amp;y);//写者闸机</span><br><span class="line">         cnt_writer++;//记录过了闸机的写者数量</span><br><span class="line">...</span><br><span class="line">     sem_post(&amp;y);//写者闸机</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2.第一个站在临界区门口的作家需要给读者使个绊,上读者锁,不允许读者再进入临界区,目前在临界区中的读者就得过且过吧</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(cnt_writer==1)&#123;</span><br><span class="line">    sem_wait(&amp;rsem);//只要是有一个写者,写者就要控制读者的锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.本作家写作的时候不允许其他作家打扰</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;wsem);<span class="comment">//等待临界区清空时(上一个临界区中的线程可能是写者也可能是读者),允许一个写者控制写者锁,进入临界区</span></span><br><span class="line"></span><br><span class="line">my_write(temp);<span class="comment">//访问临界区</span></span><br><span class="line"></span><br><span class="line">sem_post(&amp;wsem);<span class="comment">//本写者释放写者锁,允许下一个写者进入临界区,但是读者不可以,因为rsem锁尚未被释放</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>4.本作家写完了首先允许其他作家继续写作,直到最后一个离开临界区的作家放开读者锁,允许读者进入.作家离开时也要经过闸机严格计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;y);<span class="comment">//本写者要再次经过闸机离开了,需要对共享变量cnt_writer保护</span></span><br><span class="line">cnt_writer--;</span><br><span class="line"><span class="keyword">if</span>(cnt_writer==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;rsem);<span class="comment">//最后一个写者离开时才放开读者锁rsem,此时读者才被允许进入临界区</span></span><br><span class="line">&#125;   </span><br><span class="line">sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="读者-1">读者</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mytime=max_time;</span><br><span class="line">    <span class="keyword">while</span>(--mytime)&#123;</span><br><span class="line">        sem_wait(&amp;z);<span class="comment">//多层闸机</span></span><br><span class="line">        sem_wait(&amp;rsem);</span><br><span class="line">        sem_wait(&amp;x);</span><br><span class="line">        ++cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;</span><br><span class="line">            sem_wait(&amp;wsem);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;x);</span><br><span class="line">        sem_post(&amp;rsem);</span><br><span class="line">        sem_post(&amp;z);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in reader thread %ld,&quot;</span>,pthread_self());</span><br><span class="line">        my_read();</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;x);</span><br><span class="line">        --cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;wsem);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;z)</span><br><span class="line">	sem_wait(&amp;rsem)</span><br><span class="line">	...</span><br><span class="line">	sem_post(&amp;rsem)</span><br><span class="line">sem_wait(&amp;z)</span><br></pre></td></tr></table></figure>
<p><code>&amp;rsem</code>信号量被嵌套在<code>&amp;z</code>里面,其目的是什么呢?需要完整分析一遍步骤</p>
<p>1.试想如果已经有写者给读者上了锁,</p>
<p>2.第一个读者会持有z锁并等待<code>rsem</code>锁,在<code>rsem</code>的等待队列上挂着</p>
<p>3.第二个及以后的读者无法获得z锁,都在z的等待队列上挂着</p>
<p>4.当所有写者退出临界区,最后一个写者释放了rsem锁,此时第一个读者终于获得了rsem锁,它执行了下面步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;x);<span class="comment">//读者闸机</span></span><br><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;</span><br><span class="line">    sem_wait(&amp;wsem);<span class="comment">//给写者上锁,次锁直到最后一个离开临界区的读者放开wsem锁</span></span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;x);<span class="comment">//注意此处释放锁的顺序和刚才加锁的顺序正好相反,FILO</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在即将执行<code>sem_wait(&amp;wsem)</code>时,如果来一个写者,由于读者1已经持有了<code>rsem</code>锁,因此该写者会卡在<code>sem_wait(&amp;rsem);</code>,写者根本没有可能抢到<code>wsem</code>锁.因此这里担心写者是多余的</p>
</blockquote>
<p>5.读者1释放<code>rsem</code>锁</p>
<blockquote>
<p>此时读者1仍然没有释放z锁,因此其他读者依旧进不来.并且wsem锁也没有被放开,写者也进不来</p>
</blockquote>
<p>7.读者1释放z锁,从一群读者中挑选了一个幸运儿读者2获得z锁,剩下的读者仍然挂在z的等待队列上</p>
<p>8.读者2持有z锁之后还要经过<code>rsem</code>闸机.</p>
<p>此时读者2可能面临两种情况:</p>
<blockquote>
<p>(1)如果在
"读者1获得<code>rsem</code>时到读者2企图持有<code>rsem</code>锁"
期间,<strong>有一个写者站在临界区门口,读者1已经释放<code>rsem</code>锁也有可能会分配给写者,该写者会持有rsem锁,导致读者2过不了rsem闸机</strong></p>
<p>诚如是,则读者2只持有z一个锁,不会影响写者.读者1后来也只会用到x锁,因此读者2也不会影响读者1.</p>
<p>实际上此时读者2的状态和读者1一开始的状态相同.</p>
</blockquote>
<blockquote>
<p>(2)如果期间没有写者到达,或者读者2足够幸运被分配了rsem锁</p>
<p>此时读者2的状态和读者1拿到rsem锁之后的状态相同</p>
</blockquote>
<p>此时读者1最慢还在访问临界区,最快已经通过x闸机走人了</p>
<blockquote>
<p>(1)如果读者1走人了那么读者2面临的状态和读者1完全相同</p>
</blockquote>
<blockquote>
<p>(2)读者1刚出临界区,马上要执行下面语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;x);</span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;wsem);</span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;x);</span><br></pre></td></tr></table></figure>
<p>或许读者2和读者1会因为x发生互斥,但是这都是两个读者一个要进闸机一个要出闸机或者两个都出闸机的矛盾,对于其他锁无影响,此时写者最靠近临界区也得挂在<code>sem_wait(&amp;wsem);</code></p>
<p>只有当读者1和2都离开时,wsem才会释放,写者才<strong>会获得锁</strong></p>
</blockquote>
<p>到此可以得到z锁的作用:</p>
<p>当有写者持有<code>rsem</code>锁时,z锁保证,<code>rsem</code>等待队列上只允许最多有一个读者,该读者持有z锁导致其他读者无法挂到<code>rsem</code>等待队列上</p>
<p>写者对读者的影响:</p>
<p>当至少有一个写者在排队时,写者就会锁上<code>rsem</code>,让顶多一个读者挂在<code>rsem</code>上,其他读者挂在z上.</p>
<p>该挂在rsem上的读者一定是<strong>所有读者中</strong>最早进入临界区的.</p>
<p>只有当最后一个写者离开临界区时才会释放<code>rsem</code>锁,此时<code>rsem</code>上的读者获得<code>rsem</code>锁,</p>
<p>此时该读者持有<code>rsem</code>,z,其他读者依然得挂在z上</p>
<h2 id="多线程提高并发性">多线程提高并发性</h2>
<p>CSAPP上勉强举了一个例子,什么例子呢?</p>
<p>计算 <span class="math display">\[
\sum_{i=1}^n i
\]</span> 即正整数前n项和</p>
<p>为了使用并发,这里不用等差数列求和公式</p>
<p>CSAPP上说了这么一个意思,要开四个线程计算的话,每个线程负责计算10个数的和</p>
<p>假设<code>n=40</code>,</p>
<p>线程1就负责计算<span
class="math inline">\(\sum_{i=1}^{10}i\)</span></p>
<p>线程2就负责计算<span
class="math inline">\(\sum_{i=11}^{20}i\)</span></p>
<p>以此类推</p>
<p>各个线程的计算结果求和也是有讲究的</p>
<p>大体上有这么三种情况:</p>
<p>1.开一个全局变量<code>global_sum</code>,每个线程的每次循环直接将数加到<code>global_sum</code>上</p>
<p>2.开一个全局数组<code>global_sums[4]</code>,线程1每次循环将i加到<code>global_sums[0]</code>上,线程1每次循环将i加到<code>global_sums[1]</code>上,以此类推.最终在主线程中循环累加一下<code>global_sums</code></p>
<p>3.每个线程开一个局部变量<code>local_sum</code>,每次循环将i加到<code>local_sum</code>上,每个线程返回局部变量值交给主线程累加</p>
<p>第一种显然是不可以的,<code>global_sum</code>是一个临界区,不加保护被多线程访问会出现同步错误,解决方法是每个线程每次向<code>global_sum</code>加数的时候都要上锁下锁,但是这个时间代价非常大</p>
<p>第二种可以,但是全局数组是开在虚拟内存中的<code>.data</code>节上的,线程需要频繁地访问内存,时间代价也相对较大</p>
<p>第三种局部变量<code>local_sum</code>可能会优化为寄存器变量,诚如是,则速度会很快.即使<code>local_sum</code>被放在线程栈区,也比去<code>data</code>节访问内存快</p>
<p>CSAPP还给出的建议是,有几个处理器最多就开几个线程.每个处理器分别负责一个线程这时最大效率,如果线程数比处理器多则处理器会有线程调度,线程上下文的切换也会有时间开销</p>
<h2 id="线程安全问题">线程安全问题</h2>
<h3 id="线程不安全函数">线程不安全函数</h3>
<h4 id="不保护临界区的函数">不保护临界区的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//全局变量作为临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">count</span><span class="params">(<span class="type">void</span> *para)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;++i)&#123;</span><br><span class="line">        ++cnt;<span class="comment">//不保护临界区变量cnt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,count,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,count,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnt=%d&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">cnt=<span class="number">1024846</span></span><br></pre></td></tr></table></figure>
<p>期望的运行结果应该是<code>cnt=2000000</code>,实际上<code>cnt=1024846</code>,即同步错误</p>
<h4 id="保持跨越多个调用状态的函数">保持跨越多个调用状态的函数</h4>
<p>啥意思呢?本次函数调用的返回值依赖于先前的结果或者中间结果</p>
<p>比如伪随机数函数<code>rand</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601202115691.png"
alt="image-20220601202115691" />
<figcaption aria-hidden="true">image-20220601202115691</figcaption>
</figure>
<p>本次形成的<code>next_seed</code>会用在下一次伪随机数的生成.</p>
<p>如果两个线程同时获取了本次<code>next_seed</code>,那么可以预见的是,下一次两个线程生成的伪随机数是相同的</p>
<p>解决方法是,每次的随机数种子都有调用者传递,不同线程保存不同的种子.避开使用共享变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601205339539.png"
alt="image-20220601205339539" />
<figcaption aria-hidden="true">image-20220601205339539</figcaption>
</figure>
<p>这种不使用共享变量的线程安全函数叫做可重入函数</p>
<h4 id="返回指向静态变量的指针的函数">返回指向静态变量的指针的函数</h4>
<p>啥函数会返回静态变量呢?或者说为啥要返回静态变量呢?</p>
<p>首先glibc库中就有这种返回静态变量的函数,比如<code>ctime</code>函数.其存在是有合理性的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601202455160.png"
alt="image-20220601202455160" />
<figcaption aria-hidden="true">image-20220601202455160</figcaption>
</figure>
<blockquote>
<p>一个函数要返回一个字符串,该字符串在内存上应该放在哪里呢?</p>
<blockquote>
<p>如果函数这样写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getstr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;dustball&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报告警告:局部变量str作为返回</p>
<p>为啥会警告呢?str作为函数栈上变量,当函数返回之后,函数栈会被退掉.那么此时str指针指向的是一块没有被分配的内存区域.或者当主函数又调用新函数,新函数的函数栈覆盖掉getstr的函数栈时,此时str指针就指向了新函数的函数栈区.</p>
<p>即指针要么指向NULL,要么指向一个在生存期内的对象.否则就会成为野指针</p>
</blockquote>
<p>那么应该怎么写才能保证一个函数下才定义的变量在函数退出后依然存活呢?使用静态变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getstr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> str[] = <span class="string">&quot;dustball&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为静态变量会存放在.data或者.bss全局变量区,而不是放在函数栈下</p>
</blockquote>
<p>返回静态变量为什么就线程不安全了?比如下面程序<code>mythread.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">getstr</span><span class="params">(<span class="type">void</span> *para)</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;maxn;++i)&#123;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;str from thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1;</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,getstr,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,getstr,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> *s1,*s2;</span><br><span class="line">    pthread_join(tid1,(<span class="type">void</span>**)&amp;s1);</span><br><span class="line">    pthread_join(tid2,(<span class="type">void</span>**)&amp;s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>,s1,s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期望的是分别从两个线程中获得两个字符串,在主线程中交给<code>s1,s2</code>保管</p>
<p>实际上<code>s1,s2</code>指向的是同一块内存地址,即都是<code>.data</code>区域的静态变量<code>buffer</code>,多线程不会拷贝全局变量区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# gcc mythread.c -o mythread -lpthread</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">str from thread 139788891407936</span><br><span class="line">str from thread 139788891407936</span><br></pre></td></tr></table></figure>
<p><strong>怎么解决 这类错误呢?</strong></p>
<p>我们现在指望的是函数主动返回一个值供我们引用,但是函数的局限性就是它多次调用只能返回一个值,实际上这个静态变量还是临界区</p>
<p>我们现在给函数提供一个内存区域,让函数把数据写到我们指定的区域,<strong>在不同的线程中指定不同的区域.这样就可以避免多个引用指向同一块内存区域,即不使用共享变量</strong></p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">getstr</span><span class="params">(<span class="type">void</span> *dest)</span> &#123;<span class="comment">//dest作为缓冲区</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)dest,<span class="string">&quot;str from thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1;</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>];<span class="comment">//在主线程申请栈上申请两个缓冲区,两个线程各自写入一块缓冲区</span></span><br><span class="line">    <span class="type">char</span> s2[<span class="number">100</span>];</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,getstr,(<span class="type">void</span>*)s1);<span class="comment">//在主线程创建对等线程的时候指定线程 使用哪一块缓冲区</span></span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,getstr,(<span class="type">void</span>*)s2);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);		<span class="comment">//不必使用函数返回值,直接写NULL</span></span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>,s1,s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# gcc mythread.c -o mythread -lpthread</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">str from thread 139961335383616</span><br><span class="line">str from thread 139961326990912</span><br></pre></td></tr></table></figure>
<h4 id="调用线程不安全函数的函数">调用线程不安全函数的函数</h4>
<p>线程调用的所有函数都是线程执行流的一部分,不光最高层的线程例程函数需要考虑线程安全性,只要是线程执行流上的所有涉及临界区的函数都应当考虑线程安全问题</p>
<h3 id="库函数的线程安全性">库函数的线程安全性</h3>
<p>大多数库函数都是线程安全的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601205715921.png"
alt="image-20220601205715921" />
<figcaption aria-hidden="true">image-20220601205715921</figcaption>
</figure>
<h2 id="死锁问题">死锁问题</h2>
<p>死锁问题大概是指:</p>
<p>线程1想要资源2但是资源2被线程2掌握</p>
<p>线程2想要资源1但是资源1被线程1掌握</p>
<p>没有获得资源则两个线程都需要中断或者忙等待.每个线程都不愿主动放弃已经获取的资源</p>
<blockquote>
<p>注意这里资源数量默认为1,也可以大于1,但是还是用1理解比较方便</p>
</blockquote>
<blockquote>
<p>更规范的定义:</p>
<p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件.那么该进程集合就是死锁的</p>
<blockquote>
<p>死锁是对一个进程集合而言的</p>
</blockquote>
<blockquote>
<p>显然死锁的概念也适用于线程集合上</p>
</blockquote>
</blockquote>
<h3 id="建模表示">建模表示</h3>
<h4 id="线程图建模">线程图建模</h4>
<p>用线程图表示这个事情:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601210209517.png"
alt="image-20220601210209517" />
<figcaption aria-hidden="true">image-20220601210209517</figcaption>
</figure>
<p>禁止区即<code>s,t</code>资源剩余数量为-1的区域,这显然是不可能的</p>
<p>当两个线程都互补想让争抢资源,并且争抢资源
的顺序不对时,就容易发生死锁</p>
<p>图中死锁区域的状态就是:</p>
<p>线程1已经抢到了s,并且吃里扒外想要抢夺t</p>
<p>线程2已经抢到了t,并且吃里扒外想要抢夺s</p>
<p>双方都有对方想要的东西但是双方都不打算交出自己的资源,于是两个线程都无限忙等</p>
<p>在线程图上由于状态转移只能向右或者向上转移(时间的推移方向)</p>
<p><strong>而死锁区就是右侧核上侧被禁止区完全挡住的区域</strong></p>
<h4 id="有向图建模">有向图建模</h4>
<p>图片来自<code>&lt;&lt;MOS&gt;&gt;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601211535232.png"
alt="死锁的有向图建模" />
<figcaption aria-hidden="true">死锁的有向图建模</figcaption>
</figure>
<p>圆圈⭕节点表示的是进程(或者说线程),</p>
<p>方框节点表示的是资源,</p>
<p>资源R指向进程A的有向边,表示进程A已经占有资源R</p>
<p>进程B指向资源S的有向边,表示进程B需要得到资源S</p>
<p>这里的最大资源数量就可以不只有1个了,比如T资源有两个就可以画两个方框,通过合理安排(也不用安排,显然的事情)就可以解决死锁</p>
<p>当一个资源分配图上的一些圆圈方框连接成一个圈时(圈上的箭头同逆时针或者同顺时针),就产生了死锁</p>
<blockquote>
<p>如果资源数量为1时,发生死锁就是一辈子的死锁</p>
<p>如果资源数量大于1,则死锁有可能是暂时的,比如本例中的T资源,要是存在另一个T资源,就可以解燃眉之急</p>
</blockquote>
<h3 id="死锁的判断">死锁的判断</h3>
<h4 id="互斥锁死锁的判断">互斥锁死锁的判断</h4>
<h5 id="无死锁的充分条件">无死锁的充分条件</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601221022640.png"
alt="image-20220601221022640" />
<figcaption aria-hidden="true">image-20220601221022640</figcaption>
</figure>
<p><code>&lt;&lt;MOS&gt;&gt;</code>上举的例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601221103392.png"
alt="image-20220601221103392" />
<figcaption aria-hidden="true">image-20220601221103392</figcaption>
</figure>
<p>啥意思呢?比如线程(或者进程)A和线程B都要使用1和2两种资源</p>
<p>那么线程A和B都应该按照申请1,申请2,释放2,释放1或者申请2,申请1,释放1,释放2这种顺序</p>
<p>否则如图b,<strong>可能</strong>会产生A申请到1同时B申请到2,此后两个进程就都没有进展了.注意这里说法是可能,也有可能A进程执行完毕才轮到B进程执行,此时就没有死锁</p>
<h5 id="充要条件">充要条件</h5>
<p>资源图上只要没有强联通分量(圈上的箭头同方向)则不是死锁</p>
<p>资源图上只要是有强连通分量就有死锁</p>
<blockquote>
<p>甚至可以复习一下塔杨算法求scc</p>
</blockquote>
<h4 id="计数锁死锁的判断">计数锁死锁的判断</h4>
<h5 id="存在死锁的充分条件">存在死锁的充分条件</h5>
<p><code>&lt;&lt;MOS&gt;&gt;</code>给出的算法</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601224743929.png"
alt="image-20220601224743929" />
<figcaption aria-hidden="true">image-20220601224743929</figcaption>
</figure>
<blockquote>
<p>符号意义:</p>
<p>现有资源数量表示某种资源的最大数量,包括已用的和没用的</p>
<p>可用资源数量表示某种资源还没有被进程占用的资源</p>
<p>设共有n种资源,编号1到n</p>
<p>现有资源向量<span
class="math inline">\(\bold{E}=\{E_1,E_2,...,E_n\}\)</span>,其中<span
class="math inline">\(E_i\)</span>表示第i种资源的总数量(包括已占用的和未占用的)</p>
<p>可用资源向量<span
class="math inline">\(\bold{A}=\{A_1,A_2,...,A_n\}\)</span>,其中<span
class="math inline">\(A_i\)</span>表示第i种资源的可用数量(尚未被占用的数量)</p>
<p>当前分配矩阵 <span class="math display">\[
\bold{M}=
\begin{bmatrix}
  \bold{C_1}\\
  \bold{C_2}\\
  ...\\
  \bold{C_n}
\end{bmatrix}
=
\begin{bmatrix}
  C_{11}\ C_{12}\ ...\ C_{1n}\\
  C_{21}\ C_{22}\ ...\ C_{2n}\\
  ...\\
  C_{n1}\ C_{n2}\ ...\ C_{nn}
\end{bmatrix}
\]</span> 其中每一行都是一个向量<span
class="math inline">\(\bold{C_i}\)</span>表示第i个进程已经占有的资源向量</p>
<p>请求矩阵 <span class="math display">\[
\bold{Q}=
\begin{bmatrix}
  \bold{R_1}\\
  \bold{R_2}\\
  ...\\
  \bold{R_n}
\end{bmatrix}
=
\begin{bmatrix}
  R_{11}\ R_{12}\ ...\ R_{1n}\\
  R_{21}\ R_{22}\ ...\ R_{2n}\\
  ...\\
  R_{n1}\ R_{n2}\ ...\ R_{nn}
\end{bmatrix}
\]</span> 其中每行都是一个向量<span
class="math inline">\(\bold{R_i}\)</span>表示第i个进程还需要的资源向量(资源请求向量)</p>
<p>定义两个向量的抽象代数关系: <span class="math display">\[
\bold{U}@ \bold{V}\Leftrightarrow \forall i\in[1,n],U_i@ V_i
\]</span> 比如小于等于关系 <span class="math display">\[
\bold{U}\le \bold{V}\Leftrightarrow \forall i\in[1,n],U_i\le V_i
\]</span> 即U的每一项都要小于等于V的每一项,则向量<span
class="math inline">\(\bold{U}\le\bold{V}\)</span></p>
</blockquote>
<p>死锁检查算法:</p>
<p>遍历<span class="math inline">\(\bold{Q}\)</span>矩阵,用<span
class="math inline">\(\bold{A}\)</span>向量与<span
class="math inline">\(\bold{Q}\)</span>的所有行向量进行比较,如果存在<span
class="math inline">\(\bold{R_i}\le \bold{A_i}\)</span>,则<span
class="math inline">\(\bold{A}=\bold{A}+\bold{C_i}\)</span>,并且将<span
class="math inline">\(\bold{R_i}\)</span>置0,下一次遍历时不再考虑第i行</p>
<p>重复上述步骤,</p>
<p>如果<span class="math inline">\(\bold
Q\)</span>矩阵的所有行都可以被消去,则通过消去的方法分配资源是不存在死锁的.不按照消去方法就有可能产生死锁</p>
<p>如果<span
class="math inline">\(\bold{Q}\)</span>矩阵就是有几行消不去,则一定有死锁产生</p>
<h3 id="死锁的避免">死锁的避免</h3>
<p>银行家算法:</p>
<h4 id="单个资源的银行家算法">单个资源的银行家算法:</h4>
<p>总是挑选当前需要资源数最少的进程先分配资源并执行,待该进程执行完毕后回收其资源,壮大银行资本</p>
<blockquote>
<p>如果资源需求量最少的进程都没法满足,那么已经产生了死锁</p>
</blockquote>
<h4 id="多个资源的银行家算法">多个资源的银行家算法</h4>
<p>实际上该算法刚才我们已经学习过了,计数锁的判断时的消去方法就应用了银行家算法:</p>
<blockquote>
<p>总是挑软柿子捏</p>
</blockquote>
<p>总是挑选当前能够满足资源要求的进程首先执行,并在其执行完后获取其原本占有的资源,壮大银行资本</p>
<blockquote>
<h2 id="mos的段子手">MOS的段子手</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601231623980.png"
alt="image-20220601231623980" />
<figcaption aria-hidden="true">image-20220601231623980</figcaption>
</figure>
<blockquote>
<p>"似乎只是为了让一些图论家有事可做罢了"</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/27/birth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/27/birth/" class="post-title-link" itemprop="url">Imperial March!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-27 22:28:00" itemprop="dateCreated datePublished" datetime="2022-05-27T22:28:00+08:00">2022-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-04 22:23:02" itemprop="dateModified" datetime="2022-06-04T22:23:02+08:00">2022-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>别天天提你那"Imperial March"整的自己真和维达这么牛逼似的.</p>
<p>你就是一风暴兵,你也配有个性?</p>
<p>学习学成这个熊样子,你也配觉得自己是个东西?</p>
<p>你是有多闲啊,还tm想拥有爱情?</p>
<p>你清高你了不起,看不起刷抖音的,你自己倒是B站刷一天</p>
<p>你笑话人家LSP,转头自己一个人的时候就看人家跳舞</p>
<p>打算法竞赛的时候你自我感动自以为学了多少东西,多少东西?校赛一考你什么都不是</p>
<p>你天天熬夜觉得自己多卷了多少东西似的,还不是刷B站玩游戏了?</p>
<p>你坐教室里学了不到一个小时就觉得自己满了,CSAPP一章你能看一个星期,你是王八还是蜗牛啊?</p>
<p>天天骂学校课程安排的不合理,你倒是自己有思路有明确方向啊?</p>
<p>天天看不起学英语的学政治的,你也六级优秀啊?你也玩个权术啊?</p>
<p>你能吗?</p>
<p>你是谁啊?</p>
<p>你什么都不是,你没牌面</p>
<p>你满肚子里的骄傲屁哪怕自己咽回去也比放出来恶心人家强!</p>
<p>你该干啥干啥!你永远是个风暴兵!你不是什么绝地武士!你就是个垃圾!</p>
<p>你还有一年就得决定本科的去向了!你现在是刀殂上的死鱼烂虾!</p>
<p>你下面的总结,笑死,自我感动罢了</p>
<p>你也配过生日?</p>
<p>你醒醒吧!</p>
<h1 id="imperial-march">Imperial March</h1>
<p>天临4年(或改元卢雷元年)夏肆月廿伍,球过其而立生日,因缺思厅,时值大二下期末,回顾其两年大学过活有感,作此总结</p>
<p>期末将近,本学期的学习又进入收官阶段,好像本学期初的上学期期末考试才刚发生过.</p>
<p>白驹过隙,时间像<a
target="_blank" rel="noopener" href="https://music.163.com/#/song?id=29734863">Mountains</a>里频率逐渐加快的时钟滴答.</p>
<p>眨眼之间,时钟已经快如脉搏,巨浪已如秦岭般近在眼前</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/793E2A715B3B08FCA69FBFFE1CD38551.jpg"
alt="阳台·秦岭" />
<figcaption aria-hidden="true">阳台·秦岭</figcaption>
</figure>
<p>在过去的两年里,球子都经历了啥呢?</p>
<h2 id="n个id">n个id</h2>
<p><strong>shockwave</strong></p>
<blockquote>
<p>abandoned,那时候我还是个变形金刚G1大波粉</p>
</blockquote>
<p><strong>野心勃勃的帝国球</strong></p>
<blockquote>
<p>abandoned,太过于中二,让人笑话</p>
</blockquote>
<p><strong>死灰复燃的帝国球</strong></p>
<blockquote>
<p>abandoned,有点政治敏感,德棍打死</p>
</blockquote>
<p><strong>deutschball</strong></p>
<blockquote>
<p>using,波兰球漫画爱好者,但实际上是政治白痴</p>
</blockquote>
<p><strong>dustball</strong></p>
<blockquote>
<p>using,在大一下刚认识伍幺零时她认为我的id</p>
</blockquote>
<p><strong>灰球球</strong></p>
<blockquote>
<p>using,dustball的翻译,叠词者,恶心也</p>
</blockquote>
<h2 id="三个方向">三个方向</h2>
<p>两年的大学生活波澜壮阔</p>
<p>大一时还天真地认为自己是个算法竞赛的料,最终在校赛之时才发现自己不过学了ACMer和OIer的皮毛上的一根毛</p>
<p>大二上惊叹于HTML5网页的精美与微信小程序的便携快捷,好像就认定以后要做前端</p>
<p>大二下却又转变方向改学网络安全,又学了CTFer身上的一根毛</p>
<p>每个方向都带给我新鲜感,都让我感叹算法的精妙与工业的美丽</p>
<h2 id="两台机器">两台机器</h2>
<p>两年来最默默无闻的伙伴莫过于两台计算机,还有计算机上天天打交道的各种软件</p>
<p>一台DELL Vostro 3583,我称它为Commando,现在已经退休作为靶场了</p>
<p>一台Lenovo LEGION Y9000P2021H,我称它为Executor</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214030953.png"
alt="image-20220527214030953" />
<figcaption aria-hidden="true">image-20220527214030953</figcaption>
</figure>
<p>最初只有一个软件朋友Dev-CPP,后来Typora,WPS,VScode等等伙计齐聚一堂</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214116346.png"
alt="image-20220527214116346" />
<figcaption aria-hidden="true">image-20220527214116346</figcaption>
</figure>
<p>从前,喜怒哀乐只能和它们聊,它们也只会听.只有程序给出的唯一的输出,能让我感到百分百的安全感.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527215958751.png"
alt="image-20220527215958751" />
<figcaption aria-hidden="true">image-20220527215958751</figcaption>
</figure>
<p>解决程序的报错或者纠正算法的错误,能让我感到帮助一个朋友解决问题的成就感.</p>
<p>把各个工具加入到Executor的环境变量path然后把vscode作为Executor的舰桥,通过终端向Executor发号施令.这让我感到朋友们齐聚一堂的热闹</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527215136408.png"
alt="image-20220527215136408" />
<figcaption aria-hidden="true">image-20220527215136408</figcaption>
</figure>
<p>探索VScode,Typora的各种功能,让我感觉这是在了解朋友们的更多方面...</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214304580.png"
alt="typora sequence" />
<figcaption aria-hidden="true">typora sequence</figcaption>
</figure>
<h2 id="一群兄弟">一群兄弟</h2>
<p>我们越来越熟悉,成为同一条壕沟里的战友.</p>
<p>我们相互<code>define</code>绰号,被随意组CP却没有人生气.</p>
<p>我们心有灵犀,一呼百应去码头给兄弟过生日</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/m.jpg"
alt="m" />
<figcaption aria-hidden="true">m</figcaption>
</figure>
<p>我们资料共享,兄弟之间没有猜忌</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214949645.png"
alt="image-20220527214949645" />
<figcaption aria-hidden="true">image-20220527214949645</figcaption>
</figure>
<p>我们敢于争先,比先进不比摆烂,软卓的名号在软工日益响亮.</p>
<p>我们潜力无限,未来可期.</p>
<p>虽然我们即将散作满天星,但是我们聚如一团火.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/%E8%BD%AF%E5%8D%93.jpg"
alt="软卓" />
<figcaption aria-hidden="true">软卓</figcaption>
</figure>
<h2 id="一本好书">一本好书</h2>
<p>那必须是相见恨晚的CSAPP.</p>
<p>如果能重来,我一定在大一的时候把这本书翻个西巴烂,</p>
<p>这样在我大二学C++的时候不至于连个源头文件干啥都不知道.</p>
<p>在我学操作系统的时候不至于连个虚拟内存技术都不知道.</p>
<p>在我学计算机组成原理的时候不至于连个寻址方式都不知道.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527213322734.png"
alt="image-20220527213322734" />
<figcaption aria-hidden="true">image-20220527213322734</figcaption>
</figure>
<p>在这本书上值得下大功夫多敲代码多做实验</p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/23/汇编语言/">CSAPP-chapter3
x86-64汇编语言 | Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/27/链接/">CSAPP-chapter7 链接 |
Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/23/异常/">CSAPP-chapter8
异常与进程 | Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/17/虚拟内存/">CSAPP-chapter9
虚拟内存 | Deutschball's blog (dustball.top)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/27/%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">CSAPP-chapter7 链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-27 12:20:00" itemprop="dateCreated datePublished" datetime="2022-05-27T12:20:00+08:00">2022-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-09 20:50:49" itemprop="dateModified" datetime="2024-03-09T20:50:49+08:00">2024-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文的typora onedark风格见:<a
target="_blank" rel="noopener" href="https://dustball.top/HTML/linkage.html">linkage</a></p>
<h1 id="链接">链接</h1>
<p>win11+vscode+wsl</p>
<p>链接是对.o,.a,.so而言的,在此之前要先经过编译,即程序从源代码.c文件编译成目标文件.o</p>
<h2 id="从.c到.o">从.c到.o</h2>
<h3 id="将要遭遇的概念">将要遭遇的概念</h3>
<p>GCC:(GNU Compiler Collection)GNU编译器集合</p>
<p>gcc和g++都属于"编译器驱动程序"(driver),实际上编译器是cc1(C语言),cc1plus(C++语言)</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:~/mydir# whereis gcc</span><br><span class="line">gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc /usr/share/man/man1/gcc.1.gz</span><br></pre></td></tr></table></figure>
<p>在linux系统上自带,可以用whereis 命令查询gcc的位置</p>
<p>我们实际调用的是第一个<code>/usr/bin/gcc</code></p>
<p>/usr目录:unix system
resources缩写,包含了所有共享文件,是unix系统最重要的目录之一</p>
<p>用户的家原来也在这里,但是现在改成了/home</p>
<p>/usr/bin目录:所有可执行文件,比如gcc,g++</p>
</blockquote>
<p>GAS:GNU汇编器（GNU
Assembler），简称为GAS.使用gcc命令时汇编器(as)和链接器(ld)都是GAS提供的</p>
<h3 id="gcc和g的区别">gcc和g++的区别</h3>
<p>包括但是不止下面两条</p>
<ol type="1">
<li></li>
</ol>
<p>gcc对于.c文件调用cc1编译器,对于.cpp文件调用cc1plus编译器</p>
<p>g++不管是.c和.cpp都会调用cc1plus编译器</p>
<ol start="2" type="1">
<li></li>
</ol>
<p>在链接时gcc==不会==传递给链接器链接C++标准库的命令但是g++会</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v;<span class="comment">//此处需要使用STL中的vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这样一个test.cpp文件</p>
<p>使用gcc命令编译则会报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out</span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o: <span class="keyword">in</span> <span class="keyword">function</span> `__gnu_cxx::new_allocator&lt;int&gt;::deallocate(int*, unsigned long)<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.cpp:(.text._ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim[_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim]+0x20): undefined reference to `operator delete(void*)&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o:(.data.rel.local.DW.ref.__gxx_personality_v0[DW.ref.__gxx_personality_v0]+0x0): undefined reference to `__gxx_personality_v0<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<p>但是使用g++命令编译则不会报错</p>
<p>如果想让gcc命令编译时让链接器可以链接标准库可以使用命令行参数<code>-lstdc++</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out -lstdc++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是即使加上该参数,使用gcc和g++对于.cpp的编译还是有区别的.</p>
<p>啥区别我现在不知道,也不想知道</p>
<p>因此现阶段在编译.c源代码时就用gcc命令,编译.cpp源代码时就用g++命令</p>
<h3
id="gcc命令行参数和.c到.exe的过程">gcc命令行参数和.c到.exe的过程</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/441e2211a121079fdd5f07542a3b2313.png"
alt="image-20220401003811834" />
<figcaption aria-hidden="true">image-20220401003811834</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6ade9eae51f7c18adf10e6905673a554.png"
alt="image-20220401003612021" />
<figcaption aria-hidden="true">image-20220401003612021</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/86a785b63483f768b90553bb2b84a6e6.png"
alt="image-20220331235005241" />
<figcaption aria-hidden="true">image-20220331235005241</figcaption>
</figure>
<h4 id="预编译-e">预编译-E</h4>
<p>预编译命令只能作用于源代码文件(.c,.cpp)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E balabala.c</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp balabala.c</span><br></pre></td></tr></table></figure>
<p>1.将所有include(包括库文件和自己写的文件)展开</p>
<p>2.替换所有的宏定义</p>
<p>比如</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> word;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> a=N;</span><br><span class="line">  word b=N;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc test.c -E</code>(使用<code>cpp test.c</code>作用相同)之后会将预编译内容打印到屏幕,但是不会生成.i文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9bbf91702b485741525fd0e7657384e9.png"
alt="image-20220331222506965" />
<figcaption aria-hidden="true">image-20220331222506965</figcaption>
</figure>
<p>(截图仅为一小部分)</p>
<p>观察到<code>#define N 10</code>消失,N被10替换</p>
<p><code>typedef</code>起别名并不会被替换</p>
<p>使用-o命令行参数指定预编译生成文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>然后使用<code>ls -sh -l</code>名令以列表方式查看当前目录下文件大小</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/213bf06d5c5260f55778c0ad5cb99876.png"
alt="image-20220331224027046" />
<figcaption aria-hidden="true">image-20220331224027046</figcaption>
</figure>
<p>可见.i文件明显比.c文件大</p>
<h5 id="i命令行参数指定自定义头文件">-I命令行参数指定自定义头文件</h5>
<p><strong>如果需要包含的头文件和就在当前目录下则自动包含,</strong></p>
<p>比如当前目录(mydir/)下</p>
<p>有一个自定义头文件<code>myheader.h</code>里面只有一个变量a的定义</p>
<p>有一个test.c里面没有定义a直接拿来用</p>
<p>此时预编译是可以通过的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># ls -l</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">10</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">43</span> myheader.h</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">51</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">44</span> test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cpp test.c -o test.i</span></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cat test.i</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;myheader.h&quot;</span> <span class="number">1</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在其他目录则需要<code>- I &lt;directory&gt;</code>指定包含文件所在的目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r-- 1 root root 10 3月  31 22:43 myheader.h</span><br><span class="line">-rw-r--r-- 1 root root 51 3月  31 22:44 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">mv</span> myheader.h ..</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span></span><br><span class="line">test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line">test.c:1:10: fatal error: myheader.h: 没有那个文件或目录</span><br><span class="line">    1 | <span class="comment">#include &quot;myheader.h&quot;</span></span><br><span class="line">      |          ^~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
<p>将原本与test.c同目录的myheader.h移动到上级目录(..)中,此时使用cpp命令则在当前目录下找不到myheader.h报错了</p>
<p>此时使用<code>-I &lt;directory&gt;</code>指定上级目录(..)为包含路径则预编译通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -I ..</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;../myheader.h&quot; 1</span></span><br><span class="line">int a=10;</span><br><span class="line"><span class="comment"># 2 &quot;test.c&quot; 2</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译compilation-s">编译(Compilation)-S</h4>
<p>编译命令可以应用于前面所有类型的文件(.c,.i)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S balabala.c</span><br></pre></td></tr></table></figure>
<p>作用是将源代码(或者说预编译之后的源代码)编译成汇编语言</p>
<p>将一个全空的c程序(一个字都没写的,这样写当然不对,但是是在后来的某一阶段报错)test.c编译成汇编语言,会在同一目录下生成test.s文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.c -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.s</span><br><span class="line">  .file <span class="string">&quot;test.c&quot;</span></span><br><span class="line">  .text</span><br><span class="line">  .ident      <span class="string">&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span></span><br><span class="line">  .section    .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">  .section    .note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">  .align 8</span><br><span class="line">  .long  1f - 0f</span><br><span class="line">  .long  4f - 1f</span><br><span class="line">  .long  5</span><br><span class="line">0:</span><br><span class="line">  .string      <span class="string">&quot;GNU&quot;</span></span><br><span class="line">1:</span><br><span class="line">  .align 8</span><br><span class="line">  .long  0xc0000002</span><br><span class="line">  .long  3f - 2f</span><br><span class="line">2:</span><br><span class="line">  .long  0x3</span><br><span class="line">3:</span><br><span class="line">  .align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure>
<p>关于汇编语言后来会学,但不是现在</p>
<h4 id="汇编assembly-c">汇编(Assembly)-c</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc balabala.c -c</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as balabala.c</span><br></pre></td></tr></table></figure>
<p>汇编命令可以应用于前面过程中生成的所有文件(.c,.i,.s)</p>
<blockquote>
<p><strong>汇编过程将上一步的汇编代码转换成机器码(machine
code)</strong>，这一步产生的文件叫做<strong>目标文件</strong>，是二进制格式</p>
</blockquote>
<p>对于一个啥也没写的test.c文件,预编译,编译,汇编都是可以通过的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">echo</span> &gt; test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 root root 1 3月  31 23:04 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.c</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -o test.i</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.i -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root   1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root 149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.s -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r-- 1 root root    1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root  149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 1072 3月  31 23:06 test.o</span><br><span class="line">-rw-r--r-- 1 root root  298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.o</span><br><span class="line">ELF&gt;�@@</span><br><span class="line">  GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0GNU���test.c.symtab.strtab.shstrtab.text.data.bss.comment.note.GNU-stack.note.gnu.property!@@,0@,5lEp�� PXX</span><br></pre></td></tr></table></figure>
<p>到此为止,我们完成了下图中红框中的部分</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/37c9008fc9dd09ea605e54bb4b5787ff.png"
alt="image-20220401001520336" />
<figcaption aria-hidden="true">image-20220401001520336</figcaption>
</figure>
<p>下面来到了链接阶段对应图中load time</p>
<h4 id="链接linking">链接(Linking)</h4>
<p>ld负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。</p>
<p>附加的目标文件包括==静态连接库和动态连接库==。</p>
<p>还是一个字也没写的test</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.o -o test.out</span><br><span class="line">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: <span class="keyword">in</span> <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">(.text+0x24): undefined reference to `main&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ld test.o</span><br><span class="line">ld: 警告: 无法找到项目符号 _start; 缺省为 0000000000401000</span><br></pre></td></tr></table></figure>
<p>在链接阶段终于报错了</p>
<p>报错原因是程序总要有一个main函数入口,一个空的test自然没有main函数</p>
<h5 id="库">库</h5>
<p>库就是现成的可以复用的"代码".</p>
<p>这里"代码"加了引号,因为库不是我们使用的高级语言代码,而是机器码</p>
<blockquote>
<p>一看到"库"我第一反应是包含的头文件</p>
<p><code>#include &lt;stdio.h&gt;</code>之后使用-E编译命令可以看到预编译生成的.i文件,里面全都是声明,没有实现,函数也都是一些接口,没有函数体,显然只通过include头文件是没法运行这些函数的,那么这些函数的实现在哪里呢?程序怎么找到的函数实现呢?</p>
<p>从前道听途说的是在.cpp文件中,在cpp源文件中我们确实可以看到函数的实现,但是我们在编译过程中一直没有与cpp文件发生关联啊?只有.cpp文件包含了.h但是没有见.h包含.cpp啊?从前我幼稚可笑的想法是会根据文件名自动找,比如<code>#include "balabala.h"</code>之后编译器会自动在同目录下找同名的<code>balabala.cpp</code>.但是通过<code>gcc -E</code>命令可以清楚的看到并没有.并且从来没有规定说头文件和源文件的文件名相同.我原来的想法纯属胡扯</p>
<p>库,头文件,源文件的区别和联系,参考https://www.runoob.com/w3cnote/cpp-header.html</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/389c0f3472cca4d688f97a3e3fc606f3.png"
alt="image-20220401011132234" />
<figcaption aria-hidden="true">image-20220401011132234</figcaption>
</figure>
<p><strong>可以得到几点结论:</strong></p>
<p>1..cpp这种拓展名不是必须的</p>
<p>2.寻找函数实现是在链接阶段完成的,而引入只有声明的头文件是为了使得编译可以通过</p>
<p>3.函数实现以.o或.obj格式参与到链接中</p>
<p>4.unix下即使不引入头文件,只指明链接阶段需要的.o文件,也可以通过编译,但不是一个好习惯</p>
<p>5.我们程序中使用到符号(函数名,变量名等)会在==参与链接的所有.o文件==中寻找,重复定义报错发生在该阶段</p>
<p><strong>经过前面的学习,我们自己了解到的知识</strong></p>
<p>1..o是.s文件经过汇编生成的,我们自己写的程序也会经历该阶段</p>
<p>2.链接时会连接多个.o文件,包括==自己的==和==库中的==</p>
<p>那么虽然菜鸟教程里没有提到"库",==我们也可以推测,预定义的.cpp编译生成的.o文件就是库==</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37806908/article/details/97686753">这篇博客证明了我的猜测</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/4776958a286c0e87718c164b107099d0.png"
alt="image-20220401013407948" />
<figcaption aria-hidden="true">image-20220401013407948</figcaption>
</figure>
<p>.a是多个.o合在一起,和.o是一个性质的文件</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">这个博客也证明了我的想法</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3d75cf7547fcd04ae74a1286e24df585.png"
alt="image-20220401015054137" />
<figcaption aria-hidden="true">image-20220401015054137</figcaption>
</figure>
<p>还有一个问题,makefile是啥?</p>
<p>记得在上学期用Dev-cpp写一卡通乘车系统项目时,建立项目后会在项目目录下生成一个makefile文件</p>
<p>现在用devcpp建立一个空白项目</p>
<p>项目根目录下有这么几个文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/24c6bc0e7cf5d3cdec752f46ef64de9b.png"
alt="image-20220401013807320" />
<figcaption aria-hidden="true">image-20220401013807320</figcaption>
</figure>
<p>其中Makefile.win</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Project: project</span><br><span class="line"># Makefile created by Dev-C++ <span class="number">5.15</span></span><br><span class="line"></span><br><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br><span class="line">WINDRES  = windres.exe</span><br><span class="line">OBJ      = main.o</span><br><span class="line">LINKOBJ  = main.o</span><br><span class="line">LIBS     = -<span class="string">L&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/lib32&quot;</span> -<span class="type">static</span>-libgcc -m32 -g3</span><br><span class="line">INCS     = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span></span><br><span class="line">CXXINCS  = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include/c++&quot;</span></span><br><span class="line">BIN      = project.exe</span><br><span class="line">CXXFLAGS = $(CXXINCS) -Og -m32 -g3</span><br><span class="line">CFLAGS   = $(INCS) -Og -m32 -g3</span><br><span class="line">RM       = del /q</span><br><span class="line"></span><br><span class="line">.PHONY: all all-before all-after clean clean-custom</span><br><span class="line"></span><br><span class="line">all: all-before $(BIN) all-after</span><br><span class="line"></span><br><span class="line">clean: clean-custom</span><br><span class="line">	$&#123;RM&#125; $(OBJ) $(BIN)</span><br><span class="line"></span><br><span class="line">$(BIN): $(OBJ)</span><br><span class="line">	$(CC) $(LINKOBJ) -o $(BIN) $(LIBS)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br></pre></td></tr></table></figure>
<p>这里好像把<code>g++.exe -D__DEBUG__</code>命令重新起名CPP</p>
<p>后来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br></pre></td></tr></table></figure>
<p>在这里带入的话相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc.exe -D__DEBUG__ -c main.c -o main.o -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -Og -m32 -g3</span><br></pre></td></tr></table></figure>
<p>用gcc执行了命令,==并且用-I参数指定了链接阶段需要加入链接的库文件的目录==</p>
<p>由此可见,Makefile不过是一个脚本罢了,是我们不用在命令行在==链接阶段==输入冗长的命令</p>
<p>如果在项目中加入源文件比如<code>test.cpp</code>并且编译运行main.c</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fcb8fec5ac02c2c60d79be136b9451b7.png"
alt="image-20220401015434869" />
<figcaption aria-hidden="true">image-20220401015434869</figcaption>
</figure>
<p>之后会在Makefile.win里面增加一条记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.o: test.cpp</span><br><span class="line">	$(CC) -c test.cpp -o test.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是向项目中加入头文件比如test.h然后编译运行main.c则不会在Makefile.win中增加记录</p>
<p>说明Makefile只管.cpp和.c文件时如何编译为.o文件的,头文件.h它毫不关心</p>
</blockquote>
<p>到此我们知道了多个文件是如何互相找到,在何时互相找到的,也就是链接要做的事情</p>
<p>下面为了更清楚地理解库的作用,我们需要亲自写几个库试试</p>
<p>然后我查阅了这个博客https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>库有两种,一种是静态库,一种是动态库</p>
<p><strong>静态库</strong>(.a,.lib)</p>
<p>静态库会在链接时与我们自己编译生成的.o文件一起链接打包到可执行文件,这种链接方式称为"静态链接"</p>
<p>静态库可以看作一组目标文件(.o)的集合</p>
<p>静态库对函数库的链接是在编译链接时期完成的</p>
<p>程序运行时与函数库已经没有关系,方便移植</p>
<p>浪费空间,不容易更新</p>
<p><strong>动态库</strong>(.so.dll)</p>
<blockquote>
<p>windows上的动态库.dll我们早就见过了</p>
<p>比如红警3根目录下面就可以见到</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/c34f7f9dcbb4783085a0b1277ec42747.png"
alt="image-20220401113523196" />
<figcaption aria-hidden="true">image-20220401113523196</figcaption>
</figure>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自播客</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/719104933403b1f0681d43d0c32dc318.png"
alt="image-20220401112348428" />
<figcaption aria-hidden="true">image-20220401112348428</figcaption>
</figure>
<p>动态库的出现是为了解决两个问题</p>
<p>1.静态库占用空间,多个程序可能有相同的静态库</p>
<p>2.更新时,静态库即使静态库稍微改动一点,也需要全部重新编译(全量更新)</p>
<p>动态库相对这两点的特性</p>
<p>1.多个程序复用同一个库</p>
<p>2.增量更新,哪里更新就编译哪里</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/42c1dee76a6f7a6ec8b7985e2496bc18.png"
alt="image-20220401112727292" />
<figcaption aria-hidden="true">image-20220401112727292</figcaption>
</figure>
<p>这就要求动态库在运行时才会装载</p>
<h5 id="静态库的使用">静态库的使用</h5>
<p>在<code>/home/deutschball/mydir</code>文件夹下写了三个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root 156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root 985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root 872 4月   1 09:43 Point.h</span><br></pre></td></tr></table></figure>
<p><strong>point.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> x, y;</span><br><span class="line">		string name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;);</span><br><span class="line">		<span class="built_in">Point</span>();</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getX</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getY</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function">string <span class="title">getName</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getDistance</span><span class="params">(<span class="type">const</span> Point &amp;)</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="type">const</span> Point &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>point.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = p.name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;n) &#123;</span><br><span class="line">	name = n;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setName</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getX</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getY</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Point:: <span class="built_in">getName</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::getDistance</span><span class="params">(<span class="type">const</span> Point &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	os &lt;&lt; p.name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">p</span><span class="params">(<span class="string">&quot;A&quot;</span>, <span class="number">5.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自博客</a></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/965e66764fab853fdf885313e4535d87.png" /></p>
<p>准备工作完毕,下面开始创建静态库</p>
<p>main.cpp为入口,Point.h是头文件,我们需要将Point.cpp创建为静态库</p>
<p>1.将Point.cpp编译成目标文件.o</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ Point.cpp -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>2.使用<code>ar</code>工具将刚才生成的目标文件打包成.a静态库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ar -crv libpoint.a Point.o</span><br><span class="line">a - Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 32</span><br><span class="line">-rw-r--r-- 1 root root 8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux下静态库的命名规范是lib开头</p>
</blockquote>
<p>我们没有指定libpoint.a的目录,因此在当前文件夹下形成</p>
<p>到此,静态库libpoint.a建立完毕</p>
<p>下面我们在编译<code>main.cpp</code>时<strong>使用</strong>静态库</p>
<p><code>-L</code>指定静态库目录</p>
<p><code>-l</code>指定静态库和动态库的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main</span><br><span class="line">.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 52</span><br><span class="line">-rw-r--r-- 1 root root  8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 19824 4月   1 10:07 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>可执行文件main.out就生成了</p>
<blockquote>
<p>-L指定静态库目录,由于我们的静态库就在当前文件夹,于是-L ./</p>
<p>-l指定静态库名字,会自动在名字前面加上lib,在后面加上.a后缀,于是指定-l
point就找到了libpoint.a</p>
</blockquote>
<h5 id="动态库的使用">动态库的使用</h5>
<p>linux上动态库的命令规则libbalabala.so,前缀lib后缀.so</p>
<p>windows上动态库使用比较复杂,不管他了</p>
<p><strong>创建动态库</strong></p>
<p>首先生成目标文件,注意使用-fPIC命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -fPIC -c Point.cpp</span><br></pre></td></tr></table></figure>
<p><code>-fPIC</code>(<strong>position independent
code</strong>)作用是创建==地址无关==代码</p>
<blockquote>
<p>与地址无关?</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fead4e692210f2756e3b97a437a26de1.png"
alt="image-20220401115548277" />
<figcaption aria-hidden="true">image-20220401115548277</figcaption>
</figure>
<p>参考博客<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/fengliu-/p/10216878.html">linux编译动态库
fPIC作用 - feng..liu - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>然后<strong>生成</strong>动态链接库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -shared -o libpoint.so Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 60</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br></pre></td></tr></table></figure>
<p>生成了libpoint.so</p>
<p>到此动态库创建完毕,下面<strong>使用</strong>动态库</p>
<p>尝试用使用静态库的方法使用动态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 80</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 18064 4月   1 12:17 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">./main.out: error <span class="keyword">while</span> loading shared libraries: libpoint.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以通过编译但是out文件执行出错,说是找不到libpoint.so</p>
<p>==那么动态库到底在哪里呢?==</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6c1ebfe5e82c9f20cb3684876fca8ff8.png"
alt="image-20220401122038391" />
<figcaption aria-hidden="true">image-20220401122038391</figcaption>
</figure>
<p>使用第一种方法,将我们自己编写的动态库放在/usr/lib下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cp</span> libpoint.so /usr/lib</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">A(5,4)</span><br></pre></td></tr></table></figure>
<p>发现可以正常运行了</p>
<h3 id="参考文档">参考文档</h3>
<p><a
target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-how-programs-are-prepared-run">How
programs are prepared to run on z/OS</a></p>
<p>参考博客</p>
<p>https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>https://www.runoob.com/w3cnote/cpp-header.html</p>
<h2 id="目标文件">目标文件</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509190447711.png"
alt="image-20220509190447711" />
<figcaption aria-hidden="true">image-20220509190447711</figcaption>
</figure>
<p>又称为elf文件</p>
<p><code>executable and linkable file</code></p>
<blockquote>
<p>ELF文件有三种:</p>
<p>可重定位目标文件<code>.o</code></p>
<p>共享目标文件<code>.so</code></p>
<p>可执行目标文件<code>.out</code></p>
<p>编译器和汇编器生成可重定位目标文件和共享目标文件(<code>.o</code>),连接器生成可执行目标文件(<code>.out</code>)</p>
</blockquote>
<h2 id="可重定位目标文件.o">可重定位目标文件<code>.o</code></h2>
<p><code>.o</code>文件的结构</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509195158089.png"
alt="image-20220509195158089" />
<figcaption aria-hidden="true">image-20220509195158089</figcaption>
</figure>
<p>一个<code>.c</code>源文件就是一个模块</p>
<p><code>.c</code>源文件使用编译器和汇编器得到<code>.o</code>可重定位目标文件</p>
<h3 id="readelf命令的使用">readelf命令的使用</h3>
<p>对于<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>;<span class="comment">//在使用其他模块中定义的函数前,要先引用该函数,否则报编译错</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> val=sum(<span class="built_in">array</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc main.c -Og -c -o main.o</code>将其编译成为可重定位目标文件<code>main.o</code></p>
<p>下面对<code>main.o</code>使用<code>readelf</code>的一系列命令进行观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509193405618.png"
alt="image-20220509193405618" />
<figcaption aria-hidden="true">image-20220509193405618</figcaption>
</figure>
<h4 id="h打印elf文件头信息"><code>-h</code>打印elf文件头信息</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          776 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>1.<code>Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509194647169.png"
alt="image-20220509194647169" />
<figcaption aria-hidden="true">image-20220509194647169</figcaption>
</figure>
<p>魔数,表明本文件类型等基本信息</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>16进制</th>
<th>7f</th>
<th>45</th>
<th>4c</th>
<th>46</th>
<th>02</th>
<th>01</th>
<th>01</th>
</tr>
</thead>
<tbody>
<tr>
<td>ascii码或意义</td>
<td>DEL符</td>
<td>'E'</td>
<td>'L'</td>
<td>'F'</td>
<td>01表示32位<br />02表示64位</td>
<td>01表示小端法<br />02表示大端法</td>
<td>ELF版本号<br />通常为1</td>
</tr>
</tbody>
</table>
<p>后面9个字节==ELF标准==中无定义,用0填充,和前面的<code>7f 45 4c 46 02 01 01</code>凑成16个字节</p>
<p>2.<code>Start of program headers:          0 (bytes into file)</code></p>
<p>程序头开始位置,对于.o文件来说,它距离可执行还缺链接这一大步,程序头对他来说没意义</p>
<p>3.<code>Start of section headers:          776 (bytes into file)</code></p>
<p>节头开始时的字节,即本文件的第776字节开始时节头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184122775.png"
alt="image-20220510184122775" />
<figcaption aria-hidden="true">image-20220510184122775</figcaption>
</figure>
<p>使用010editor观察,<code>section header table</code>的起始位置是<code>0300h+8=776</code>字节</p>
<p>4.<code>Size of this header:               64 (bytes)</code></p>
<p>本头(elf文件头)的大小为64字节(16进制表示为0x40)即本elf头部分占用本文件的0到63字节,则下一部分即sections部分从0x40开始</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184615368.png"
alt="image-20220510184615368" />
<figcaption aria-hidden="true">image-20220510184615368</figcaption>
</figure>
<p>5.<code>Size of section headers:           64 (bytes)</code></p>
<p><code>section header table</code>中,每个<code>section</code>表项的大小</p>
<p>6.<code>Number of section headers:         13</code></p>
<p><code>section header table</code>中的表项数</p>
<p>5和6合计可以计算出<code>section header table</code>的大小为13*64=832字节</p>
<p>又知道<code>section header table</code>
的起始位置为<code>776</code>(10进制)字节处,加上该部分大小832字节可以计算得到本<code>.o</code>文件总大小为<code>1608</code></p>
<p>使用wc命令可以验证刚才计算(<code>wordcount</code>统计文件大小(字节数))</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# <span class="built_in">wc</span> main.o</span><br><span class="line">   3   13 1608 main.o</span><br></pre></td></tr></table></figure>
<p>7.<code>Section header string table index: 12</code></p>
<h4
id="s打印整个section-header-table表信息"><code>-S</code>打印整个<code>section header table</code>表信息</h4>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>表头</th>
<th>Name</th>
<th>Type</th>
<th>Address</th>
<th>Offset</th>
<th>Size</th>
<th>EntSize</th>
<th>Flags</th>
<th>Link</th>
<th>Info</th>
<th>Align</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>节名</td>
<td>节类型</td>
<td></td>
<td>在本文件中的偏移量</td>
<td>节大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">There are 13 section headers, starting at offset 0x308:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000	</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000001e  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000068</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000094</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  00000098</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000280</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  000000e8</span><br><span class="line">       0000000000000138  0000000000000018          11     9     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000220</span><br><span class="line">       000000000000002d  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000298</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以<code>.text</code>节为例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p><code>Offset=0x40</code>即本节在本文件中的<code>0x40</code>位置,又elfheader占用了前64个字节(0~0x3F),因此<code>.text</code>节是紧接着elfheader存放的,大小为<code>0x1e=30</code>字节</p>
<p>那么下一个节的起始位置就应该是<code>0x40+0x1e=0x5e</code></p>
<p>然而下一个节<code>.data</code>的<code>Offset=0x60</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">     0000000000000008  0000000000000000  WA       0     0     8;Align对齐为8</span><br></pre></td></tr></table></figure>
<p>用010editor观察发现0x5e和0x5f全是0,估计是考虑了对齐的原因</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510201200464.png"
alt="image-20220510201200464" />
<figcaption aria-hidden="true">image-20220510201200464</figcaption>
</figure>
<p>用objdump -s观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 4883ec08 be020000 00488d3d  ....H........H.=</span><br><span class="line"> 0010 00000000 e8000000 004883c4 08c3      .........H....  </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 01000000 02000000                    ........     </span><br><span class="line"> 如果0x5e和0x5f是.data的前两个字符,合计应该是10个字节,而readelf统计的data区大小为8字节</span><br></pre></td></tr></table></figure>
<p>可以断定<code>0x5e</code>和<code>0x5f</code>的<code>0</code>是对齐方式导致的</p>
<h4 id="观察某一节">观察某一节</h4>
<p>只需要在参数上指定该节的首字符,比如要观察<code>.rel</code>开头的节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -r main.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.text&#x27;</span> at offset 0x2f0 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000016  000700000002 R_X86_64_PC32     0000000000000000 .rodata - 4</span><br><span class="line">000000000020  001100000004 R_X86_64_PLT32    0000000000000000 <span class="built_in">printf</span> - 4</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.eh_frame&#x27;</span> at offset 0x320 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>
<p>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 c</span><br><span class="line">     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     8: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 f.2320</span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">    13: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 a</span><br><span class="line">    14: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM b</span><br><span class="line">    15: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>
<h3 id="可重定位目标文件的常用节">可重定位目标文件的常用节</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> e=<span class="number">30</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="text"><code>.text</code></h4>
<p>存放指令</p>
<p>使用<code>objdump -d main.o</code>可以观察<code>.text</code>的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	48 83 ec 10          	sub    $0x10,%rsp</span><br><span class="line">   c:	c7 45 fc 1e 00 00 00 	movl   $0x1e,-0x4(%rbp)</span><br><span class="line">  13:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1a &lt;main+0x1a&gt;</span><br><span class="line">  1a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  1f:	e8 00 00 00 00       	callq  24 &lt;main+0x24&gt;</span><br><span class="line">  24:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  29:	c9                   	leaveq </span><br><span class="line">  2a:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<h4 id="data"><code>.data</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p>存放已经初始化(且不为零)的全局变量或者局部变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203006548.png"
alt="image-20220510203006548" />
<figcaption aria-hidden="true">image-20220510203006548</figcaption>
</figure>
<p>如图被data节表管理的data节中只有10,20,40这三个已经赋值的全局或者静态变量</p>
<h4 id="bss"><code>.bss</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">     0000000000000000  0000000000000000  WA       0     0     1</span><br></pre></td></tr></table></figure>
<p>该部分只有一个节表表项,在节中实际不存在,只是起一个占位符的作用</p>
<p>未初始化的静态变量或者初始化为<code>0</code>的全局或静态变量,当程序运行时才会给<code>bss</code>变量在内存分配空间并赋值0</p>
<p><code>COMMON</code>存放未初始化的全局变量,这和链接有关</p>
<h4 id="rodata"><code>.rodata</code></h4>
<p><code>printf</code>要打印的字符串字面值就存放在该区域</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203554082.png"
alt="image-20220510203554082" />
<figcaption aria-hidden="true">image-20220510203554082</figcaption>
</figure>
<p><code>.rel</code>开头的节及其他节</p>
<p><code>.rel</code>的节和重定位有关</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203810791.png"
alt="image-20220510203810791" />
<figcaption aria-hidden="true">image-20220510203810791</figcaption>
</figure>
<p>链接依赖于符号<code>.symtab</code>节管理符号</p>
<h3 id="symtab节"><code>.symtab</code>节</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c=sum(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只将<code>main.c</code>编译成<code>main.o</code>可重定位目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -Og -c -o main.o</span><br></pre></td></tr></table></figure>
<p>然后<code>readelf -s</code>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     9: 0000000000000000    33 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 22%" />
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 2%" />
<col style="width: 25%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>项目</th>
<th>Num</th>
<th>Value</th>
<th>Size</th>
<th>Type</th>
<th>Bind</th>
<th>Vis</th>
<th>Ndx</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>意义</td>
<td>编号</td>
<td>符号在其所在节中,举例节首地址的偏移量</td>
<td>大小</td>
<td>类型(函数/对象等等)</td>
<td>属性,本地还是全局</td>
<td></td>
<td>section节索引,在section header table中确定</td>
<td>名称,这个字符串名称放在.strtab节中</td>
</tr>
</tbody>
</table>
<p><code>Ndx</code>中的值是该符号在本文件中的哪一节,<code>UND</code>则为本模块中引用的其他模块的符号</p>
<h3 id="符号和符号表">符号和符号表</h3>
<p><code>.o</code>目标模块都有一共符号表,其中包含该目标模块中定义和引用的符号信息</p>
<p>对于连接器来说有三种符号</p>
<p>1.本模块定义的全局符号,对其他模块可见</p>
<p>2.其他模块定义的全局符号,对本模块可见</p>
<p>3.本模块定义的静态符号,只对本模块可见</p>
<blockquote>
<p>static的作用类似于java中的private或者protected,而全局变量则相当于public修饰</p>
</blockquote>
<p>函数栈中的局部变量不会出现在符号表中,其符号由堆栈维护,或者说不需要符号.</p>
<p>每个符号都属于一个节</p>
<p>比如函数就属于text节,已初始化且不为0的全局变量属于.data节,未初始化的静态变量属于.bss节等等</p>
<blockquote>
<p><strong>只有.o可重定位目标模块中存在的</strong>,并且节头表.symtab中没有条目的三个伪节:</p>
<p>.ABS 不该被重定位的符号</p>
<p>.UNDEF 本模块中只有引用没有定义的符号</p>
<p><strong>.COMMON 未初始化的全局变量</strong></p>
</blockquote>
<blockquote>
<p>注意存放全局变量时,放在.COMMON和.bss的区别,static变量不会涉及链接问题,但是全局变量会</p>
<p>将未初始化的全局变量放到.COMMON,将已初始化为0的全局变量放到.bss,将已初始化不为零的全局变量放在data</p>
<p>这样做的目的和链接时符号的强弱性质有关,这都是后话了</p>
</blockquote>
<p>链接形成可执行目标文件之后这三个伪节就不复存在了</p>
<h3 id="符号解析">符号解析</h3>
<p>多个目标文件或者库还有命令行参数构成链接器的<strong>输入</strong></p>
<p>连接器在链接时,会给每个引用在其<strong>输入</strong>的一个模块的符号表中找到与该引用对应的符号定义</p>
<p>关键在于全局符号的引用解析</p>
<p>如果<strong>编译器</strong>遇到了一个引用并且在本模块中没有找到定义,则<strong>编译器</strong>会假设其定义在其他模块中,生成一共链接器符号表条目</p>
<p>如果链接器在所有输入的目标模块中都没有找到该引用的定义则报错</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//func只是一个引用,在本模块中没有定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghX.o:main.c:(.text+0xe): undefined reference to `func<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2.exe: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;&#125;<span class="comment">//func在本模块中有定义</span></span><br></pre></td></tr></table></figure>
<p>此时链接不会发生报错</p>
</blockquote>
<p>如果链接器找到了多个定义,则按照下面三条规则处理多重定义符号名</p>
<blockquote>
<p>强符号:函数,已初始化的全局变量(data或者bss节)</p>
<p>弱符号:未初始化的全局变量,放在COMMON伪节</p>
<p><code>int a;</code>这就是一个弱符号</p>
<p><code>int a=0;</code>这就是一个强符号</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220520170252584.png"
alt="image-20220520170252584" />
<figcaption aria-hidden="true">image-20220520170252584</figcaption>
</figure>
<p>因此将全局变量按照是否初始化,被分到common还是data或者bss节</p>
<p>common中符号的在链接时会被作为弱符号</p>
<h3 id="重定位">重定位</h3>
<p>重定位的两个步骤</p>
<h4 id="重定位节">1.重定位节</h4>
<p>将所有输入的目标文件合并成一个文件,由于每个目标文件都有.data等节,因此需要合并每个目标文件中的相同节,形成一个文件</p>
<p>如此,所有的符号定义相对于该文件都有一个确定的偏移量位置,此时就可以给每个符号一个虚拟内存地址了</p>
<h4
id="重定位节中的符号引用"><strong>2.</strong>重定位节中的符号引用</h4>
<p>在1中我们已经给每个符号定义确定了一个绝对的虚拟内存地址,但是怎么让该符号的引用也知道应该引用这个绝对的虚拟内存地址?</p>
<p>本步骤就是让所有符号引用都有着落</p>
<blockquote>
<p>举个例子,<code>main.c</code>是这样写的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//声明一个函数符号引用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> 	func();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让编译停止在链接前,此时<code>func</code>函数对于<code>main</code>模块来说还只是一个符号引用,</p>
<p>对<code>main.o</code>反汇编之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; gcc main.c -O0 -c -o main.o</span><br><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; objdump main.o -d </span><br><span class="line"></span><br><span class="line">main.o:     file format pe-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">0:   55                      push   %rbp</span><br><span class="line">1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">4:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br><span class="line">12:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">17:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">1b:   5d                      pop    %rbp</span><br><span class="line">1c:   c3                      retq</span><br><span class="line">1d:   90                      nop</span><br><span class="line">1e:   90                      nop</span><br><span class="line">1f:   90                      nop</span><br></pre></td></tr></table></figure>
<p>发现反汇编的代码中并没有出现func函数的影子,并且有两条很诡异的call指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br></pre></td></tr></table></figure>
<p>明明就在本函数之中,却还要<code>call</code>一下</p>
<p>这样写的原因是,目前本模块并不知道<code>func</code>的地址,因此指令中根本没法写<code>call</code>谁<code>e8 00 00 00 00</code>这里后面8个0就是未知地址,<code>e8</code>是只是<code>call</code>指令的操作码</p>
<p>这里写了两个不明所以的<code>call</code>指令,原因是,上面这个<code>8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</code>在链接后调用的是<code>__main</code>函数,作用是进行一些初始化</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401650 &lt;__main&gt;:</span><br><span class="line">  401650:	8b 05 da 59 00 00    	mov    0x59da(%rip),%eax        # 407030 &lt;initialized&gt;</span><br><span class="line">  401656:	85 c0                	test   %eax,%eax</span><br><span class="line">  401658:	74 06                	je     401660 &lt;__main+0x10&gt;</span><br><span class="line">  40165a:	c3                   	retq   </span><br><span class="line">  40165b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  401660:	c7 05 c6 59 00 00 01 	movl   $0x1,0x59c6(%rip)        # 407030 &lt;initialized&gt;</span><br><span class="line">  401667:	00 00 00 </span><br><span class="line">  40166a:	e9 71 ff ff ff       	jmpq   4015e0 &lt;__do_global_ctors&gt;</span><br><span class="line">  40166f:	90                   	nop</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面这个才是<code>call func</code>,调用<code>func</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401560</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">401560</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">401561</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">401564</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          	sub    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">401568</span>:	e8 e3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401650</span> &lt;__main&gt;</span><br><span class="line">  <span class="number">40156</span>d:	e8 <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401580</span> &lt;func&gt;</span><br><span class="line">  <span class="number">401572</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401577</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          	add    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">40157b</span>:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">40157</span>c:	c3                   	retq   </span><br><span class="line">  <span class="number">40157</span>d:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157f</span>:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
</blockquote>
<p>链接器依赖可<strong>重定位模块</strong>(<code>.o</code>)中的<strong>重定位条目</strong>实现该步骤</p>
<h5 id="重定位条目">重定位条目</h5>
<p>汇编器在遇到一个本模块中没有定义的符号引用时,就会为该符号引用创建一个重定位条目</p>
<p>代码的重定位条目存放在<code>.rel.text</code>节中</p>
<p><strong>已初始化</strong>数据的重定位条目存放在<code>.rel.data</code>节中</p>
<p>重定位条目结构定义:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095006902.png"
alt="image-20220525095006902" />
<figcaption aria-hidden="true">image-20220525095006902</figcaption>
</figure>
<blockquote>
<p>offset:引用的节偏移量</p>
<p>type:重定位类型(着重关心其中的两种)</p>
<p>symbol:符号表的下标</p>
<p>addend:修正参数</p>
</blockquote>
<p><code>R_X86_64_PC32</code>重定位一个使用32位PC相对地址的引用</p>
<blockquote>
<p>PC相对地址:某地址与当前PC值的距离</p>
</blockquote>
<p>32位<strong>相对地址</strong>加上当前PC值得到有效地址</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000001139 &lt;func&gt;:</span><br><span class="line">    1139:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    113d:	48 8d 3d c0 0e 00 00 	lea    0xec0(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1144:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1149:	e8 e2 fe ff ff       	call   1030 &lt;printf@plt&gt;</span><br><span class="line">    114e:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1152:	c3                   	ret    </span><br><span class="line">    </span><br><span class="line">0000000000001153 &lt;main&gt;:</span><br><span class="line">    1153:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1157:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    115c:	e8 d8 ff ff ff       	call   1139 &lt;func&gt;</span><br><span class="line">    1161:	b8 00 00 00 00       	mov    $0x0,%eax</span><br></pre></td></tr></table></figure>
<p>比如当执行115c处的<code>115c: e8 d8 ff ff ff          call   1139 &lt;func&gt;</code>时</p>
<p>此时程序计数器指向下一条指令<code>PC=0x1161</code></p>
<p>操作码<code>e8</code>表示call</p>
<p>相对地址<code>d8 ff ff ff</code>按照小端模式存放,写成16进制数应该为<code>0xff ff ff d8=-40=-0x28</code></p>
<p>PC加上相对地址即<code>0x1161-0x28=0x1139</code>恰好为<code>0000000000001139 &lt;func&gt;:</code>的首条指令的地址</p>
</blockquote>
<p><code>R_x86_64_32</code>重定位一个使用32位<strong>绝对地址</strong>的引用</p>
<p>绝对寻址,直接在指令编码中给出有效地址</p>
<h5 id="重定位算法">重定位算法</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527115221609.png"
alt="image-20220527115221609" />
<figcaption aria-hidden="true">image-20220527115221609</figcaption>
</figure>
<p>重定位算法也是比较容易理解的,</p>
<p>说了一个啥事呢?</p>
<p>现在各个模块的text合并成一个text节,所有符号都有一个重定位条目,记录了自己在本节中的偏移量(相对于节基地址的位置)</p>
<p>然后本节中的一个符号想要找另一个符号的位置</p>
<p>这就相当鱼一个数组arr中,要计算<code>arr[20]</code>和<code>arr[200]</code>的举例,直接用200-20=180,这里下标就是数组元素相对于数组基地址的偏移量</p>
<p>数组就相当于这一整个text节,元素相当于text节中的一个符号,下标相当于该符号相对于text</p>
<p>所有引用符号重定位之后,此时所有引用,所有符号
都有址可循,链接完全完成,形成可执行目标文件.out</p>
<h2 id="可执行目标文件.out">可执行目标文件<code>.out</code></h2>
<p>可执行目标文件通常以<code>.out</code>作为拓展名,或者根本就不写拓展名,反正linux上对拓展名没有windows上那么严格</p>
<h3 id="文件视图">文件视图</h3>
<p>完全链接之后,所有的目标模块都融洽地形成一个可执行目标文件,原来每个目标模块中都有<code>text,data</code>等节,在可执行目标文件中,每种节有且只有一个</p>
<p>可执行目标文件的格式:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095816498.png"
alt="image-20220525095816498" />
<figcaption aria-hidden="true">image-20220525095816498</figcaption>
</figure>
<p>ELF头从0开始,这并不意味着ELF在真正执行的时候,起运行地址空间从0开始.</p>
<p><code>.init</code>节是一个小型的代码段,里面就一个小函数<code>_init</code>作用是进行一些初始化,具体初始化了啥我不知道,也不是学这一部分所应关心的重点</p>
<p>用010editor elf模板观察一个可执行目标文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525143339664.png"
alt="image-20220525143339664" />
<figcaption aria-hidden="true">image-20220525143339664</figcaption>
</figure>
<p><code>elf_header</code>的作用和<code>.o</code>可重定位目标模块中的类似,作用是声明ELF魔数,规定后续各部分的偏移量和大小</p>
<h3 id="program_header程序头"><code>program_header</code>程序头</h3>
<p>作用是规定</p>
<p>1.各节在本可执行目标文件中的偏移,</p>
<p>2.虚拟内存地址,</p>
<p>3.对齐要求,</p>
<p>4.本目标文件中的段大小,</p>
<p>5.实际执行时内存中的段大小,</p>
<p>6.运行时的读写执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ objdump -h prog</span><br><span class="line"></span><br><span class="line">prog:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynsym       00000090  00000000000003c8  00000000000003c8  000003c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .dynstr       0000007d  0000000000000458  0000000000000458  00000458  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version  0000000c  00000000000004d6  00000000000004d6  000004d6  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .gnu.version_r 00000020  00000000000004e8  00000000000004e8  000004e8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.dyn     000000c0  0000000000000508  0000000000000508  00000508  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         00000017  0000000000001000  0000000000001000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000010  0000000000001020  0000000000001020  00001020  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000008  0000000000001030  0000000000001030  00001030  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         00000171  0000000000001040  0000000000001040  00001040  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000009  00000000000011b4  00000000000011b4  000011b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       00000004  0000000000002000  0000000000002000  00002000  2**2</span><br><span class="line">0000000000003e20  00002e20  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 20 .dynamic      000001b0  0000000000003e28  0000000000003e28  00002e28  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .got          00000028  0000000000003fd8  0000000000003fd8  00002fd8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .got.plt      00000018  0000000000004000  0000000000004000  00003000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .data         00000010  0000000000004018  0000000000004018  00003018  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 24 .bss          00000008  0000000000004028  0000000000004028  00003028  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 25 .comment      0000001f  0000000000000000  0000000000000000  00003028  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<h3 id="运行视图">运行视图</h3>
<p>在<code>shell</code>上,<code>./prog</code>命令即可加载并执行可执行目标文件<code>prog</code></p>
<p>实际上是<code>shell</code>调用<code>execve</code>函数来调用加载器,加载器是操作系统的组成部分.</p>
<p>加载器把<code>prog</code>的所有代码和数据从磁盘拷贝到内存,然后跳转到程序的第一条指令,然后控制转移到该程序,程序执行.这个过程叫做加载</p>
<p>至于加载器究竟干了啥,我不知道,现在也不想知道</p>
<p>加载完成后,程序在内存中的映像图是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525145002132.png"
alt="image-20220525145002132" />
<figcaption aria-hidden="true">image-20220525145002132</figcaption>
</figure>
<blockquote>
<p>其中忽略了一些无关紧要的信息,比如</p>
<p>1.各段都有自己的对齐要求,但是图上都画的紧挨着.实际上有可能"相邻"两段之间有一些没有意义的空隙,当程序错误执行到这些空当时就会触发段错误</p>
<p>2.没有表现出地址空间布局随机化.ASLR的作用是对抗pwn攻击的,在做一些简单的pwn题目时,一个变量,一个函数的地址都是确定的,使用ida打开看到了,那么就可以确定下一次运行时那个函数,那个变量还是在那个位置.而开启ASLR之后每次运行,同一个变量会有不同的地址.</p>
<blockquote>
<p>但是仍然可以确定的是,两个变量,变量和函数,函数之间的相对位置都是不变的,就相当于把整个村从城南搬到城北,李四还是知道张三住哪里,走多远到张三家</p>
</blockquote>
</blockquote>
<p>运行时视图没有"<code>section</code>"这种说法了,类似的概念叫"<code>segment</code>"</p>
<p>比如只读代码段(由原来的<code>.init,.text,.rodata</code>节组成)</p>
<p>性质类似的节(比如只读数据和代码都不可执行,合并到一个段</p>
<p>段也有类似于节的属性,比如读写执行权限</p>
<p>如果企图在只读代码段修改或写入东西</p>
<p>或者在开启了NX保护(堆栈不可执行)之后在堆栈上写<code>shellcode</code>并<code>ret2shellcode</code></p>
<p>都会引起段错误</p>
<h2 id="库文件.a-.so">库文件<code>.a &amp; .so</code></h2>
<p>CSAPP中将静态库放在静态链接讲完之后,动态链接开始讲之前.</p>
<p>但实际上讲动态链接时并没有涉及到静态库.</p>
<p>现在改变一下思路把静态库和动态库这两种库文件放在一起阐述</p>
<h3 id="源头之争">源头之"争"</h3>
<blockquote>
<p><strong>去年的历史遗留问题</strong></p>
<p><strong>1.</strong>在大一学习c语言时我们就知道,如果要使用<code>printf</code>和<code>scanf</code>函数,必须<code>#include &lt;stdio.h&gt;</code>,</p>
<p>如果使用<code>srand(time(0))</code>,其中的<code>time(0)</code>要求<code>#include &lt;time.h&gt;</code></p>
<p>然而实际上去观察一下<code>&lt;stdio.h&gt;</code>这种.h头文件,其中并没有函数的实现,只有函数的接口.那<code>#include &lt;xxx.h&gt;</code>的目的是啥呢?</p>
<p><strong>2.</strong>在大二上学习C++时,函数,类的定义和声明分别写在源还是头文件中,给我们带来了巨大麻烦</p>
<p>头文件既然妹有写实现,源文件中声明和实现相当于都有,那么头文件还有存在的意义吗?难道是只写接口看起来干净整洁好看吗?</p>
<p>非也</p>
</blockquote>
<p><strong>头文件提供一个引用</strong></p>
<p>啥意思呢?下面以一个例子说明,在这个例子中虽然不涉及头文件,但是实际上包括了头文件要做的事</p>
<blockquote>
<p>注意一些文字游戏</p>
<p>"定义"和"实现"是一个说法,都是带函数体的函数,比如<code>int func()&#123;/*花括号里是函数体*/&#125;</code></p>
<p>"声明"和"接口"是一个说法,都是不带函数体,只有一个函数声明,比如<code>int func();//分号结尾,妹有函数体</code></p>
</blockquote>
<p>考虑这么一个程序<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main.c</code>中,<code>func</code>函数既没有定义也没有实现,直接在<code>main</code>函数中调用</p>
<p>现在我们把编译和链接分别执行</p>
<h4 id="编译阶段">编译阶段</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main</span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:3:11: warning: implicit declaration of <span class="keyword">function</span> ‘func’ [-Wimplicit-function-declaration]</span><br><span class="line">    3 |     int a=func();</span><br><span class="line">      |           ^~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里报了一个警告,意思是<code>func</code>没有直接言明</p>
<blockquote>
<p>编译器很懵逼,func是个啥啊,你妹有定义实现也就罢了,竟然连声明都不打招呼,</p>
<p>上来就用,玩意func有参数,万一func根本就不是函数,是个变量咋整?func有没有返回值啊&gt;_&lt;,返回啥类型值啊?</p>
<p>我编译器只能联系上下文,按照func是一个返回int的无参函数来编译了</p>
<p>链接器你就自求多福吧,我摆烂了</p>
</blockquote>
<blockquote>
<p>那么怎么才能让编译器知道关于func的信息呢?在使用之前声明一下这个函数接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<strong>编译</strong>就妹有警告了,这意味着编译器此时已经非常自信地认为自己的工作很perfect</p>
</blockquote>
<h4 id="链接阶段">链接阶段</h4>
<p>链接的作用是给每个引用都找到实现,让所有悬而未决的议案落地</p>
<p>在同文件夹下有一个<code>func.c</code>,其中有<code>func()</code>函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时<code>main.c</code>这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code>和<code>func.c</code>都已经正确经过编译,生成了可重定位目标文件<code>main.o</code>和<code>func.o</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func.c -c -o func.o</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main.o</span><br></pre></td></tr></table></figure>
<p>根据前面章节的学习,<code>main.o</code>中有一个func函数的引用悬而未决,如果要形成<code>main.out</code>,需要让这个引用落地</p>
<p>如果直接写<code>gcc main.o -o main</code>不用想都知道会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o -o main</span><br><span class="line">/usr/bin/ld: main.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.c:(.text+0xe): undefined reference to `func&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>链接器报错:func引用未定义</p>
<blockquote>
<p>考虑如下场景</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525165401741.png"
alt="image-20220525165401741" />
<figcaption aria-hidden="true">image-20220525165401741</figcaption>
</figure>
<p>这里printf未定义的报错是不是和刚才func妹有定义的报错是同一种错误?</p>
</blockquote>
<p>给gcc怎样传递命令行参数,才能不让链接器报错呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o func.o -o main</span><br></pre></td></tr></table></figure>
<p>这句话的意思是,将<code>main.o</code>和<code>func.o</code>进行链接,(如果妹有链接错误的话)形成可执行目标文件<code>main</code></p>
<h4 id="整个过程">整个过程</h4>
<p>现在考虑编译到链接整个过程,怎样才能不报错不报警告?</p>
<p>1.编译时引用要提前声明一下</p>
<p>2.链接时要包含所有引用实现的模块</p>
<h4 id="回到源头之争">回到源头之"争"</h4>
<p><code>#include &lt;stdio.h&gt;</code>是一条宏定义,在预编译阶段会被展开,也就是将<code>stdio.h</code>中的所有东西都加在<code>main.c</code>的一开始,形成<code>main.i</code></p>
<p><code>main.i</code>实际上还是<code>ASCII</code>文本文档,和<code>main.c</code>几乎妹有区别</p>
<p>还记得<code>&lt;stdio.h&gt;</code>中都是写的啥吗?函数声明</p>
<p>那么<code>main.i</code>是个啥?</p>
<p>一伙子函数引用+我们自己写的<code>main</code>函数,</p>
<p>which调用了<code>printf</code>,</p>
<p>which在前面一伙子函数引用中有一席之地.</p>
<p>可见<code>&lt;stdio.h&gt;</code>帮我们完成了声明函数引用的工作.</p>
<blockquote>
<p>为什么要用一个头文件来做这个工作?我们程序员是傻吗?自己声明一个printf的引用不行吗?</p>
<p>其一,printf是个变参函数,这一下子就限制了很多人写函数引用,变参函数的函数接口长啥样啊?我也不知道</p>
<p>其二,printf的返回值是啥,<code>int?long?unsigned?size_t?</code>调用约定是啥?<code>__cdecl?__fastcall?</code>即使我记性好,这些都记住了,那么<code>scanf,sprintf,fgetc,fwrite....</code>等等函数的接口又长啥样?难道每次调用一个库函数都要去查手册吗?手册得多厚啊,新华字典见了都怕</p>
</blockquote>
<p>在预编译阶段过后,宏定义被展开,此时头文件就完成了自己的使命</p>
<p>奇怪的是,即使我们用到了<code>glibc</code>库中的函数<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接时,也没有指定<code>printf</code>在哪里实现啊?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./main</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>按照我们在"链接阶段"举的例子,这里就应该链接报错<code>"undefined reference : 'printf' "</code></p>
<p>而实际上程序链接地好好的</p>
<p>这是因为,<code>printf</code>
的实现在<code>glibc.so</code>动态库中,而该动态库会被链接器自动且隐式地链接</p>
<p><code>printf</code>实现所在的源文件去哪了?</p>
<p>源文件被编译成<code>glibc.so</code>动态库了,从一个ASCII文档变成二进制文件了,源文件的灵魂已经装进<code>glibc.so</code></p>
<p>如果想要看<code>printf</code>源文件怎么实现的,去哪里找呢?</p>
<p>谷歌或者百度<code>glibc-2.9</code>或者其他版本,去官网下载吧</p>
<h4 id="明确分工">明确分工</h4>
<p>在大二上学面向对象C++的时候,曾经费尽心思记什么东西应该写到头文件里,什么东西应该写到源文件里(到考试,到现在也没记住)</p>
<p>其实学了链接时符号解析规则,这些问题根本就不是问题</p>
<p>刚才已经举例说明了,头文件的作用就是声明一下函数接口,起引用作用</p>
<h5 id="头文件可以写函数实现吗">头文件可以写函数实现吗</h5>
<p>现在基于对链接的了解,考虑<strong>头文件里可以写函数实现吗</strong>?</p>
<blockquote>
<p>貌似可以,并且可以说出歪歪理儿,举一个有模有样的例子:</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>gcc main.c -o main</code>不会报错,并且连链接时指定可重定位目标文件或者库文件都省去了,岂不美哉?</p>
<p>当然不会报错,这样写<code>func.h</code>改名为<code>func.balabala</code>都可以,<code>.h</code>后缀妹有意义</p>
<p>实际上相当于写了</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里不报错的原因是,整个编译链接就涉及到两个模块,并且只有<code>main</code>引用了<code>func</code>,这关系简单明了</p>
<p>可如果这样写呢?</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序入口这样写:</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();		<span class="comment">//要调用func1必然要链接func1.o目标模块</span></span><br><span class="line">    <span class="type">int</span> b=func2();		<span class="comment">//要调用func2必然要链接func2.o目标模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525202607308.png"
alt="image-20220525202607308" />
<figcaption aria-hidden="true">image-20220525202607308</figcaption>
</figure>
<blockquote>
<p>main中相当于有两个func的定义</p>
</blockquote>
<p>使用<code>gcc main.c func1.c func2.c -o prog</code>企图编译链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c func1.c func2.c -o prog</span><br><span class="line">/usr/bin/ld: /tmp/ccb95Wtp.o: <span class="keyword">in</span> <span class="keyword">function</span> `func<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">func2.c:(.text+0x0): multiple definition of `func&#x27;</span>; /tmp/ccAEawPN.o:func1.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>发现编译是可以通过的,报错全是链接错,<code>func</code>有多重定义</p>
<p>为啥会报错呢?</p>
<p>第一次预见<code>func</code>的定义是在<code>func1.c</code>中,竟然在<code>func2.c</code>中又预见了<code>func</code>的定义</p>
<p>实际上相当于写了这么一个程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第一处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第二处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();	</span><br><span class="line">    <span class="type">int</span> b=func2();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>被定义了两次,函数名字和参数表一模一样,不是重载也不是重写,必然会报错</p>
<p>用前面章节的知识解释,函数定义是硬符号,符号解析时硬符号最多有一个,如果链接器发现有两个以上的同名硬符号则报错</p>
<blockquote>
<p>有人在往linux内核里添加系统调用的时候就在<code>syscalls.h</code>里面写了内核函数的实现,我不说是谁</p>
</blockquote>
<p>那么为了防止上述多重定义的情况发生,应该怎么办呢?</p>
<p>不允许多重定义,还能不允许多重引用吗?</p>
<p>头文件里只写函数声明或者说函数接口,源文件里写函数实现呗</p>
<h6 id="正确写法">正确写法</h6>
<h6 id="main.c"><code>main.c</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>		<span class="comment">//main中只引用了func1和func2,妹有引用func,因此不用#include &lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();</span><br><span class="line">    <span class="type">int</span> b=func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func.h-func.c"><code>func.h &amp; func.c</code></h6>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC		<span class="comment">//如果妹有定义FUNC符号才拓展该宏,条件展开发生在预编译时期</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span>	<span class="comment">//引用func.h的作用是,在预编译阶段把int func()搞进来,</span></span></span><br><span class="line">					<span class="comment">//实际上由于只有一个函数,并且接口简单,不使用头文件都可以.规范期间还是使用头文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func1.h-func1.c"><code>func1.h &amp; func1.c</code></h6>
<p><code>func1.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC1</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;		<span class="comment">//虽然func1中会引用func,但头文件中不写include &lt;func.h&gt;,因为头文件就只是提供该模块中函数的引用,</span></span><br><span class="line">						<span class="comment">//具体函数实现中引用了什么其他家的花草,头文件并不关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>					<span class="comment">//这里两个头的include先后顺序无所谓,反正都是引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func2.h-func2.c"><code>func2.h &amp; func2.c</code></h6>
<p><code>func2.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC2</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="通过链接">通过链接</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func1.c func.c main.c func2.c -o prog				<span class="comment">#这里源文件的先后顺序妹有区别,但是一定要写全需要的源文件</span></span><br><span class="line">															<span class="comment">#编译链接成功</span></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./prog													<span class="comment">#运行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="头文件可以写全局变量吗">头文件可以写全局变量吗</h5>
<p>还是以<code>geometry</code>的例子(见下文静态库-&gt;使用静态库),假如在<code>geometry.h</code>中,我们定义了一个全局变量<code>PI</code></p>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们的目的是,只要引用了该头文件就可以直接使用PI,比如</p>
<p>在<code>main.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">int</span> pi=PI;	<span class="comment">//试图阔的PI的拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果却报告链接错误了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/cc9eI8oy.o:(.rodata+0x0): multiple definition of `PI<span class="string">&#x27;; /tmp/cci0ubCp.o:(.rodata+0x0): first defined here</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">/usr/bin/ld: cannot find ./libgeometry.so: No such file or directory</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">./makedynamiclib.sh: line 5: ./prog: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>意思是<code>PI</code>有多重定义了</p>
<p>为啥会报链接错:有多重定义?</p>
<p><code>line.c</code>和<code>point.c</code>,<code>main.c</code>中都有<code>#include "geometry.h"</code></p>
<p>前面我们也分析了头文件的作用,头文件中的东西在预编译宏展开之后会直接加到源文件前面.</p>
<p>那么预编译之后,<code>line.i,point.i,main.i</code>中各有一次<code>const double PI=3.1415926</code>的定义,这是硬符号,然后三个文件都被编译成可重定位目标文件.o准备链接</p>
<p>链接时同名的全局符号只允许有至多一个硬符号,而对于<code>PI</code>符号,链接器可以发现两个(找到第二个就报错了,不管第三个了)因此报链接错,多重定义</p>
<blockquote>
<p>可是我们头文件中宏定义是条件展开的啊,已经定义过就不会被定义了啊?</p>
<p>考虑宏定义的展开是在预编译阶段,远没到链接,等到链接的时候,早就都展开了
.条件展开的作用是防止同一个头文件被多次include</p>
<blockquote>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这两个头文件是包含关系,完全可以只<code>#include &lt;cstdio&gt;</code>,但是这时<code>#include &lt;stdio.h&gt;</code>之后再<code>#include &lt;cstdio&gt;</code>时,会引入<code>&lt;cstdio&gt;</code>中除了包含的的<code>&lt;stdio.h&gt;</code>之外的其他内容.当然,如果再引入一遍<code>&lt;stdio.h&gt;</code>也不会报错,因为都是引用</p>
<p>但是有时候去重的作用就很重要,比如<code>"a.h"</code>中会<code>#include "b.h"</code>同理<code>"b.h"</code>会<code>#include "a.h"</code>,即两个头文件会互相引入,如果此时不使用条件展开去重,则预编译器会不停引入两个文件,直到崩溃</p>
</blockquote>
</blockquote>
<h6 id="正确写法-1">正确写法</h6>
<h6 id="方法一宏定义pi">方法一:宏定义PI</h6>
<p>在<code>geometry.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是glibc库的头文件中使用的方法</p>
<p>比如<code>stdio.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NFILE _NSTREAM_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSTREAM_ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOB_ENTRIES 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure>
<p>我们自己写一个<code>main.c</code>,<code>#include &lt;stdio.h&gt;</code>之后就可以直接使用这些宏定义</p>
</blockquote>
<blockquote>
<p>为什么可以使用宏定义呢?</p>
<p>各组成模块宏定义展开之后可能会有多条同样的宏定义,宏定义允许多次定义,在调用时使用最后一次的宏定义</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1416</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.14159</span><br></pre></td></tr></table></figure>
<p>但是会报告编译警告</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">testGlobal.c:3: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:2: note: this is the location of the previous definition</span><br><span class="line">    2 | <span class="comment">#define PI 3.14</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:3: note: this is the location of the previous definition</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:5: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    5 | <span class="comment">#define PI 3.14159</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: note: this is the location of the previous definition</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
<p>而如果多次宏定义一模一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>
<p>则不会报告编译警告</p>
</blockquote>
<h6 id="方法二使用extern引用">方法二:使用extern引用</h6>
<p>比如在<code>point.c</code>中全局位置写入<code>const double PI=3.1415926;</code></p>
<p><code>main</code>函数中要使用<code>PI</code>值,那么在<code>main.c</code>中找一个使用<code>PI</code>之前的位置(不管是局部还是全局位置),<code>extern double PI;</code></p>
<p>作用是,声明一下<code>PI</code>是一个外部符号(本模块中妹有定义),编译时产生一个引用,至于引用的解析,让链接器去找</p>
<blockquote>
<p>实际上用<code>extern</code>声明一个变量和声明一个函数引用的作用是类似的,都是声明引用.</p>
<p>但是为啥函数引用不用<code>extern</code>声明,但是变量就一定得用<code>extern</code>声明呢?</p>
<p>函数只要不写函数体,在参数表小括号后面一个分号,立刻就可以断定这是一个函数引用.</p>
<p>而全局变量即使不赋值直接写分号,<code>int a;</code>编译器就认为这是一个应该放在.bss节的本模块中的数据.为了突出是个引用,因此使用<code>extern</code>关键字</p>
</blockquote>
<blockquote>
<p>extern的作用</p>
<p>如果一个程序这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> PI;			<span class="comment">//试图声明一个引用,并在main函数之后赋值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>会报错<code>[注解] 'double PI' previously 被声明于此处</code>.同一个模块中存在多重定义了</p>
<p>正确的写法应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> PI;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果:<code>3.14</code></p>
<p>对于函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//这两种写法都可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;		<span class="comment">//实现</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;fcntl.h&gt;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">open</span> <span class="params">(__const <span class="type">char</span> *__file, <span class="type">int</span> __oflag, ...)</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6
id="extern-double-pi能否写入头文件"><code>extern double PI;</code>能否写入头文件</h6>
<p>既然可以将<code>extern double PI;</code>写入<code>main.c</code>,那么写入<code>geometry.h</code>不一样吗?被<code>main.c</code>引入之后不就相当于在<code>main.c</code>中写了这句吗</p>
<p>这样写可以通过编译链接,感觉上妹有问题,但是用CLion搜索了整个glibc库,所有头文件中都没有这么写,只在<code>configure.in</code>中有这么一句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> glibc_conftest_frobozz;</span><br></pre></td></tr></table></figure>
<h5 id="静态变量">静态变量</h5>
<p>静态变量的作用是,将"全局位置"的变量的访问权限限定在本模块中.</p>
<p>啥意思呢?</p>
<p><code>point.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="comment">//全局位置</span></span><br><span class="line"><span class="comment">//const double PI=3.1415926;					//真·全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;				<span class="comment">//假·全局变量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>被<code>static</code>修饰的变量即使放在本模块的"全局位置",也是相对于本模块中的函数而言的"全局位置"</p>
<p>此时如果在<code>main.c</code>中想要使用<code>PI</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">double</span> PI;			<span class="comment">//声明PI引用,让链接器去解析</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="type">int</span> pi=PI;				<span class="comment">//试图使用引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而此时会报链接错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: warning: relocation against `PI<span class="number">&#x27;</span> in read-only section `.text<span class="number">&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.c:(.text+<span class="number">0xd7</span>): undefined reference to `PI<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static修饰的变量就类似于java和C++中<code>private</code>修饰的变量</p>
<p>只不过static限制模块之间的访问权限</p>
<p><code>private</code>限制类之间的访问权限</p>
<p>这是两种编程范式,模块化编程和面向对象编程</p>
</blockquote>
<h3 id="静态库.a">静态库.a</h3>
<p>静态库<code>static library</code>实际上是一伙子可重定位目标模块<code>.o</code>的集合</p>
<h4 id="起源">起源</h4>
<p>现在假设我们一个工程有成百上千个目标模块<code>.o</code>,</p>
<p>在其中一个目标模块引用了其他若干个目标模块中的符号.</p>
<p>如果引用的其他目标模块不多,尚且看不出问题,只需要<code>gcc main.o module1.o module2. ... -o prog</code>即可完成链接</p>
<p>如果引用的其他目标模块成百上千,那么可以想象到<code>gcc main.o module1.o module2. ... -o prog</code>这条编译命令能有多长</p>
<p>"可以编写<code>makefile</code>完成链接"</p>
<p>即使用<code>makefile</code>,还是存在难以解决的问题</p>
<p><strong>引用的符号在哪个模块里,是在<code>module1.o</code>还是在<code>module2.o</code>?程序员记得住吗?每次编译都要查表吗?</strong></p>
<p><strong>静态库也是可重定位目标文件<code>.o</code>吗?</strong></p>
<p>最容易想到的是,将一些工具性质的,经常被调用的一些目标模块,编译成一个大目标模块<code>.o</code>,注意还是可重定位目标模块<code>.o</code></p>
<p>当程序员自己写一个源文件<code>test.c</code>并编译成目标模块<code>test.o</code>,其中要用到一些库函数时,只需要将刚才生成的大<code>.o</code>文件链接进来</p>
<p>诚如是,则链接时该包含成千上万函数的大<code>.o</code>文件将会在运行时全部加载进入进程的地址空间,即使<code>test.o</code>只引用到了一个或者几个函数.</p>
<blockquote>
<p>这就好比要去图书馆接一本书,却把图书馆整个儿搬回家了</p>
</blockquote>
<p>能不能真正像借书一样,用到哪本书拿哪本,用到一个函数就只加载该函数所在的模块?</p>
<p><strong>于是归档文件(archieve)<code>.a</code>产生了,即静态库</strong></p>
<blockquote>
<p><code>.o</code>可重定位目标模块可能是静态库.a的组成,也可能是源代码<code>test.c</code>编译后链接前的中间文件.也就是说,.o中有可能有程序的入口点<code>main</code>函数.</p>
<p><code>.a</code>作为一个库文件,只能起到支持的作用,它就相当于一个服务器被动地给客户端服务.也就是说,只有用户的程序中有入口点,.a是不会主动执行的.直接试图将静态库编译链接为可执行目标文件是不可能的,因为库中没有<code>main</code>函数</p>
</blockquote>
<h4
id="使用静态库ar-rcs-静态库名.a-组成目标1.o-组成目标2.o-....">使用静态库<code>ar rcs &lt;静态库名&gt;.a &lt;组成目标1&gt;.o &lt;组成目标2&gt;.o ....</code></h4>
<p>举一个比较有实际意义的例子,模拟平面几何中的点和线</p>
<p>工作目录下有五个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxrwx 1 kali kali 731 May 25 21:57 geometry.h</span><br><span class="line">-rwxrwxrwx 1 kali kali 667 May 25 22:02 line.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 285 May 25 21:26 main.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 520 May 25 21:57 point.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 140 May 25 22:03 shellscript.sh</span><br></pre></td></tr></table></figure>
<h5 id="geometry.h"><code>geometry.h</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//点结构体</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//线结构体</span></span><br><span class="line">        Point a;</span><br><span class="line">        Point b;</span><br><span class="line">    &#125;Line;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line)</span>;         <span class="comment">//计算线段长</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line)</span>;          <span class="comment">//计算斜率</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line,Line)</span>;      <span class="comment">//判断平行</span></span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point,Point)</span>;      <span class="comment">//构造新线段</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line)</span>;			<span class="comment">//打印线两端点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里面的函数声明被分在两个源文件实现,<code>point.c</code>实现有关点计算的函数,<code>line.c</code>实现有关线计算的函数</p>
<h5 id="point.c"><code>point.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     double x;</span></span><br><span class="line">    <span class="comment">//     double y;</span></span><br><span class="line">    <span class="comment">// &#125;Point;</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="line.c"><code>line.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     Point a;</span></span><br><span class="line">    <span class="comment">//     Point b;</span></span><br><span class="line">    <span class="comment">// &#125;Line;</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEuclideanDistance(L.a,L.b);			<span class="comment">//此处要用到计算欧几里得距离的函数,其实现在point.c中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>*(L.a.y-L.b.y)/(L.a.x-L.b.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line L1,Line L2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(getSlope(L1)-getSlope(L2))&lt;<span class="number">0.001</span>;	<span class="comment">//控制精度为0.001</span></span><br><span class="line">    &#125;</span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">        Line L;</span><br><span class="line">        L.a=a;</span><br><span class="line">        L.b=b;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[(%.2f,%2f)(%.2f,%.2f)]&quot;</span>,L.a.x,L.a.y,L.b.x,L.b.y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="main.c-1"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Point a=newPoint(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    Point b=newPoint(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">double</span> euclidean_distance=getEuclideanDistance(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;euclidean_distance=%.2f\n&quot;</span>,euclidean_distance);</span><br><span class="line">    showPoint(a);</span><br><span class="line">    showPoint(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>main</code>函数中只用到了和点有关的函数,与线有关的函数一个也妹有用到</p>
<p>下面编写<code>bash</code>脚本进行编译,制作静态库,链接,运行</p>
<h5 id="shellscript.sh"><code>shellscript.sh</code></h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc point.c -c -o point.o</span><br><span class="line">gcc line.c -c -o line.o</span><br><span class="line">ar rcs libgeometry.a point.o line.o				#创建静态库</span><br><span class="line"></span><br><span class="line">gcc -static main.c -L. -lgeometry -lm -o prog </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<p>执行该<code>shell</code>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.a</span><br><span class="line">line.o</span><br><span class="line">point.o</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>这么几个文件</p>
<p>现在好奇的是,这个<code>libgeometry.a</code>到底有没有用啥拿啥的功能,也就是说,<code>line.o</code>有没有被链接进入可执行目标文件<code>prog</code>.用ida64打开<code>prog</code>,搜一下<code>function</code>看看<code>newLine</code>函数存不存在即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221037808.png"
alt="image-20220525221037808" />
<figcaption aria-hidden="true">image-20220525221037808</figcaption>
</figure>
<p>结果证明它不存在,也就是说<code>line.o</code>妹有链接进入<code>prog</code></p>
<p>还有就是<code>main</code>中妹有用到<code>point.c</code>中的<code>getManhattanDistance</code>函数,它有没有随着<code>point.o</code>一起被链接进入<code>prog</code>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221208601.png"
alt="image-20220525221208601" />
<figcaption aria-hidden="true">image-20220525221208601</figcaption>
</figure>
<p>事实上是有的,也就是说,从归档文件<code>.a</code>中用啥拿啥是以模块为单位的,而不是以函数为单位的,</p>
<p>归档文件中的一个模块,不管有多少个函数,只要有其中之一被引用,该模块中的所有函数都会随着该模块链接进入可执行目标文件</p>
<h4 id="a如何链接"><code>.a</code>如何链接</h4>
<p>前面章节中符号解析重定位等等都是<code>.o</code>的链接方法.现在对于一个静态库<code>.a</code>,应该如何链接呢?</p>
<p><strong>1.</strong>当输入<code>gcc f1 f2 ... fn</code>之后,编译器首先将各个源文件编译为可重定位目标文件<code>.o</code>,已经是<code>.o</code>或者<code>.a</code>文件则跳过不编译,得到一个全都是<code>.o</code>或者<code>.a</code>的参数序列</p>
<p><strong>2.</strong>链接器从左向右扫描这些<code>.o</code>或者<code>.a</code>文件,这两种文件有不同的待遇.</p>
<blockquote>
<p>链接器会维护三个集合:</p>
<p>可重定位目标文件集合E</p>
<p>未解析符号集合U(undefined)</p>
<p>已定义符号集合D(defined)</p>
</blockquote>
<p><strong>3.</strong>如果链接器当前扫描到的文件是一个.o,则</p>
<blockquote>
<p>本.o文件添加到E集合</p>
<p>本.o文件中的定义放到D集合</p>
<p>本.o文件中的引用放到U集合</p>
</blockquote>
<p><strong>4.</strong>如果链接器当前扫描到的文件是一个.a,则</p>
<blockquote>
<p>遍历本.a文件中所有组成模块,寻找U中引用的定义模块,</p>
<p>如果找到则将该模块放到E,将该引用从U中去掉,将定义放到D中</p>
<p><strong>遍历完后本.a文件不再发挥作用</strong></p>
</blockquote>
<p><strong>5.</strong>当链接器扫描完了参数,此时检查U集合是否为空</p>
<blockquote>
<p>如果U非空则有未解析的引用,报错<code>undefined reference</code></p>
<p>如果U为空则连接成功,合并并重定位E中的模块,形成可执行目标文件</p>
</blockquote>
<p>链接结束</p>
<blockquote>
<p>注意第4条最后的"<strong>遍历完后本.a文件不再发挥作用</strong>"</p>
<p>这就要求命令行上的参数有顺序了</p>
<p>如果都是.o妹有.a,则所有.o的所有定义和引用都会被放在D和U中,不怕有遗漏的定义</p>
<p>但是如果有.a,则链接器扫描.a时,只负责解析先前存在在U中的引用,后面的目标模块它现在看都不看</p>
<p>比如假如参数序列是这样的:<code>gcc a.o b.o lib.a c.o</code></p>
<p>其中a,b,c中都有<code>lib.a</code>中的引用,并且</p>
<p><code>a.o</code>引用了<code>lib.a</code>中的<code>a</code>模块,</p>
<p><code>b.o</code>引用了<code>lib.a</code>中的<code>b</code>模块,</p>
<p><code>c.o</code>引用了<code>lib.a</code>中的<code>c</code>模块,</p>
<p>当链接器扫描到<code>lib.a</code>时,链接器会依据<code>lib.a</code>,解析<code>a.o</code>和<code>b.o</code>中的引用,但是链接器此时并不知道后面还有啥参数,在用<code>lib.a</code>解析了<code>a.o</code>和<code>b.o</code>之后就丢弃了<code>lib.a</code>的其他部分,</p>
<p>然后扫描<code>c.o</code>又有了新的引用,而此时链接器已经扫描到头了,找不到一个能给出定义的模块了</p>
<p>链接出错</p>
<p>这样设计虽然会因为顺序问题导致链接出错,但是注意一下或者多写几遍.a就可以克服.并且能够做到尽量少引入目标模块,非用不引.并且时间最优</p>
</blockquote>
<h3 id="动态库.so">动态库.so</h3>
<p>动态库又叫做共享目标文件</p>
<h4 id="起源-1">起源</h4>
<blockquote>
<p>静态库的缺点:</p>
<p>试想现在要同时运行多个进程,每个进程都要调用库函数<code>printf</code>,按照静态库的链接方法,每个进程的虚拟地址空间都会有一个printf
的拷贝,并且会物理地址空间上建立相应物理页</p>
<p>而实际上<code>printf</code>就是一段只读的代码,给定参数就可以当作黑盒用.</p>
<p>就像办公室的打印机,不同的用户只需要给定自己想要打印的材料,用同一台打印机就可以获得不同的输出</p>
</blockquote>
<p>在兼容静态库拿啥用啥的思想上,让只读的代码和数据不需要有多份拷贝,<strong>一份足矣</strong>,这就是动态库的思想.</p>
<p>动态库在<strong>运行或加载</strong>时,可以加载到<strong>任意地址</strong></p>
<p>在linux上动态库后缀.so,在windows上动态库后缀.dll</p>
<h4 id="动态库的链接">动态库的链接</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526001100718.png"
alt="image-20220526001100718" />
<figcaption aria-hidden="true">image-20220526001100718</figcaption>
</figure>
<p>在链接阶段,动态库传递给链接器的只有重定位和符号表信息,并没有让只读代码段参与链接.</p>
<p>啥时候动态库中的只读代码才会参与链接呢?在执行过程中,首次用到了动态库中的引用时,不得不动态加载了,此时动态链接器才会将动态库映射到进程的地址空间,并进行重定位让悬空引用落地</p>
<blockquote>
<p>这个过程我没有亲眼见证,都是道听途说,暂且认为它是这样的</p>
</blockquote>
<p>为了让不同的进程都能将共享库的物理地址空间映射到自己的虚拟地址空间,有好多种办法</p>
<p>1.物理地址空间为共享库专门留出空间,一个萝卜一个坑,就算妹有萝卜,坑也得留着,其他代码数据都往后稍稍.用到该共享库的时候就一定加载到给他预留的物理地址空间.</p>
<blockquote>
<p>缺点是,程序不一定会用到该共享库,或者程序刚开始时只用到该共享库的一小部分代码,共享库只有一小部分加载进入物理地址空间.然后是其他代码,占用了为共享库预留的剩余空间,现在又要调用共享库中的其他代码,这时一开始预留的空间已经被占用,不够用了.又得重新找一个空旷的地方放动态库.这样重复多了,物理地址空间就变得呲离破碎,全是下脚料空间</p>
<p>这可能比静态库还要浪费物理内存,这不就废了吗</p>
</blockquote>
<p>2.位置无关代码</p>
<p>动态库可以任意加载进入物理地址空间,由动态链接器完成程序中动态库引用的解析</p>
<h4 id="使用动态库">使用动态库</h4>
<p>还是使用静态库时举的<code>geometry</code>的例子</p>
<p><code>makedynamiclib.sh</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so line.c point.c  #制作代码位置无关的共享库libgeometry.so</span><br><span class="line"></span><br><span class="line">gcc  main.c ./libgeometry.so -lm -o prog </span><br><span class="line"></span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/linkage]</span><br><span class="line">└─# ./makedynamiclib.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.so</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>两个目标文件</p>
<p>使用ida64打开prog观察,发现函数少的可怜</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526093938243.png"
alt="image-20220526093938243" />
<figcaption aria-hidden="true">image-20220526093938243</figcaption>
</figure>
<p>并且可以发现,在<code>point.c</code>中定义的<code>getManhattanDistance</code>并没有被解析.</p>
<p>即,使用动态库时引用解析是<strong>以函数为单位</strong>的,相对于以模块为单位进行解析的静态库更加灵活</p>
<p>以<code>getEuclideanDistance</code>为例,观察该函数引用是如何被解析的</p>
<p>在<code>main</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011EB                 call    _getEuclideanDistance</span><br></pre></td></tr></table></figure>
<p>跟踪<code>_getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001060 _getEuclideanDistance proc near         ; CODE XREF: main+82↓p</span><br><span class="line">.plt:0000000000001060                 jmp     cs:off_4030</span><br><span class="line">.plt:0000000000001060 _getEuclideanDistance endp</span><br></pre></td></tr></table></figure>
<p>跟踪<code>cs:off_4030</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0000000000004030 off_4030        dq offset getEuclideanDistance</span><br><span class="line">.got.plt:0000000000004030                                         ; DATA XREF: _getEuclideanDistance↑r</span><br><span class="line">.got.plt:0000000000004030 _got_plt        ends</span><br><span class="line">.got.plt:0000000000004030</span><br></pre></td></tr></table></figure>
<p>跟踪<code>offset getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern:0000000000004078                 extrn getEuclideanDistance:near</span><br><span class="line">extern:0000000000004078                                         ; CODE XREF: _getEuclideanDistance↑j</span><br><span class="line">extern:0000000000004078                                         ; DATA XREF: .got.plt:off_4030↑o</span><br></pre></td></tr></table></figure>
<p>此时已经跟踪到头了,点谁都不会跳转了.但是自始至终妹有看见该函数的实现,好像一直在踢皮球</p>
<p>这涉及到位置无关代码PIC的理论</p>
<h4 id="位置无关代码pic">位置无关代码PIC</h4>
<p>Position-Independent Code</p>
<p>共享库在编译时要求必须使用位置无关选项<code>-fpic</code></p>
<h5 id="pic数据引用">PIC数据引用</h5>
<p>全局偏移量表global offset table,GOT</p>
<p>GOT位于<strong>数据段的开始</strong></p>
<p>编译时使用<code>-static</code>选项得到的可执行目标文件中是妹有GOT表的</p>
<p>只有使用位置无关代码的动态链接才会生成GOT表,即使就写一个空壳子main函数啥也不干,什么头文件也不导入,动态链接之后的可执行目标文件也是会有GOT的</p>
<h6 id="got表结构">GOT表结构:</h6>
<p>GOT表项八字节一个,表项内容是引用指向的地址,即一个位置无关代码在运行时的实际地址</p>
<blockquote>
<p>为什么是八字节?</p>
<p>八个字节即64位,考虑进程的虚拟地址空间有64位吗?</p>
<p><img
src="https://pic2.zhimg.com/v2-76f7edab5d8e719cc150fc382c18a10e_1440w.jpg?source=172ae18b" /></p>
<p>图片来自<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/207001939">Linux内存管理：虚拟地址空间
- 知乎 (zhihu.com)</a></p>
<p>用户的虚拟地址空间只有48位,从<code>0x0</code>到<code>0xFFFF FFFF FFFF</code></p>
<p>内核的虚拟地址空间也是48位,从<code>0xFFFF 0000 0000 0000</code>到<code>0xFFFF FFFF FFFF FFFF</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Start                 End                     Size            Use</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">0000000000000000      0000ffffffffffff         256TB          user</span><br><span class="line">ffff000000000000      ffff7fffffffffff         128TB          kernel logical memory map</span><br><span class="line">ffff800000000000      ffff9fffffffffff          32TB          kasan shadow region</span><br><span class="line">ffffa00000000000      ffffa00007ffffff         128MB          bpf jit region</span><br><span class="line">ffffa00008000000      ffffa0000fffffff         128MB          modules</span><br><span class="line">ffffa00010000000      fffffdffbffeffff         ~93TB          vmalloc</span><br><span class="line">fffffdffbfff0000      fffffdfffe5f8fff        ~998MB          [guard region]</span><br><span class="line">fffffdfffe5f9000      fffffdfffe9fffff        4124KB          fixed mappings</span><br><span class="line">fffffdfffea00000      fffffdfffebfffff           2MB          [guard region]</span><br><span class="line">fffffdfffec00000      fffffdffffbfffff          16MB          PCI I/O space</span><br><span class="line">fffffdffffc00000      fffffdffffdfffff           2MB          [guard region]</span><br><span class="line">fffffdffffe00000      ffffffffffdfffff           2TB          vmemmap</span><br><span class="line">ffffffffffe00000      ffffffffffffffff           2MB          [guard region]</span><br></pre></td></tr></table></figure>
<p>如果GOT表项可以指向一个内核中的函数或者变量,则显然需要8字节的表项,</p>
<p>如果GOT表项只是指向用户模块中的变量或者函数,则只需要6字节(48位)的表项</p>
<p>因此问题转化为一个进程是否会访问内核</p>
<p>显然是可以的,比如系统调用</p>
</blockquote>
<h6 id="got表怎么干活的">GOT表怎么干活的?</h6>
<p>CSAPP上举了这么一个例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526192907692.png"
alt="image-20220526192907137" />
<figcaption aria-hidden="true">image-20220526192907137</figcaption>
</figure>
<p>一定时刻记住以下几点:</p>
<p>1.代码段是c源代码经过<strong>编译</strong>得到的,与链接无关</p>
<p>2.本模块中引用了一个位于其它模块中的符号<code>addcnt</code>,本模块中妹有定义,因此编译器会为其生成一个<code>GOT</code>表项,又从代码段到数据段GOT的跳转需要重定位,因此汇编器会生成一个重定位条目,为静态链接器(相对动态链接器的说法)进行重定位做准备</p>
<p>3.编译阶段是不知道GOT表在哪里的(即使GOT表和代码段在同一模块中),汇编器只会生成重定位条目</p>
<p>4.静态链接阶段才会将代码段中对GOT的引用重定位,</p>
<p>5.静态链接后,在代码段只需要对GOT表的PC相对寻址,在实际运行时,由动态链接器去实际填充该表项应该指向的地址</p>
<blockquote>
<p>注意这里有两次引用,一是代码段引用数据段的GOT表,二是GOT表引用其他模块中的符号</p>
</blockquote>
<blockquote>
<p>GOT表的存在,相当于编译器和静态链接器给动态链接器减轻了负担,动态链接器不需要去代码段找需要解析的引用,只需要看看数据段的开头,就知道哪些引用需要解析</p>
<p>至于动态链接器是个啥,怎么工作的,现在不关心,就当是一个黑盒,它在程序运行阶段发挥作用,结果是给GOT表中的引用找到实际地址,填充到GOT表项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R[%rax]&lt;---R[%rip]+0x2008b9=&amp;GOT[3]		//主存中GOT[3]的地址放到rax寄存器中</span><br><span class="line">M[R[%rax]]=M[R[%rip]+0x2008b9]=M[%GOT[3]]&lt;---M[%GOT[3]]+1			//解引用后+1再放回去</span><br></pre></td></tr></table></figure>
<h5 id="pic函数调用">PIC函数调用</h5>
<p>GOT和PLT协作</p>
<p>CSAPP教材上给出了看起来不长,却信息量巨大的图文,下面就这一段文字进行解读</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526201953361.png"
alt="image-20220526201953361" />
<figcaption aria-hidden="true">image-20220526201953361</figcaption>
</figure>
<h6 id="过程链接表plt">·过程链接表(PLT)</h6>
<p>1.PLT是一个数组,其中每个条目都是16字节的代码.</p>
<blockquote>
<p>PLT表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001020</span><br><span class="line">.plt:0000000000001020                               ; Segment type: Pure code	;段类型:纯代码</span><br><span class="line">.plt:0000000000001020                               ; Segment permissions: Read/Execute	;段权限:读/执行/不可写</span><br><span class="line">.plt:0000000000001020                               _plt            segment para public &#x27;CODE&#x27; use64</span><br><span class="line">.plt:0000000000001020                                               assume cs:_plt	;令cs段寄存器指向plt段</span><br><span class="line">.plt:0000000000001020                                               ;org 1020h</span><br><span class="line">.plt:0000000000001020                                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing</span><br></pre></td></tr></table></figure>
<p>PLT表的表项16字节一个,表项内容是<strong>代码(指令)</strong></p>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;6字节</span><br><span class="line">.plt:0000000000001030                               _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001030 FF 25 E2 2F 00 00                             jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030                               _isPrime        endp</span><br><span class="line"></span><br><span class="line">;10字节</span><br><span class="line">.plt:0000000000001036 68 00 00 00 00                                push    0</span><br><span class="line">.plt:000000000000103B E9 E0 FF FF FF                                jmp     sub_1020</span><br></pre></td></tr></table></figure>
<p>为什么是16字节?</p>
<p>有些指令长,有些指令短,有些plt条目中有多条指令</p>
<p>16字节应该是存在的最长的plt表项</p>
</blockquote>
<p>2.PLT[0]是一个特殊条目,它跳转到动态链接器中.</p>
<blockquote>
<p>1.动态链接器本身就是一个动态库中的函数,是位置无关代码.因此也需要借助GOT和PLT表跳转.</p>
<p>2.PLT表中不只有用户显示引用的动态库中的函数,还有用户妹有显示引用却不可或缺的动态库函数,比如动态链接器</p>
</blockquote>
<p>3.每个被可执行程序调用的库函数都有自己的PLT表条目.每个条目都负责一个具体的函数</p>
<p>不光调用<code>glibc.so</code>动态库中的函数比如<code>printf</code>时有PLT条目,调用自定义的动态库也会有PLT条目</p>
<blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//isPrime为自定义动态库libfunc.so中的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=isPrime(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);		<span class="comment">//printf为glibc.so中的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>制作动态库并链接,执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libfunc.so func.c</span><br><span class="line"></span><br><span class="line">gcc -g main.c ./libfunc.so  -O0 -o prog </span><br></pre></td></tr></table></figure>
<p>使用ida64打开prog观察反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001030 ; int printf(const char *format, ...)</span><br><span class="line">.plt:0000000000001030 _printf         proc near               ; CODE XREF: main+29↓p</span><br><span class="line">.plt:0000000000001030                 jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030 _printf         endp</span><br><span class="line">...</span><br><span class="line">.plt:0000000000001040 _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001040                 jmp     cs:off_4020</span><br><span class="line">.plt:0000000000001040 _isPrime        endp</span><br></pre></td></tr></table></figure>
<p>都生成了plt条目</p>
</blockquote>
<h6 id="全局偏移量表got">·全局偏移量表(GOT)</h6>
<p>初始时,每个GOT条目都对应PLT条目的第二条指令</p>
<blockquote>
<p>这其实不是GOT的特性了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   8:   bf fe 01 00 00          mov    $0x1fe,%edi</span><br><span class="line">   d:   e8 00 00 00 00          call   12 &lt;main+0x12&gt;	//此处call的地址就在下一行啊</span><br><span class="line">  12:   89 45 fc                mov    %eax,-0x4(%rbp)</span><br><span class="line">  15:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  18:   89 c6                   mov    %eax,%esi</span><br><span class="line">  1a:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 21 &lt;main+0x21&gt;</span><br><span class="line">  21:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  24:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  29:   e8 00 00 00 00          call   2e &lt;main+0x2e&gt;//此处call的地址就在下一行</span><br><span class="line">  2e:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  33:   c9                      leave</span><br><span class="line">  34:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>由于编译器和静态链接器不能决定引用函数的具体地址,因此他俩只能摆烂.</p>
<p>动态链接器会把GOT指向的地址修改为动态库函数地址</p>
</blockquote>
<h5 id="举个例子">举个例子</h5>
<p>CSAPP举的例子</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526211008954.png"
alt="image-20220526211008954" />
<figcaption aria-hidden="true">image-20220526211008954</figcaption>
</figure>
<h6 id="首次调用addvec"><strong>首次调用addvec</strong></h6>
<p>1.<code>callq 0x4005c0 #call addvec()</code></p>
<p>该指令执行时会将该call指令的后一条指令的地址作为返回时的地址压栈,然后置<code>PC=0x0x4005c0</code>,然后转移控制</p>
<p>2.<code>0x4005c0  jmpq *GOT[4]</code></p>
<p>这里<code>*GOT[4]</code>不是汇编语言的写法,是编者方便读者理解,使用了C语言中数组的表示方法</p>
<p>这里的意思是,跳转到<code>GOT[4]</code>指向的地址(即<code>GOT[4]</code>表项中存放的地址),而不是跳转到<code>GOT[4]</code>的地址</p>
<blockquote>
<p>实际上是这种写法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    1040:	ff 25 da 2f 00 00    	jmp    *0x2fda(%rip)        # 4020 &lt;isPrime@Base&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>间接跳转</p>
</blockquote>
<p>在第一次调用addvec时,<code>GOT[4]=0x4005c6</code>即<code>0x4005c0</code>的下一条地址</p>
<p>3.<code>pushq $0x1</code></p>
<p>CSAPP上对这条指令的解释是"把<code>addvec</code>的ID(0x1)压栈"</p>
<p>啥意思呢?</p>
<p>我的理解是,addvec是用户指定调用的第一条库函数(不包括编译器自己写上的动态链接器等隐式调用的函数),因此把1这个魔数压栈,压栈的目的是作为参数,接下来就要调用动态链接器了,因此传递1作为参数,告诉动态链接器应该动态链接的是用户调用的第一个库函数addvec</p>
<p>4.<code>pushq *GOT[1]</code></p>
<p><code>GOT[1]</code>存放的是<code>.reloc</code>节的首地址</p>
<p>联系刚才的<code>push $0x1</code>,可以猜测,<code>.reloc</code>是一个表,每一个表项对应一个需要重定位的库函数,其中第一条就是<code>addvec</code>的表项,然后动态链接器要用这个<code>0x1</code>去查<code>.reloc</code>表</p>
<p>5.<code>jmpq *GOT[2]</code></p>
<p><code>GOT[2]</code>存放的是动态链接器的地址,</p>
<p>用<code>jmpq GOT[2]</code>会跳转到<code>GOT[2]</code>,啥也不会发生</p>
<p>用<code>jmpq *GOT[2]</code>会跳转到<code>GOT[2]</code>的内容,也就是动态链接器的地址</p>
<p>为啥不用<code>call</code>指令调用,却用<code>jmpq</code>直接跳转到函数的开始呢?</p>
<p><code>call</code>指令需要将跳转前的下一条指令压栈作为返回地址,返回地址将会覆盖栈顶上用于动态链接器的参数.</p>
<p>而<code>jmpq</code>直接跳转到动态链接器,栈顶此时就是他要使用的参数</p>
<p>6.动态链接器会确定<code>.reloc</code>表中第一个库函数即<code>addvec</code>的运行时地址,然后用该地址改写<code>GOT[4]</code></p>
<blockquote>
<p>具体怎么查的addvec运行时地址,怎么改写的GOT[4],那是后话了,现在当成黑盒子用</p>
</blockquote>
<p>7.动态链接器将控制交给addvec,此时才开始真正执行<code>call addvec</code></p>
<h6 id="第二次调用addvec"><strong>第二次调用addvec</strong></h6>
<p>由于第一次调用addvec时,动态链接器已经将<code>GOT[4]</code>改写为正确的<code>addvec</code>运行时地址,现在调用就不会在请动态链接器出马了</p>
<p>在<code>jmpq *GOT[4]</code>之后就跳转到了<code>addvec</code>的首地址</p>
<p>这里不用call的原因是,这里就是想把控制交给addvec,不需要记录PLT表中的返回地址</p>
<p>在主函数调用addvec时已经<code>call addvec</code>了</p>
<blockquote>
<p>这有点类似于记忆化搜索</p>
<p>记忆数组对应GOT表</p>
<p>搜索函数对应动态链接器</p>
<p>第一次搜索前记忆数组都是空的,对应GOT表返回地址不正确</p>
<p>搜索到之后搜素函数会改写记忆数组相应元素,对应动态链接器会修改GOT表项为函数运行时地址</p>
<p>第二次搜索时如果记忆数组不为空则直接使用数组内容,不调用搜索函数,对应第二次调用函数时直接根据GOT表跳转</p>
</blockquote>
<h3 id="库打桩">库打桩</h3>
<blockquote>
<p>打桩:打桩，指把桩打进地里，使<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/建筑物/673834">建筑物</a>基础坚固。--百度百科</p>
</blockquote>
<p>很纳闷为什么library interpositioning要翻译成打桩</p>
<p>library interpositioning 库 插入</p>
<p>就是程序本来应该调用一个库函数却被劫持调用一个包装函数或者其他逻辑的函数.甚至不如叫"库劫持"更直观</p>
<h4 id="预编译时打桩">预编译时打桩</h4>
<p>使用宏定义劫持库函数</p>
<h5 id="main.c-2"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>				<span class="comment">//此处的&lt;malloc.h&gt;不一定就是glibc中的头文件,有可能是劫持使用的&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只是有这么一个<code>main.c</code>文件,
用<code>gcc main.c -o main</code>命令,编译链接之后所有都按部就班地发生,真正调用glibc库的malloc函数申请堆内存</p>
<p>下面给他劫持喽</p>
<h5 id="malloc.h"><code>malloc.h</code></h5>
<p>注意本头文件和库函数<code>malloc</code>声明所在的头文件<code>malloc.h</code>同名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMALLOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMALLOC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)				<span class="comment">//宏定义劫持库函数</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> free(ptr) mymalloc(ptr)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>;			<span class="comment">//声明函数接口</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="mymalloc.c"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span>				</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>&#123;				<span class="comment">//mymalloc的实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc啥也不干&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free啥也不干&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="命令">命令:</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c</span><br><span class="line"></span><br><span class="line">gcc -I. -o main main.c mymalloc.c</span><br><span class="line"></span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc搜索头文件的规则</p>
<blockquote>
<p>当#include &lt;headerfile.h&gt;
时，编译时按照"<code>编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
<p>当#include
"headerfile.h"，编译时按照"<code>源文件当前目录---&gt;编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
</blockquote>
<p>我们在使用glibc库函数时一般使用<code>&lt;malloc.h&gt;</code>,在不加编译命令时,编译器根本不会在当前工作目录下搜索这种尖括号头文件</p>
<p>而我们现在就想给他劫持到搜索当前工作目录,这就是编译时打桩</p>
<p>怎么实现这个头文件劫持呢?编译时加入<code>-I</code>选项,意思是告诉编译器,在搜索系统预设目录前,先按照编译命令指定目录(<code>-I.</code>这里的点号<code>.</code>就是当前目录)搜索头文件.</p>
<p>当前文件夹下恰好有我们自己写的同名头文件malloc.h,只要能找到,编译器就不会再在其他目录找这个头文件</p>
<p>然后在链接时需要给出我们自己写的<code>malloc.h</code>中的两个函数引用<code>mymalloc</code>和<code>myfree</code>,这就是<code>mymalloc.c</code>要做的事情了</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc啥也不干malloc啥也不干</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上glibc中的malloc从未被调用过</p>
<p>总结预编译时打桩的步骤:</p>
<p>1.修改库函数头文件搜索位置</p>
<p>2.链接新的实现</p>
</blockquote>
<p>但是吧,PWN的题目都是给出一个已经编译链接完成的可执行目标文件.谁会让你在预编译阶段做手脚呢?</p>
<p>只能说,没用的知识又怎加了</p>
<h4 id="链接时打桩">链接时打桩</h4>
<h5 id="main.c-3"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<code>main.c</code>看起来还是非常正常的,使用<code>gcc main.c -o main</code>可以编译链接得到一个正儿八经的程序</p>
<p>下面用链接时打桩给他劫持喽</p>
<h5 id="mymalloc.c-1"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span>);		<span class="comment">//对glibc中真·库函数malloc的引用</span></span><br><span class="line"><span class="type">void</span> *__real_free(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)&#123;	<span class="comment">//包装函数</span></span><br><span class="line">    <span class="type">void</span> *ptr=__real_malloc(<span class="number">510</span>);<span class="comment">//包装函数会调用真函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper malloc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *__wrap_free(<span class="type">void</span> *ptr)&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper free\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为啥函数名前面要假设<code>__real,__wrap</code>这种前缀?</p>
<h5 id="命令-1">命令</h5>
<p><code>shellscript.sh</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c		<span class="meta">#mymalloc.c编译成可重定位目标文件</span></span><br><span class="line">	</span><br><span class="line">gcc -c main.c			<span class="meta">#main.c编译成可重定位目标文件</span></span><br><span class="line"></span><br><span class="line">gcc -Wl,--wrap,<span class="built_in">malloc</span> -Wl,--wrap,<span class="built_in">free</span>  -o  prog main.o mymalloc.o	</span><br><span class="line">    </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the linker.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>comma-separated 用逗号分开的</p>
<p>给链接器传递用逗号分开的<选项></p>
</blockquote>
<p><code>--wrap,malloc</code>的作用是,链接器将malloc这个符号解析为<code>__wrap_malloc</code>这个符号,并且将<code>__real_malloc</code>这个符号解析为<code>malloc</code></p>
<p>那么在<code>main.c</code>中调用malloc时会被链接器重定位到<code>__wrap_malloc</code>的定义,</p>
<p>真正的glibc库中的<code>malloc</code>需要使用<code>__real_malloc</code>调用</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/link]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line"><span class="keyword">in</span> wrapper malloc</span><br><span class="line"><span class="keyword">in</span> wrapper free</span><br></pre></td></tr></table></figure>
<p>同样的道理,CTF题也不会让在链接阶段办手续,又是没用的知识</p>
<h4 id="运行时打桩">运行时打桩</h4>
<h5 id="运行时加载链接共享库">运行时加载链接共享库</h5>
<p>Linux系统为<strong>动态链接器</strong>提供的<strong>系统调用</strong>:]</p>
<h6 id="dlopen"><code>dlopen</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag)</span>;<span class="comment">//成功则返回指向句柄的指针,一个代表共享库的句柄handle</span></span><br></pre></td></tr></table></figure>
<p>加载链接共享库<code>filename</code></p>
<p>flag参数值含义:</p>
<p><code>RTLD_GLOBAL</code>用其他用该选项打开的库解析filename库中的外部符号</p>
<p><code>RTLD_NOW</code>,链接器立刻解析外部符号引用</p>
<p><code>RTLD_LAZY</code>,链接器不得不解析外部符号时才进行解析</p>
<h6 id="dlsym"><code>dlsym</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle,<span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>
<p><code>handle</code>是<code>dlopen</code>的返回值,即指向共享库句柄的指针</p>
<p><code>symbol</code>是handle指向的共享库中的符号,比如一个全局变量或者一个符号</p>
<p>如果存在则返回该symbol的地址,否则返回NULL</p>
<h6 id="dlclose"><code>dlclose</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure>
<p>卸载handle指向的共享库</p>
<h6 id="dlerror"><code>dlerror</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回字符串,内容是最近调用前面三个函数时发生的错误,如果妹有错误则返回NULL</p>
<h6 id="举个例子-1">举个例子</h6>
<p>由于gcc会隐式加载链接glibc.so库,我们需要自己写一个动态库,比如<code>geometry</code></p>
<blockquote>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>geometry.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成动态库<code>libgeometry.so</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so geometry.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>		<span class="comment">//引入该头文件的主要作用是,获得Point结构体的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> *handle=dlopen(<span class="string">&quot;./libgeometry.so&quot;</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>)=dlsym(handle,<span class="string">&quot;newPoint&quot;</span>);<span class="comment">//函数指针指向handle库中&quot;newPoint&quot;符号</span></span><br><span class="line">    <span class="type">void</span> (*showPoint)(Point)=dlsym(handle,<span class="string">&quot;showPoint&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!newPoint||!showPoint)&#123;			<span class="comment">//检查newPoint和showPoint是否真的获得了地址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Point p=newPoint(<span class="number">1.2</span>,<span class="number">3.4</span>);			</span><br><span class="line">    showPoint(p);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dlclose(handle)&lt;<span class="number">0</span>)&#123;	<span class="comment">//卸载动态库</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>);</span><br></pre></td></tr></table></figure>
<p>声明一个返回值为Point类型,双参数都是double类型的函数指针</p>
</blockquote>
<p>编译命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# gcc -rdynamic -o prog main.c -ldl</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lenky.info/tag/rdynamic/">-rdynamic</a> 却是一个 <a
target="_blank" rel="noopener" href="http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html">连接选项</a>
，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号）都添加到动态符号表（即.dynsym表）里，以便那些通过
<a
target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man3/dlopen.3.html">dlopen()</a>
或 <a
target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/backtrace.3.html">backtrace()</a>
（这一系列函数使用.dynsym表内符号）这样的函数使用。</p>
<p>添加-rdynamic选项后，.dynsym表就包含了所有的符号，不仅是已使用到的外部动态符号，还包括本程序内定义的符号，比如bar、foo、baz等。</p>
<p>参考博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/fengdijiang/article/details/108882608">gcc或g++的编译选项
-shared -fPIC 与 -g -rdynamic
部分转载_字正腔圆的博客-CSDN博客_rdynamic</a></p>
<p><code>-ldl</code>的作用是链接<code>dlfcn</code>库,是我们能够使用<code>dlopen</code>这种函数</p>
</blockquote>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# ./prog</span><br><span class="line">(1.20,3.40)</span><br></pre></td></tr></table></figure>
<h5 id="运行时打桩-1">运行时打桩</h5>
<p>运行时打桩的思想是,自己写一个家的<code>malloc</code>函数,该函数使用dlopen等函数在运行时加载<code>glibc</code></p>
<p>奇怪,我按照CSAPP的说法做的实验,结果会报告段错误,留作后话吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/24/markdown%E8%8A%B1%E9%87%8C%E7%8B%90%E7%AC%91%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/24/markdown%E8%8A%B1%E9%87%8C%E7%8B%90%E7%AC%91%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">markdown花里狐笑功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-24 10:23:00" itemprop="dateCreated datePublished" datetime="2022-05-24T10:23:00+08:00">2022-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-27 12:19:36" itemprop="dateModified" datetime="2022-05-27T12:19:36+08:00">2022-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="markdown花里狐笑功能">markdown花里狐笑功能</h1>
<p>看看这个博客主题是否支持呢</p>
<p>以这种方式添加自己的HTML页面,<a
target="_blank" rel="noopener" href="https://dustball.top/HTML/markdown_function.html">markdown花里狐笑功能</a>,是可以的</p>
<p>typora首先导出HTML文件然后放在source/HTML里面,缺点是在博客主页找不到,只能输入URL.</p>
<p>优点是typora有多聪明,这个HTML页面就有多聪明</p>
<h2 id="html-elem">HTML elem</h2>
<p><kbd>一个长得像键盘一样的东西</kbd></p>
<script>function myfunction(){alert(0)}</script>
<button onclick="myfunction()">
一个长得像按钮一样的东西
</button>
<hr>
<p>水平线</p>
<!--注释-->
<center>
居中
</center>
<p><cite>引用</cite></p>
<p><code>code block</code></p>
<p><em>强调</em></p>
<progress>
g飞过来飞过去
</progress>
<p>测试下标<sub>下标</sub>测试上标<sup>上标</sup></p>
<p><u>下划线</u></p>
<p><var>变量</var></p>
<form action="demo_form.php" method="get">
First name: <input type="text" name="fname"><br> Last name:
<input type="text" name="lname"><br> <input type="submit" value="提交">
</form>
<p><input>输入控件</input></p>
<p><select> <option value="下拉框">下拉框</option>
<option value="选项1">选项1</option>
<option value="选项2">选项2</option>
<option value="选项3">选项3</option> </select></p>
<p>图像</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511100355390.png">图像</img></p>
<p>听歌</p>
<audio src="https://other-web-nf01-sycdn.kuwo.cn/191ac0e387ba16b02edbf6425b1a715e/628c3c52/resource/n1/96/74/235556933.mp3">
</audio>
<p><mark>标记</mark></p>
<blockquote>
块引用
</blockquote>
<p><i>比萨斜塔</i></p>
<nav>
导航栏
</nav>
<h2 id="sequence">sequence</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title:三次握手和四次挥手</span><br><span class="line">participant deutschball as d</span><br><span class="line">participant schwertlilien as s</span><br><span class="line">d--&gt;s:you fooooooooool.</span><br><span class="line">s--&gt;d:you stupppppppid.</span><br><span class="line">d--&gt;s:roger that.</span><br><span class="line">note over d,s:connection initialized</span><br><span class="line">note over d,s:exchanging information...</span><br><span class="line">note over d,s:connection lost</span><br><span class="line">d--&gt;s: fuck you!</span><br><span class="line">s--&gt;d: roger that</span><br><span class="line">s--&gt;d: fuck you!do you copy?</span><br><span class="line">d--&gt;s: roger that</span><br></pre></td></tr></table></figure>
<h2 id="flow">flow</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<h2 id="mermaid">mermaid</h2>
<h3 id="pie">pie</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 世界人口</span><br><span class="line">    &quot;俄国人&quot; : 15</span><br><span class="line">    &quot;美国人&quot; : 20</span><br><span class="line">    &quot;中国人&quot; : 500</span><br></pre></td></tr></table></figure>
<h3 id="graph">graph</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B -- Yes --&gt; C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B -- No ----&gt; E[End];</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/23/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/23/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">CSAPP-chapter3 x86-64汇编语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-23 19:30:00 / Modified: 19:37:19" itemprop="dateCreated datePublished" datetime="2022-05-23T19:30:00+08:00">2022-05-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="csapp-chapter3-x86-64-assembly">CSAPP-chapter3 x86-64
Assembly</h1>
<h2 id="汇编变种后缀的应用场景">汇编变种后缀的应用场景</h2>
<h3 id="前置知识">前置知识:</h3>
<h4 id="c语言数据格式">0.C语言数据格式</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(char)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(short)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(int)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(long)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(long long)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(void*)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span> *) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在64位ubuntu上的运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ test.cpp -o test.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./test.out</span><br><span class="line">sizeof(char)=1</span><br><span class="line">sizeof(short)=2</span><br><span class="line">sizeof(int)=4</span><br><span class="line">sizeof(long)=8</span><br><span class="line">sizeof(long long)=8</span><br><span class="line">sizeof(void*)=8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在64位windows上的运行结果稍有不同</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(char)=1</span><br><span class="line">sizeof(short)=2</span><br><span class="line">sizeof(int)=4</span><br><span class="line">sizeof(long)=4</span><br><span class="line">sizeof(long long)=8</span><br><span class="line">sizeof(void*)=8</span><br></pre></td></tr></table></figure>
<p>在32位windows上的运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(char)=1</span><br><span class="line">sizeof(short)=2</span><br><span class="line">sizeof(int)=4</span><br><span class="line">sizeof(long)=4</span><br><span class="line">sizeof(long long)=8</span><br><span class="line">sizeof(void*)=4</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th>操作系统(字节)</th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>long long</th>
<th>void*</th>
</tr>
</thead>
<tbody>
<tr>
<td>linux64位</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>windows64位</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>windows32位</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>4</td>
</tr>
</tbody>
</table>
<h4 id="寄存器规格">1.寄存器规格</h4>
<p>大多数的后缀都与寄存器规格有关,下图将会被多次用到</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406175644150.png"
alt="image-20220406175644150" />
<figcaption aria-hidden="true">image-20220406175644150</figcaption>
</figure>
<h4 id="寻址方式">2.寻址方式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406180238442.png"
alt="image-20220406180238442" />
<figcaption aria-hidden="true">image-20220406180238442</figcaption>
</figure>
<h3 id="mov类">mov类</h3>
<h4 id="操作数长度相关后缀bwlq">操作数长度相关后缀b,w,l,q</h4>
<p>mov类命令的<strong>数据流动方向</strong>有五种,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">立即数-&gt;寄存器</span><br><span class="line">寄存器-&gt;寄存器</span><br><span class="line">主存  -&gt;寄存器</span><br><span class="line">立即数-&gt;主存</span><br><span class="line">寄存器-&gt;主存</span><br></pre></td></tr></table></figure>
<p>显然<code>立即数-&gt;立即数</code>是不可能的,这里立即数相当于右值,就好比说把5存到6上</p>
<p>并且规定不能从主存直接到主存即<code>主存-&gt;主存</code>,必须经过寄存器</p>
<p>与<strong>数据长度有关的后缀</strong>有</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406174739043.png"
alt="image-20220406174739043" />
<figcaption aria-hidden="true">image-20220406174739043</figcaption>
</figure>
<blockquote>
<p>这里两个字节等于一个字</p>
<p>便于记忆,可以了解后缀的含义:</p>
<p>b:byte,一个字节</p>
<p>w:word,一个字(两个字节)</p>
</blockquote>
<p>使用哪种后缀需要与数据流动方向一起决定,具体规则是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.主存没有决定后缀的权利</span><br><span class="line"></span><br><span class="line">2.如果源或者目的其一是寄存器则根据寄存器大小决定,如果使用的是`%al,%spl`这种单字节寄存器则mov命令用b后缀,</span><br><span class="line">同理如果使 `%rax,%rsp`这种8个字节寄存器则mov命令用q后缀.</span><br><span class="line">如果源和目的都是寄存器则跟随目的寄存器规格</span><br><span class="line"></span><br><span class="line">3.寄存器比立即字的优先级高</span><br></pre></td></tr></table></figure>
<p>记住这三条规则才能完成3.2</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406175452026.png"
alt="image-20220406175452026" />
<figcaption aria-hidden="true">image-20220406175452026</figcaption>
</figure>
<p><strong>1.<code>movl %eax,(%rsp)</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406175737319.png"
alt="image-20220406175737319" />
<figcaption aria-hidden="true">image-20220406175737319</figcaption>
</figure>
<p>源<code>%eax</code>为32位(=4字节=2字)寄存器,</p>
<p>目的<code>(%rsp)</code>是采用简介寻址,实际地址位于内存中,没有发言权,</p>
<p>因此<code>mov</code>的后缀跟随<code>%eav</code>即传送双字,使用l后缀</p>
<p><strong>2.<code>movw (%rax),%dx</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406180020141.png"
alt="image-20220406180020141" />
<figcaption aria-hidden="true">image-20220406180020141</figcaption>
</figure>
<p>源<code>(%rax)</code>在内存中,没有发言权,</p>
<p>目的<code>%dx</code>是一个16位(=2字节=1字)寄存器</p>
<p>因此<code>mov</code>的后缀跟随<code>%dx</code>即传送单字,使用w后缀</p>
<p><strong>3.<code>movb $0xFF %bl</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406180630017.png"
alt="image-20220406180630017" />
<figcaption aria-hidden="true">image-20220406180630017</figcaption>
</figure>
<p>源<code>$0xFF</code>是一个立即字,优先级低</p>
<p>目的<code>%bl</code>是一个字节寄存器,优先级高</p>
<p><code>mov</code>后缀跟随<code>%bl</code>使用b</p>
<p><strong>4.<code>movb (%rsp,%rdx,4) %dl</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406180836564.png"
alt="image-20220406180836564" />
<figcaption aria-hidden="true">image-20220406180836564</figcaption>
</figure>
<p>源<code>(%rsp,%rdx,4)</code>在内存上,没有发言权</p>
<p>目的<code>%dl</code>是一个字节寄存器</p>
<p><code>mov</code>后缀跟随<code>%dl</code>使用b</p>
<p><strong>5.<code>movq (%rdx),%rax</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406181217813.png"
alt="image-20220406181217813" />
<figcaption aria-hidden="true">image-20220406181217813</figcaption>
</figure>
<p>源<code>(%rdx)</code>在内存上,没有发言权</p>
<p>目的<code>%rax</code>是一个四字寄存器</p>
<p><code>mov</code>后缀跟随<code>%rax</code>使用q</p>
<p><strong>6.<code>movw %dx,(%rax)</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406181231776.png"
alt="image-20220406181231776" />
<figcaption aria-hidden="true">image-20220406181231776</figcaption>
</figure>
<p>源<code>%dx</code>是一个单字寄存器</p>
<p>目的<code>(%rax)</code>在内存上,没有发言权</p>
<p>因此<code>mov</code>后缀跟随<code>%dx</code>用w</p>
<h5 id="长度类后缀的其他细节差异">长度类后缀的其他细节差异</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406191326874.png"
alt="image-20220406191326874" />
<figcaption aria-hidden="true">image-20220406191326874</figcaption>
</figure>
<p>1.<code>movb,movw</code>只会修改目标寄存器的对应低位</p>
<p>2.<code>movl</code>不光会修改目标寄存器的对应低位,并且会将高位全部置零</p>
<p>3.对于64位的立即数,1.只能用<code>movabsq</code>2.将其存到寄存器中,<code>movq</code>只能处理32位的立即数</p>
<h4 id="数据拓展相关后缀zs">数据拓展相关后缀z,s</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406193244989.png"
alt="image-20220406193244989" />
<figcaption aria-hidden="true">image-20220406193244989</figcaption>
</figure>
<blockquote>
<p>零拓展和符号拓展的区别:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406194028869.png"
alt="image-20220406194028869" />
<figcaption aria-hidden="true">image-20220406194028869</figcaption>
</figure>
<p><code>R(%dl)=AA=10101010</code>符号位为1</p>
<p>第4行符号拓展直接将高位全都置1得到一串F</p>
<p>第5行零拓展直接将高位全都置0得到一串0</p>
<p>有符号数拓展时使用符号拓展</p>
<p>无符号数拓展时使用0拓展,可以理解为无符号拓展</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406200228709.png"
alt="image-20220406200228709" />
<figcaption aria-hidden="true">image-20220406200228709</figcaption>
</figure>
<p>1.首先,使用指针的目的是,使实际操作的地址在内存中,如此需要在寄存器中过度一次,将转型分成两个阶段,即<code>源内存-&gt;寄存器</code>和<code>寄存器-&gt;目的内存</code>两个阶段</p>
<p>2.然后一定注意"==当执行强制类型转换即涉及大小变化又涉及C语言中的符号变化时,操作应该先改变大小=="</p>
<blockquote>
<p>这里"先改变大小"的意思是,无符号源用z,有符号源用s,然后决定大小的后缀看目的的大小</p>
</blockquote>
<p><strong>1.long到long</strong></p>
<p>不涉及大小变化,不涉及符号变化,只需要使用传送四字指令<code>movq</code>,两个阶段相同</p>
<p><strong>2.char到int</strong></p>
<p>只涉及大小变化,首先从字节内存到双字寄存器需要符号拓展指令<code>movsbl</code>
然后从双字寄存器到内存根据寄存器规格决定使用双字传送指令<code>movl</code></p>
<p><strong>3.char到unsigned</strong></p>
<p>既涉及大小变化,又涉及符号变化</p>
<p>首先改变大小,从有符号字节内存到双字寄存器需要符号拓展指令<code>movsbl</code></p>
<p>然后从双字寄存器到双字内存根据寄存器规格决定使用双字传送指令<code>movl</code>,即目的符号不起作用</p>
<blockquote>
<p>char到unsigned int和char到int形成的汇编语言是相同的</p>
</blockquote>
<blockquote>
<p>这一点可以实验验证</p>
<p>对于char的最小值-128=0x80,如果强制转型到unsigned,可能的结果:</p>
<p>1.首先变化符号,然后变化大小,即首先使用<code>movzbl</code>,然后<code>movl</code>,这样unsigned的值为<code>0x00000080=128</code></p>
<p>2.首先变化大小,然后变化符号,即首先使用<code>movsbl</code>,然后<code>movl</code>,这样unsigned值为<code>0xFFFFFF80=4294967168</code></p>
<p>基于上述两种猜想,可以写如下程序验证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406201752965.png"
alt="image-20220406201752965" />
<figcaption aria-hidden="true">image-20220406201752965</figcaption>
</figure>
<p>证明猜想2是正确的</p>
</blockquote>
<p><strong>4.unsigned char到long</strong></p>
<p>既涉及大小变化,又涉及符号变化</p>
<p>首先改变大小,从无符号字节内存到四字寄存器,要使用无符号拓展指令<code>movzbq</code></p>
<p>然后从四字寄存器到内存,使用四字传送指令<code>movq</code></p>
<p>然而实际上首先使用的是<code>movzbl</code></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/291651098">查阅了知乎</a></p>
<p>然后官方给出的解释:</p>
<blockquote>
<p>(Clarification, not an erratum) Figure 3.5.</p>
<p>Although there is an instruction movzbq, the GCC compiler typically
generates the instruction movzbl for this purpose, relying on the
property that an instruction generating a 4-byte with a register as
destination will fill the upper 4 bytes of the register with zeros.</p>
<p>尽管应该使用movzbq指令,但是GCC编译器通常使用movzbl指令来达到相同的目的,</p>
<p>==这是因为只要是以寄存器为目的并且生成低位4字节的指令都会将高位的4字节置零==</p>
</blockquote>
<p>博客上其他人的解释</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220406203013260.png"
alt="image-20220406203013260" />
<figcaption aria-hidden="true">image-20220406203013260</figcaption>
</figure>
<p>这就很明白了</p>
<p><strong>5.int到char</strong></p>
<p>只涉及大小转换,大变小直接截取</p>
<p>直接从内存中取出双字数据放到寄存器里然后截取低8位传送给内存</p>
<p>即首先使用<code>movl</code>然后<code>movb</code></p>
<p><strong>6.unsigned到unsigned char</strong></p>
<p>只涉及大小转换,大变小直接截取</p>
<p>直接从内存中取出双字数据放到双字寄存器然后截取低8位传送给内存</p>
<p>即首先使用<code>movl</code>然后<code>movb</code></p>
<p><strong>7.char到short</strong></p>
<p>只涉及大小变换,小变大需要拓展</p>
<p>首先使用有符号拓展<code>movsbw</code>将字节数据传送到单字寄存器</p>
<p>然后使用<code>movw</code>从单字寄存器传送到内存</p>
<h2 id="汇编语言特殊算术操作">汇编语言特殊算术操作</h2>
<p>首先纠错</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407195514558.png"
alt="image-20220407195514558" />
<figcaption aria-hidden="true">image-20220407195514558</figcaption>
</figure>
<p>书上除法这里是有错误的,商和余数都放在了<code>R[%rdx]</code>这显然是不合理的,我觉得应该写为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407210130248.png"
alt="image-20220407210130248" />
<figcaption aria-hidden="true">image-20220407210130248</figcaption>
</figure>
<h3 id="乘法">乘法</h3>
<p>c源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"><span class="comment">//此处改名的目的是让128位整数能够类似64位整数使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">store_uprod</span><span class="params">(<span class="type">uint128_t</span> *dest,<span class="type">uint64_t</span> x,<span class="type">uint64_t</span> y)</span>&#123;</span><br><span class="line">                *dest=x*(<span class="type">uint128_t</span>) y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movq    %rsi, %rax</span><br><span class="line">mulq    %rdx</span><br><span class="line">movq    %rax, (%rdi)</span><br><span class="line">movq    %rdx, 8(%rdi)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>逻辑分析:</p>
<p>首先三个参数分别存放在</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407195244614.png"
alt="image-20220407195244614" />
<figcaption aria-hidden="true">image-20220407195244614</figcaption>
</figure>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R[%rdi]=dest//这里%rdi寄存器中存放的是dest这个位置 dest这个位置 dest这个位置</span><br><span class="line">R[%rsi]=x</span><br><span class="line">R[%rdx]=y</span><br></pre></td></tr></table></figure>
<p><strong>1.<code>movq    %rsi, %rax</code></strong></p>
<p>即令<code>R[%rax]=R[%rsi]=x</code>将x放在了<code>%rax</code>寄存器中</p>
<p><strong>2.<code>mulq    %rdx</code></strong></p>
<p><code>R[%rdx]=y</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407195537665.png"
alt="image-20220407195537665" />
<figcaption aria-hidden="true">image-20220407195537665</figcaption>
</figure>
<p>看似只有一个操作数,实际上隐含着另一个操作数在<code>%rax</code>寄存器中</p>
<p>即令<code>R[%rdx]*R[%rax]</code>,两个64位数的计算机结果是一个128位数,显然单独一个64位寄存器是放不下的,因此计算结果被分成两部分</p>
<p>低64位放在<code>%rax</code>寄存器,高64位放在<code>%rdx</code>寄存器</p>
<p><strong>3.<code>movq    %rax, (%rdi)</code></strong></p>
<p><code>R[%rdi]=dest</code>这是指针指向内存中的位置</p>
<p><code>M[R[%rdi]]=M[dest]</code>对内存中的位置dest应用解引用函数<span
class="math inline">\(M[dest]\)</span>得到的是该地址上的实际数值</p>
<p>令<code>M[R[%rdi]]=R[%rax]</code>,将<code>%rax</code>寄存器中刚刚算出的低64位结果放在内存中,位置为<code>R[%rdi]</code>(间接寻址)</p>
<p><strong>4.<code>movq    %rdx, 8(%rdi)</code></strong></p>
<p>刚才在第3步时存放了低64位,那么此时应该做到就是存放高64位</p>
<p>令<code>M[R(%rdi)+8]=R[%rdx]</code>,将<code>%rdx</code>寄存器中刚刚算出的高64位结果放在内存中,位置为<code>R(%rdi)+8</code>(基址+偏移量寻址)</p>
<p>此处的+8为偏移8个字节,因为低地址恰好占用这8个字节</p>
<p>在小端机器上低地址存放低位,高地址存放高位</p>
<p>到此乘法的计算结果已经被分成两个64位数存进了一个<code>uint128_t *</code>指针指向的地址</p>
<h3 id="除法">除法</h3>
<p>c源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remdiv</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y,<span class="type">long</span> *qp,<span class="type">long</span> *rp)</span>&#123;<span class="comment">//希望计算x/y将商存到指针qp指向的地址,将余数存到指针rp指向的地址</span></span><br><span class="line">        <span class="type">long</span> q=x/y;</span><br><span class="line">        <span class="type">long</span> r=x%y;</span><br><span class="line">        *qp=q;</span><br><span class="line">        *rp=r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movq    %rdi, %rax</span><br><span class="line">movq    %rdx, %r8</span><br><span class="line">cqto</span><br><span class="line">idivq   %rsi</span><br><span class="line">movq    %rax, (%r8)</span><br><span class="line">movq    %rdx, (%rcx)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407201308477.png"
alt="image-20220407201308477" />
<figcaption aria-hidden="true">image-20220407201308477</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R[%rdi]=x</span><br><span class="line">R[%rsi]=y</span><br><span class="line">R[%rdx]=qp</span><br><span class="line">R[%rcx]=rp</span><br></pre></td></tr></table></figure>
<p><strong>1.<code>movq    %rdi, %rax</code></strong></p>
<p>令<code>R[%rax]=R[%rdi]=x</code>将x存放在<code>%rax</code>寄存器里</p>
<p><strong>2.<code>movq    %rdx, %r8</code></strong></p>
<p>令<code>R[%r8]=R[%rdx]=qp</code>将商==在内存中的地址==存放在<code>%r8</code>寄存器里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407210300140.png"
alt="image-20220407210300140" />
<figcaption aria-hidden="true">image-20220407210300140</figcaption>
</figure>
<p>对于一个128位数的除法运算,被除数的低64位存放在<code>%rax</code>寄存器中,高64位存放在<code>%rdx</code>寄存器中</p>
<p>刚才在第1步时已经将64位数x放在<code>%rax</code>寄存器中了,但是高64位所在的<code>%rdx</code>现在被第三个参数<code>qp</code>占用,因此将<code>qp</code>放在另一个寄存器<code>%r8</code>中,然后将<code>%rdx</code>腾出来方便存放高64位</p>
<p><strong>3.<code>cqto</code></strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407205028742.png"
alt="image-20220407205028742" />
<figcaption aria-hidden="true">image-20220407205028742</figcaption>
</figure>
<p>为什么要进行符号拓展?</p>
<p>被除数应该是一个128位数,但是目前我们只是确定了其低64位为x,高64位还是第三个参数的值没有修改,如果此时直接计算则高64位的值可以认为是乱码,那么怎么消除高64位的乱码呢?置零或者置符号,我们将要进行符号除法,因此高64位置符号</p>
<p>即高64位按照<code>R[%rax]=x</code>的符号位拓展</p>
<p><strong>4.<code>idivq   %rsi</code></strong></p>
<p><code>R[%rsi]=y</code></p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407210300140.png" /></p>
<p><code>R[%rdx]=x mod y</code></p>
<p><code>R[%rax]=x/y</code></p>
<p><strong>5.<code>movq    %rax, (%r8)</code></strong></p>
<p><code>R[%r8]=qp</code></p>
<p><code>M[R[%r8]]=M[qp]=*qp=R[%rax]=x/y</code></p>
<p><strong>6.<code>movq    %rdx, (%rcx)</code></strong></p>
<p><code>R[%rcx]=rp</code></p>
<p><code>M[R[%rcx]]=M[rp]=*rp=R[%rdx]=x mod y</code></p>
<h3 id="习题3.12">习题3.12</h3>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407210655421.png" /></p>
<p>首先四个参数的存放位置为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407201308477.png"
alt="image-20220407201308477" />
<figcaption aria-hidden="true">image-20220407201308477</figcaption>
</figure>
<p>执行除法的时候只会提供一个操作数S作为除数,表示被除数的另两个操作数是隐含的<code>%rax,%rdx</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407210829932.png"
alt="image-20220407210829932" />
<figcaption aria-hidden="true">image-20220407210829932</figcaption>
</figure>
<p>那么在执行除法命令之前,应该把被除数先安置好</p>
<p>1.首先128位被除数的低64位存放在<code>%rax</code>中,即<code>R[%rax]=x</code>
2.然后高64位存放在<code>%rdx</code>中,无符号除法时应当全置0,</p>
<p>但是由于第三个参数qp已经占据了<code>%rdx</code>,因此在将其全都置零之前应当请三个参数挪个地方,比如<code>%r8</code></p>
<p><code>movq %rdx,%r8</code></p>
<p>3.此时就可以将被除数的高64位<code>%rdx</code>寄存器置0了,最直接的置零方法是<code>movq $0,%rdx</code>,还可以利用异或的性质<code>xorq %rdx,%rdx</code></p>
<p>至于应该选择哪一个?应该选择二进制长度最短的指令</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">0:   48 c7 c2 00 00 00 00    mov    $0x0,%rdx</span><br><span class="line">7:   48 99                   cqto</span><br><span class="line">9:   48 31 d2                xor    %rdx,%rdx</span><br></pre></td></tr></table></figure>
<p>由此可见为什么刚才有符号除法时要用cqto,因为其长度最短</p>
<p>然后xor也是不错的选择</p>
<p>最迫不得已才会选择movq指令</p>
<p>当发现实际编译器使用的命令与我们理想的不一样时,可以写一个.s文件然后将自己理想的汇编指令和实际的汇编指令各写一行</p>
<p>然后使用<code>gcc -Og -c</code>命令,使其编译成为.o文件,注意必须指定<code>-c</code>选项,否则直接编译成.exe或者.out会发生链接错误,因为刚才我门写的.s文件是非常不完整的,连main函数都没有</p>
<p>然后对.o文件使用objdump命令反编译
,就可以观察指令及其二进制编码长度了</p>
<p>一般理想与现实不同都是由于有更加短但是可以完成同样目的的指令我们没有考虑到</p>
</blockquote>
<p>在本题中我不知道类似<code>cqto</code>但是是无符号拓展的指令,可以先用异或指令达到相同的目的</p>
<p>4.被除数在3中已经准备好了,可以进行除法了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220407212434845.png"
alt="image-20220407212434845" />
<figcaption aria-hidden="true">image-20220407212434845</figcaption>
</figure>
<p>这里S是除数,本题中除数是第二个参数y存放在<code>%rsi</code>寄存器中,即<code>R[%rsi]=y</code></p>
<p>那么除法指令为<code>divq %rsi</code></p>
<p>5.除法进行完毕,瓜分商和余数</p>
<p>商位于<code>%rax</code>寄存器中,希望传送到内存中的qp位置,而内存中的qp位置存放在寄存器<code>%r8</code>中(即<code>R[%r8]=qp,M[R[%r8]]=*qp</code>)因此使用指令<code>movq %rax,(%r8)</code></p>
<p>余数位于<code>%rdx</code>寄存器中,希望传送到内存中的rp位置,而内存中的rp位置存放在寄存器<code>%rcx</code>中(即<code>R[%rcx]=rp,M[R[%rcx]]=*rp</code>)因此使用指令<code>movq %rdx,(%rcx)</code></p>
<h2 id="标志与条件控制">标志与条件控制</h2>
<h3 id="标志位">标志位</h3>
<p>标志位的作用都是为了表征刚刚进行过的算术运算的结果,比如是否有溢出,是否有进位,结果是否为0等等,</p>
<p>设置这些标志的目的之一是方便判断错误</p>
<p>之二是决定后面的程序走向,是实现条件,==循环等控制语句的基础==</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408152343527.png"
alt="image-20220408152343527" />
<figcaption aria-hidden="true">image-20220408152343527</figcaption>
</figure>
<p>其中常用的标志位有:</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408152408112.png"
alt="image-20220408152408112" />
<figcaption aria-hidden="true">image-20220408152408112</figcaption>
</figure>
<p>作用:</p>
<h4 id="cf">CF</h4>
<p>进位标志</p>
<p>作用于无符号数,比如对于八位无符号数</p>
<p>加法结果进位溢出:<code>0xFF+0x01=0x100</code>溢出了,此时<code>CF=1</code>表明刚才的算术运算有溢出</p>
<p>减法借位溢出:<code>0x00-0x01=0x100-0x01=0xFF</code>,被减数需要向他不存在的高位借位,此时<code>CF=1</code>表示被减数不够减的</p>
<p>对于有符号整数的加减法,忽略进位标志<code>CF</code></p>
<p>比如有符号整数<code>0x00-0x01=0x00+0xFF=0xFF</code>表示的是<code>0-1=-1</code>,</p>
<p><code>0xFF</code>为-1的补码表示.显然这是合乎情理的</p>
<p>同样的两个数如果是无符号数则计算结果为<code>0xFF=255</code>这两个正数相减越减越多显然不合理,因此<code>CF=1</code>标志有进位溢出</p>
<h4 id="of">OF</h4>
<p>溢出标志</p>
<p>对有符号整数(即补码)运算有效,比如</p>
<p>两个八位二进制数正数<code>01000000(B)=0x40(H)=64</code>相加,</p>
<p><code>0x40+0x40=0x80(H)=10000000(B)=</code>怎么就成了一个负数<code>-128</code>?</p>
<p>这显然不符合情理,此时<code>OF=1</code>标志有符号数溢出</p>
<p>又或者:</p>
<p>两个八位二进制负数<code>10000000=0x80=-128</code>相加</p>
<p><code>0x80+0x80=0x100=0x00=0</code>怎么就成了0?</p>
<p>这也是不符合情理的,此时<code>OF=1</code></p>
<blockquote>
<p>怎样检验有符号数加减是否有溢出?</p>
<p>计组上我们学过双标志位法,计算结果的两个符号位如果不同则说明有溢出</p>
</blockquote>
<p><code>OF</code>标志对于无符号整数运算无效</p>
<h4 id="zf">ZF</h4>
<p>零标志</p>
<p>如果运算结果为0则<code>ZF=1</code></p>
<h4 id="sf">SF</h4>
<p>符号标志</p>
<p>如果运算结果为负数则<code>SF=1</code></p>
<h3 id="可以修改标志位的指令">可以修改标志位的指令</h3>
<h4 id="除了leaq外的逻辑运算指令">除了leaq外的逻辑运算指令</h4>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408155420102.png"
alt="image-20220408155420102" />
<figcaption aria-hidden="true">image-20220408155420102</figcaption>
</figure>
<h4 id="比较和测试指令">比较和测试指令</h4>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408155446113.png"
alt="image-20220408155446113" />
<figcaption aria-hidden="true">image-20220408155446113</figcaption>
</figure>
<h4
id="一条指令可能会修改多个标志位具体规则为">一条指令可能会修改多个标志位,具体规则为:</h4>
<blockquote>
<p><strong>MOV NOT JMP</strong>*</p>
<p>does not affect flags</p>
<p>MOV,NOT,JMP指令不会修改标志位</p>
<p><strong>NEG</strong></p>
<p>The CF flag set to 0 if the source operand is 0; otherwise it is set
to 1. The OF, SF, ZF, AF, and PF</p>
<p>flags are set according to the result.</p>
<p>NEG取反指令:如果NEG的操作数是0则CF=1,否则CF=0.</p>
<p>OF,SF,ZF,AF,PF标志根据结果设定</p>
<p><strong>AND OR</strong></p>
<p>The OF and CF flags are cleared; the SF, ZF, and PF flags are set
according to the result. The state</p>
<p>of the AF flag is undefined</p>
<p>AND,OR指令的OF和CF前面已经给出;SF,ZF,PF根据结果而定,AF状态无所谓</p>
<p><strong>DEC INC</strong></p>
<p>The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set
according to the result</p>
<p>DEC,INC自增自减指令的CF位不受影响,其他标志位都视结果而定</p>
<p><strong>ADD ADC SUB SBB</strong></p>
<p>The OF, SF, ZF, AF, PF, and CF flags are set according to the
result.</p>
<p>ADD,ADC,SUB,SBB指令的所有标志位都视结果而定</p>
<p><strong>CMP</strong></p>
<p>Modify status flags in the same manner as the SUB instruction</p>
<p>CMP与SUB指令对于标志位的效果相同</p>
<p>以两个有符号八位2进制数运算为例子</p>
<p><code>0x00-0x01=0x00+0xFF=0xFF</code>,<code>OF=0</code>无溢出</p>
<p><code>0x40+0x40=0x80=10000000=-128</code>,<code>OF=1</code>有溢出</p>
<p>减法也有可能溢出,一个负数减去一个正数时</p>
<p><code>0x80-0x7F=0x80+0x81=0x101=0x01</code>成了一个正数,此时<code>OF=1</code></p>
</blockquote>
<h3 id="比较指令">比较指令</h3>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408154303941.png"
alt="image-20220408154303941" />
<figcaption aria-hidden="true">image-20220408154303941</figcaption>
</figure>
<h4
id="执行比较指令后通过标志位组合判断比较结果">执行比较指令后通过==标志位组合==判断比较结果</h4>
<p><code>cmp s1,s2</code>指令基于<code>S2-S1</code>,意思是首先对<code>S2-S1</code>求值,然后结果放在<code>s2</code>原来的地方</p>
<p>如果为负数则<code>SF=1</code>,否则(非负数)<code>SF=0</code>,</p>
<p>后面的程序只需要访问一下Flag
Register中的<code>SF</code>值就"可以????"知道<code>S2,S1</code>谁大谁小了</p>
<blockquote>
<p>==注意这里"可以"是假的==,</p>
<p>因为如果结果是一个比较大的负数,造成溢出,截断之后成了一个正数,此时<code>SF=0</code>,此时只凭借SF值会造成误判,就比如</p>
<p><code>0x80-0x7F=0x80+0x81=0x101=0x01</code>结果成了一个正数,那么符号标志位<code>SF=0</code>只凭SF值就会认为<code>0x80&gt;=0x7F</code></p>
<p>而<code>0x80=-128&lt;0x7F=127</code></p>
<p>因此只凭借SF标志位是无法判断两个操作数的大小的,==还应当考虑是否有溢出==.</p>
<p>==考虑什么时候会发生溢出?==</p>
<p>两个正数相减显然结果绝对值小于两者中的任何一个,不会溢出</p>
<p>两个负数相减同样</p>
<p>两个正数相加显然可以,比如<code>0x7F+0x01=0x80</code>成了负数</p>
<p>两个负数相加也可以,比如<code>0x80+0x80=0x100=0x00</code>成了0</p>
<p>正数-负数也可以,比如<code>0x7F-0xFF=0x7F+0x01=0x80</code>成了负数</p>
<p>负数-正数也可以,比如<code>0x80-0x7F=0x80+0x81=0x101=0x01</code>成了正数</p>
<p>==现在考虑如何完善判断两个数的大小==</p>
<p>两个数做差有四种情况</p>
<p>1.正-正</p>
<p>2.负-负</p>
<p>3.正-负</p>
<p>4.负-正</p>
<p>前两种情况没有溢出,<code>OF=0</code>,直接看<code>SF</code></p>
<p>后两种可能有溢出,如果没有溢出则看<code>SF</code>,如果有溢出则<code>SF</code>取反</p>
<p>而区分前两种和后两种的方法也很容易观察得出,即两个操作数的符号是否一致</p>
<p>令<code>F=[A-B]</code>,<code>A</code>为被减数,<code>B</code>为减数,<code>[X]</code>表示对<code>X</code>取符号,<code>X≥0</code>则<code>[X]=0</code>,否则<code>[X]=1</code></p>
<p>列出真值表</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408164041343.png"
alt="image-20220408164041343" />
<figcaption aria-hidden="true">image-20220408164041343</figcaption>
</figure>
</blockquote>
<blockquote>
<p>我们想要得到F的值,并且我们已经知道<code>OF</code>和<code>SF</code>的值,而大小判断与A,B无关,只与Flag
Register中的标志位组合有关,那么问题转化为</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408164147132.png"
alt="image-20220408164147132" />
<figcaption aria-hidden="true">image-20220408164147132</figcaption>
</figure>
<p>从真值表上我们可以观察得出,当OF=0时,F和SF是一致的,当OF=1时,F和SF是相反的</p>
<p>那么怎么用一条表达式写出F与OF,SF的关系呢?</p>
<p>根据F=1的项可以立刻得到</p>
<p><span class="math inline">\(F=\overline {OF}SF+OF\overline
{SF}=OF\oplus SF\)</span></p>
<p>到此可以总结如何判断两个有符号数的大小了</p>
<p>如果<span class="math inline">\(OF\oplus
SF\)</span>异或值为1则前小后大,否则前大后小</p>
</blockquote>
<p><code>test S1,S2</code>指令基于<code>S1&amp;S2</code>,意思是首先对<code>S1&amp;S2</code>求值,按位与只有两个操作数一模一样才会是真,否则为假.如果为假即0,则<code>ZF=1</code>,否则<code>ZF=0</code>,后面的程序只需要访问一下Flag
Register中的<code>ZF</code>值就可以知道<code>S2,S1</code>是否相同了</p>
<h3 id="访问条件码的方式">访问条件码的方式</h3>
<p>在刚刚进行完一次逻辑运算之后,此时Flag
Register的各个标志位已经设置完毕,下面就要根据其中一个或者几个标志位的组合进行决策,选择执行或者不执行一些命令</p>
<blockquote>
<p>1)可以根据条件码的某种组合, 将一个字节设置为0或者1</p>
<p>2)可以条件跳转到程序的某个其他的部分</p>
<p>3)可以有条件地传送数据</p>
</blockquote>
<h4
id="根据flagregister的情况将一个字节设置为0或者1">1.根据FlagRegister的情况将一个字节设置为0或者1</h4>
<p>SET指令</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408202821368.png"
alt="image-20220408202821368" />
<figcaption aria-hidden="true">image-20220408202821368</figcaption>
</figure>
<p>这种指令怎么发挥作用呢?</p>
<p>以<code>sete</code>为例子,</p>
<p>假设刚刚进行的运算是<code>a-a=0</code>,此时<code>ZF=1</code>表示刚才的计算结果为<code>0</code>,</p>
<p>此时使用<code>sete 目标寄存器</code>,满足设置条件(相等/零),于是向目标寄存器存放<code>ZF</code>值即<code>1</code></p>
<p><strong>练习3.13</strong></p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408204021860.png"
alt="image-20220408204021860" />
<figcaption aria-hidden="true">image-20220408204021860</figcaption>
</figure>
<blockquote>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408204354747.png"
alt="image-20220408204354747" />
<figcaption aria-hidden="true">image-20220408204354747</figcaption>
</figure>
</blockquote>
<p>A项第一行使用了cmpl比较双字命令,说明两个操作数都是双字(int,unsigned),第二行使用setl有符号小于运算,因此操作数只能是int类型</p>
<p>B项第一行使用cmpw比较字命令,说明两个操作数都是字(short,unsigned
short),第二行使用setge有符号大于等于,因此操作数只能是short</p>
<p>C项第一行使用了cmpb比较字节命令,说明两个操作数都是字节(char,unsigned
char),第二行使用setbe无符号小于等于,因此操作数只能是unsigned char</p>
<p>D项第一行使用了cmpq比较四字命令,说明两个操作数都是四字(long,unsigned
long),第二行
使用setne不等/非零,因此操作数无法确定有无符号,long或者unsigned
long均可</p>
<h4 id="条件跳转">2.条件跳转</h4>
<h5 id="条件跳转表">条件跳转表</h5>
<p>该表在后来会经常用到</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408155109547.png"
alt="image-20220408155109547" />
<figcaption aria-hidden="true">image-20220408155109547</figcaption>
</figure>
<h5 id="条件跳转指令实现if-else语句">条件跳转指令实现if-else语句</h5>
<p>c源代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y)</span>&#123;</span><br><span class="line">        <span class="type">long</span> result;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">                result=y-x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                result=x-y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定参数x,y如果x&lt;y,则返回y-x,否则返回x-y,即返回两个数的差的绝对值</p>
<p>汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">absdiff_se:</span><br><span class="line">.LFB0:</span><br><span class="line">        movq    %rsi, %rax</span><br><span class="line">        cmpq    %rsi, %rdi</span><br><span class="line">        jge     .L2</span><br><span class="line">        subq    %rdi, %rax</span><br><span class="line">        ret</span><br><span class="line">.L2:</span><br><span class="line">        subq    %rsi, %rdi</span><br><span class="line">        movq    %rdi, %rax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>分析其汇编语言都干了什么</p>
<p>首先两个参数的位置</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408154047128.png"
alt="image-20220408154047128" />
<figcaption aria-hidden="true">image-20220408154047128</figcaption>
</figure>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R[%rdi]=x</span><br><span class="line">R[%rsi]=y</span><br></pre></td></tr></table></figure>
<p><strong>1.<code>movq    %rsi, %rax</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R[%rax]=R[%rsi]=x</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408154223239.png"
alt="image-20220408154223239" />
<figcaption aria-hidden="true">image-20220408154223239</figcaption>
</figure>
<p>将x搬到<code>%rax</code>寄存器中,猜测有可能以后的变化都在x身上进行最后返回<code>%rax</code>寄存器中的值</p>
<p><strong>2.<code>cmpq    %rsi, %rdi</code></strong></p>
<p>注意是==后减前==</p>
<p>做差<code>R[%rdi]-R[%rsi]</code>,(一定注意是后减前)SF和OF标志位根据结果确定</p>
<p><strong>3.<code>jge     .L2</code></strong></p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408155127559.png"
alt="image-20220408155127559" />
<figcaption aria-hidden="true">image-20220408155127559</figcaption>
</figure>
<p>根据刚才我们推导的<code>R[%rdi]-R[%rsi]&lt;0</code>时<span
class="math inline">\(OF\oplus
SF=1\)</span>,那么<code>R[%rdi]-R[%rsi]≥0</code>就应该有<span
class="math inline">\(!(OF\oplus SF)=1\)</span></p>
<p>这里<code>jge=jump if greater</code>即<code>R[%rdi]-R[%rsi]≥0</code>的情况</p>
<p>联系前两句,第三句可以理解为:如果<span
class="math inline">\(R[\%rdi]-R[\%rsi]=y-x≥0\)</span>则跳转到<code>.L2</code></p>
<p>此后程序分叉了,如果3没有满足执行没有跳转则顺序执行<code>subq    %rdi, %rax</code>即<code>R[%rdi]=R[%rax]-R[%rdi]=x-y</code></p>
<p>如果3满足条件并且跳转则跳到.L2执行<code>subq    %rsi, %rdi</code>即<code>R[%rsi]=R[%rdi]-R[%rsi]=y-x</code>一定是非负的</p>
<p>不管是否跳转,3保证了后面的减法一定是大数-小数</p>
<p>汇编语言的程序结构类似于</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408170852710.png"
alt="image-20220408170852710" />
<figcaption aria-hidden="true">image-20220408170852710</figcaption>
</figure>
<p>而c源程序的结构类似于</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220408170946086.png"
alt="image-20220408170946086" />
<figcaption aria-hidden="true">image-20220408170946086</figcaption>
</figure>
<h5 id="条件跳转指令实现循环">条件跳转指令实现循环</h5>
<p>求一个数n的阶乘,c源文件用while和for分别这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact_while</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">                ans*=i;</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fact_for</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">                ans*=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据前面学过的标志位的用法,大体可以推测一下汇编语言可能怎么写</p>
<p>参数<code>int n</code>放在<code>edi</code>寄存器</p>
<p><img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409151147527.png" /></p>
<p>一开始<code>int ans=1;</code>要从一个寄存器里放一个1,由于最后返回的也是ans,因此可以直接用<code>eax</code>(int32位,需要双字寄存器eax,不用四字寄存器rax)寄存器方便返回</p>
<p>然后循环临时变量i也需要一个寄存器存储其值,用<code>edx</code></p>
<p>循环判断就是i和n的大小判断<code>cmp %edx,%edi</code>,这个式子基于<code>R[%edi]-R[%edx]=n-i</code></p>
<p>当i&lt;=n时,cmp指令执行完毕之后<code>SF=0</code>恒成立,表示cmp运算结果非负</p>
<p>然后进入循环体<code>ans*=i;</code>,其中<code>R[%eax]=ans,R[%edx]=i</code>,翻译成汇编语言,</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409152257759.png"
alt="image-20220409152257759" />
<figcaption aria-hidden="true">image-20220409152257759</figcaption>
</figure>
<p><code>imul %eax,%edx</code>计算<code>R[%eax]*R[%edx]</code>然后将结果存放到<code>%eax</code></p>
<p>循环体执行完毕,下面应该循环变量i自增</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409152802338.png"
alt="image-20220409152802338" />
<figcaption aria-hidden="true">image-20220409152802338</figcaption>
</figure>
<p><code>inc %edx</code></p>
<p>下面要回头执行下一次循环,此处应当使用无条件跳转命令,跳到循环判断语句</p>
<p>考虑当循环判断语句不满足时,应当跳转到何处?</p>
<p>使用条件跳转到循环下面的语句</p>
<p><strong>总的来说,推测的汇编逻辑是这样的:</strong></p>
<p>1.安置好形参n,ans,临时变量i在寄存器中的位置</p>
<p>2.循环判断</p>
<p>3.根据刚才的循环判断,决定是否条件跳转出循环</p>
<p>如果没有出循环则执行循环体(乘法),然后自增临时变量i,然后无条件跳转到2</p>
<p>如果跳出了循环则继续执行后面的语句,循环不再考虑</p>
</blockquote>
<p>下面实验观察汇编器是如何做的</p>
<p>编译成.o文件之后用objdump反汇编得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;fact_while&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64</span><br><span class="line">   4:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">   9:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">   e:   39 f8                   cmp    %edi,%eax</span><br><span class="line">  10:   7f 08                   jg     1a &lt;fact_while+0x1a&gt;</span><br><span class="line">  12:   0f af d0                imul   %eax,%edx</span><br><span class="line">  15:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  18:   eb f4                   jmp    e &lt;fact_while+0xe&gt;</span><br><span class="line">  1a:   89 d0                   mov    %edx,%eax</span><br><span class="line">  1c:   c3                      retq</span><br><span class="line"></span><br><span class="line">000000000000001d &lt;fact_for&gt;:</span><br><span class="line">  1d:   f3 0f 1e fa             endbr64</span><br><span class="line">  21:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  26:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  2b:   39 f8                   cmp    %edi,%eax</span><br><span class="line">  2d:   7f 08                   jg     37 &lt;fact_for+0x1a&gt;</span><br><span class="line">  2f:   0f af d0                imul   %eax,%edx</span><br><span class="line">  32:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  35:   eb f4                   jmp    2b &lt;fact_for+0xe&gt;</span><br><span class="line">  37:   89 d0                   mov    %edx,%eax</span><br><span class="line">  39:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>这样两种循环的写法在机器层面是一模一样的.现在研究其汇编语言的逻辑,以fact_while的汇编语言为例分析其汇编语言的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;fact_while&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64</span><br><span class="line">   4:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">   9:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">   e:   39 f8                   cmp    %edi,%eax</span><br><span class="line">  10:   7f 08                   jg     1a &lt;fact_while+0x1a&gt;</span><br><span class="line">  12:   0f af d0                imul   %eax,%edx</span><br><span class="line">  15:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  18:   eb f4                   jmp    e &lt;fact_while+0xe&gt;</span><br><span class="line">  1a:   89 d0                   mov    %edx,%eax</span><br><span class="line">  1c:   c3                      retq</span><br></pre></td></tr></table></figure>
<p><strong>1.<code>mov    $0x1,%eax</code></strong></p>
<p><code>R[%eax]=0x1</code></p>
<p>这里我们可能会这样分析:eax寄存器是返回值的一部分,因此可以推断,这一句对应c源代码中的<code>int ans=1;</code></p>
<p>但是实际上这里对应的是<code>int i=1</code></p>
<p>==这一点可以从下文中分析得出==</p>
<p><strong>2.<code>mov    $0x1,%edx</code></strong></p>
<p><code>R[%edx]=0x1</code>,对应的是<code>int ans=1</code></p>
<p><strong>3.<code>cmp    %edi,%eax</code></strong></p>
<p>这里就可以看出1和2中,或者说<code>%edx,%eax</code>中到底谁放了ans,谁放了i</p>
<p>比较指令,基于<code>R[%eax]-R[%edi]</code>,如果与c源程序<code>while(i&lt;=n)</code>对应的话</p>
<p><code>R[%edi]=n</code>是可以肯定的,因为第一个参数放在<code>edi</code>中</p>
<p>那么<code>R[%eax]=i</code>随之确定了</p>
<p>(感觉可以把i和ans的寄存器换一换,这样返回的时候可以直接返回rax,其中正好存放ans,但是当前不知道为啥,编译器没有这样做,而是在最后将edx拷贝到eax)</p>
<p><strong>4.<code>jg     1a &lt;fact_while+0x1a&gt;</code></strong></p>
<p><code>jg:jump if greater</code>,</p>
<p><img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409154729279.png" /></p>
<p>如果<code>!(i&lt;=n)即i&gt;n</code>,则<code>cmp %edi,%edx=R[%edx]-R[%edi]=i-n&gt;0</code>,<code>ZF=0</code>,并且显然这里没有溢出和进位,即满足<code>~(SF^OF)&amp;~SF</code>,jg跳转条件成立,发生条抓</p>
<p>这里和<code>while(i&lt;=n)</code>成立的条件是相同的,都是在进入循环之前首先进行条件判断</p>
<p>注意跳转位置:<code>1a &lt;fact_while+0x1a&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:   eb f4                   jmp    e &lt;fact_while+0xe&gt;</span><br><span class="line">1a:   89 d0                   mov    %edx,%eax</span><br></pre></td></tr></table></figure>
<p><code>1a</code>位置恰好为无条件跳转的下一句,表明出了循环</p>
<p><strong>5.<code>imul   %eax,%edx</code></strong></p>
<p>==注意后者为目的==</p>
<p><code>R[%edx]=R[%eax]*R[%edx]</code></p>
<p>对应循环体<code>ans*=i</code></p>
<p><strong>6.<code>add    $0x1,%eax</code></strong></p>
<p><code>R[%eax]=R[%eax]+0x1</code></p>
<p>对应临时变量i自增</p>
<p><strong>7.<code>jmp    e &lt;fact_while+0xe&gt;</code></strong></p>
<p>无条件跳转,跳转位置是fact_while开始向后偏移0xe字节</p>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409155811948.png"
alt="image-20220409155811948" />
<figcaption aria-hidden="true">image-20220409155811948</figcaption>
</figure>
<p>实际跳转到判断指令cmp,意思是重新进行循环</p>
<p><strong>8.<code>mov    %edx,%eax</code></strong></p>
<p>如果程序执行到此句,它上一句又是无条件跳转,说明程序是从更早的条件跳转过来的,对应<code>jg     1a &lt;fact_while+0x1a&gt;</code></p>
<p>这一句的逻辑是把<code>edx</code>寄存器中的东西拷贝给<code>eax</code>一份</p>
<p>edx我们分析过存放的是ans</p>
<p>eax我们分析过存放的是i</p>
<p>然而函数希望返回ans,并且返回值是以eax寄存器为准</p>
<p>因此这里需要把ans搬到eax中</p>
<p><strong>9.<code>retq</code></strong></p>
<p>函数返回</p>
<h4 id="条件传送数据">3.条件传送数据</h4>
<figure>
<img
src="http://raw.githubusercontent.com/DeutschBall/test/master/image-20220409163206775.png"
alt="image-20220409163206775" />
<figcaption aria-hidden="true">image-20220409163206775</figcaption>
</figure>
<p>条件传送数据指令,意思就是当满足某些条件时,才会将数据从哪里拷贝到哪里,还是比较容易理解的</p>
<h2 id="跳转指令">跳转指令</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220410230358338.png"
alt="image-20220410230358338" />
<figcaption aria-hidden="true">image-20220410230358338</figcaption>
</figure>
<h3 id="pc相对寻址跳转">PC相对寻址跳转</h3>
<p>首先分析CSAPP给出的例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220410230546880.png"
alt="image-20220410230546880" />
<figcaption aria-hidden="true">image-20220410230546880</figcaption>
</figure>
<p>1.<code>movq %rdi,%rdx</code></p>
<p><code>R[%rdx]=R[%rdi]=x</code>将传入的参数放进<code>rax</code>寄存器</p>
<p>2.<code>jmp  .L2</code></p>
<p>无条件跳转到<code>.L2</code></p>
<p>.L2:</p>
<p>首先<code>testq %rax,%rax</code>作用是置符号标志,方便判断<code>R[%rax]</code>是负数还是非负数</p>
<p>然后<code>jg .L3</code> ,jump if greater
即如果<code>R[%rax]&gt;0</code>则跳转.L3</p>
<p>.L3:</p>
<p><code>sarq %rax</code>,寄存器<code>%rax</code>中的值右移一位,即除以二下取整</p>
<p>显然当<code>R[%rax]=0</code>时.L2中的jg不再满足条件,执行第八行
的返回语句</p>
<p>因此可以推断,源c程序是这样写的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对.o文件使用objdump反汇编得到</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220410231054590.png"
alt="image-20220410231054590" />
<figcaption aria-hidden="true">image-20220410231054590</figcaption>
</figure>
<p>第一行和刚才相同</p>
<p>第二行<code>jmp 8</code>这里8怎么来的?左侧的机器码为<code>eb 03</code>,即实际操作数是0x03,然后程序进行到loop+0x3位置即该指令时,首先要做的就是程序计数器移动到下一条指令的位置,即移动loop+0x03这条指令的长度2,此时PC=5,然后jmp
8的8就是PC+0x03=5+3=8,这样得到的</p>
<p><strong>习题3.15</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220410231355967.png"
alt="image-20220410231355967" />
<figcaption aria-hidden="true">image-20220410231355967</figcaption>
</figure>
<p>A.当执行4003fa条指令时,PC=4003fc,然后<code>74 02</code>表明要跳转的位置是<code>PC+0x02=0x4003fc+0x02=0x4003fe</code>,即<code>je 0x4003fe</code></p>
<p>B.当执行40042f条指令时,PC=400431,然后<code>74 f4</code>表明要跳转的位置时<code>PC-0x0C=0x400431-0x0C=0x400425</code>,即<code>je 0x400425</code></p>
<p>C.执行前一条指令的时候,程序计数器指示下一行的指令位置,即为PC,<code>0x400547=PC+0x02</code>得到<code>PC=0x400545</code>,则第一行的指令地址为<code>0x400545-2=0x400543</code></p>
<p>D.执行4005e8条指令时,PC=4005ed,字节按照从最低位到最高位的顺序列出为<code>0xff ff ff 73=-141=-0x00 00 00 8D</code></p>
<p><code>PC-0x8D=0x4005ed-0x8d=0x400560</code></p>
<p>因此<code>jmpq 0x400560</code></p>
<h3 id="习题3.18">习题3.18</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220410233232652.png"
alt="image-20220410233232652" />
<figcaption aria-hidden="true">image-20220410233232652</figcaption>
</figure>
<p>程序逻辑分析如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">R[%rax]=R[%rdi]+R[%rsi]=x+y</span><br><span class="line">R[%rax]=R[%rax]+R[%rdx]=x+y+z</span><br><span class="line">计算R[%rdi]-(-3)=R[%rdi]+3=x+3,根据结果置符号位SF和溢出位OF</span><br><span class="line">如果刚才的值大于等于0即x+3&gt;=0,x&gt;=-3则跳转到.L2</span><br><span class="line">否则计算R[%rsi]-R[%rdx]=y-z</span><br><span class="line">如果刚才的值大于0即y-z=&gt;0即y&gt;=z则跳转.L3</span><br><span class="line">否则R[%rax]=R[%rdi]=z</span><br><span class="line">R[%rax]=R[%rax]*R[%rdi]=x*z;</span><br><span class="line">return R[%rax]=x*z;</span><br><span class="line"></span><br><span class="line">.L3:</span><br><span class="line">R[%rax]=R[%rsi]=y</span><br><span class="line">R[%rax]=R[%rax]*R[%rdx]=y*z</span><br><span class="line">return R[%rax]=y*z;</span><br><span class="line"></span><br><span class="line">.L2:</span><br><span class="line">计算R[%rdi]-2,g,根据结果置符号位SF和溢出位OF</span><br><span class="line">不考虑溢出,则当SF=1或者ZF=1即刚才的结果小于等于0即R[%rdi]-2&lt;=0即R[%rdi]=x&lt;=2,则跳转.L4</span><br><span class="line">否则R[%rax]=R[%rdi]=x</span><br><span class="line">R[%rax]=R[%rax]*R[%rdx]=x*z</span><br><span class="line"></span><br><span class="line">.L4</span><br><span class="line">return R[%rax]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int func(int x,int y,int z)&#123;</span><br><span class="line">	int temp=x+y+z;</span><br><span class="line">	if(x&gt;=-3)&#123;</span><br><span class="line">		if(x&lt;=2)&#123;</span><br><span class="line">			return temp;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return x*z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(y&gt;=z)&#123;</span><br><span class="line">		return y*z;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		return x*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这样写会有4条return语句,答案只有一条return语句,在完成所有条件判断之后返回val</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220411082058654.png"
alt="image-20220411082058654" />
<figcaption aria-hidden="true">image-20220411082058654</figcaption>
</figure>
<p>首先改写成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int func(int x,int y,int z)&#123;</span><br><span class="line">	int temp=x+y+z;</span><br><span class="line">	if(x&gt;=-3)&#123;</span><br><span class="line">		if(x&lt;=2)&#123;</span><br><span class="line">			//啥也不干</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			temp=x*z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(y&gt;=z)&#123;</span><br><span class="line">		temp= y*z;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		temp= x*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后<code>x&gt;=-3,x&lt;=2</code>下面是没有东西的,考虑不写这一条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(x&gt;=-3)&#123;</span><br><span class="line">	if(x&gt;2)temp=x*z;</span><br><span class="line">&#125;</span><br><span class="line">else if(y&gt;=z)&#123;</span><br><span class="line">	temp=y*z;</span><br><span class="line">&#125;</span><br><span class="line">else temp=x*y;</span><br><span class="line">return temp;</span><br></pre></td></tr></table></figure>
<p>这样写还是与给定的格式不一样</p>
<p>第一个if下面应该有一个if,有一个else,最后不应该有else</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(x&lt;-3)&#123;</span><br><span class="line">	if(y&gt;=z)temp=y*z;</span><br><span class="line">	else temp=x*y;</span><br><span class="line">&#125;</span><br><span class="line">else if(x&gt;2)temp=x*z;</span><br><span class="line">return temp;</span><br></pre></td></tr></table></figure>
<p>此时就和给定的格式相同了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220411082631746.png"
alt="image-20220411082631746" />
<figcaption aria-hidden="true">image-20220411082631746</figcaption>
</figure>
<p>testq %rsi之后各标志位的情况</p>
<table>
<thead>
<tr>
<th><code>R[%rsi]</code></th>
<th><code>testq %rsi=R[%rsi]+R[%rsi]</code></th>
<th>SF</th>
<th>ZF</th>
<th>OF</th>
<th>CF</th>
</tr>
</thead>
<tbody>
<tr>
<td>正数</td>
<td>无溢出</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>无溢出</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>负数</td>
<td>无溢出</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>正数</td>
<td>溢出</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>负数</td>
<td>溢出</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p>用testq如何判断一个数是正数还是负数?</p>
<p>正数时<code>SF^OF=0andZF=0</code></p>
<p>负数时<code>SF^OF=1</code></p>
<p>0时<code>ZF=1</code></p>
<p>非负数<code>SF^OF=0</code></p>
<p>那么配合<code>jge</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220411085309367.png"
alt="image-20220411085309367" />
<figcaption aria-hidden="true">image-20220411085309367</figcaption>
</figure>
<p>跳转成立条件即<span class="math inline">\(!(SF\oplus
OF)=1\)</span>即<span class="math inline">\(SF\oplus OF =0\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220411085754492.png"
alt="image-20220411085754492" />
<figcaption aria-hidden="true">image-20220411085754492</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">long loop_while2(long a,long b)&#123;</span><br><span class="line">	if(b&lt;=0)&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		int temp=b;</span><br><span class="line">		while(b&gt;0)&#123;</span><br><span class="line">			temp*=a;</span><br><span class="line">			b-=a;</span><br><span class="line">		&#125;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220411090237810.png"
alt="image-20220411090237810" />
<figcaption aria-hidden="true">image-20220411090237810</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long loop_while2(long a,long b)&#123;</span><br><span class="line">	long result=b;</span><br><span class="line">	while(b&gt;0)&#123;</span><br><span class="line">		result=result*a;</span><br><span class="line">		b=b-a;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归过程">递归过程</h2>
<p>需要了解一下过程,调用约定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220420205909645.png"
alt="image-20220420205909645" />
<figcaption aria-hidden="true">image-20220420205909645</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220420205922083.png"
alt="image-20220420205922083" />
<figcaption aria-hidden="true">image-20220420205922083</figcaption>
</figure>
<p>汇编第6行如果跳转实现的话(<code>rdi</code>中存放的<code>x=0</code>)则到11行将被调用者保存的rbx还原,之前又把<code>eax</code>置0,因此返回0,相当于啥也没干</p>
<p>对应<code>rfun</code>函数中的条件判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x==0)return 0;</span><br></pre></td></tr></table></figure>
<p>c程序下面的递归过程对应汇编中不满足条件跳转的语句(7到12行)</p>
<p>第7行将<code>rdi</code>中存放的x右移两位</p>
<p>第8行就调用<code>rfun</code>了,<code>rdi</code>是调用者保存的,用来给<code>rfun</code>传递参数,</p>
<p><code>rfun(x)</code>将会调用<code>rfun(x&gt;&gt;2)</code></p>
<p>这样一直递归调用到最内层的函数时<code>x==0</code>不满足跳转条件了,返回<code>0,rbx</code>值不变,还是调用者给的值,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">假设上级函数rbx=y</span><br><span class="line">rfun(x)<span class="comment">//x放到rdi里</span></span><br><span class="line">	把rbx中的y存一下</span><br><span class="line">	x放到rbx里</span><br><span class="line">	eax归零</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">		把刚才放起来y重新放回rbx里</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rdi中的x右移两位成为x1</span><br><span class="line">	<span class="title function_">rfun</span><span class="params">(x1)</span>&#123;&#125;</span><br><span class="line">		...</span><br><span class="line">		rdi中的x1右移两位成为x2</span><br><span class="line">		<span class="title function_">rfun</span><span class="params">(x2)</span>&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		rbx中的x1加到rax上</span><br><span class="line">		返回rax</span><br><span class="line">	&#125;</span><br><span class="line">	rbx中的x加到rax上</span><br><span class="line">	返回rax</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>rax中累计的是历次x的值</p>
<p>rbx保存"本次"x 的值</p>
<blockquote>
<p><code>rdi</code>也是本次x的值啊?为什么还要<code>rbx</code>保存一下?</p>
<p>在将本次的x累加到<code>rax</code>中之前<code>rdi</code>中的x已经右移两位了,应该用<code>rbx</code>记住x之后再右移</p>
<p><code>rbx</code>的作用就是记住本次本次本次的x值,</p>
<p>可以这样理解:</p>
<p>如果不用<code>rbx</code>,可以开一个数组,</p>
<p>比如第一层函数的参数x放到数组第一位</p>
<p>第二层函数的参数x1放到数组的第二位</p>
<p>...</p>
<p>然后在返回的时候只需要将下一层函数的返回值与本层在数组中存放的参数值乘起来然后返回</p>
<p>但是实际上寄存器很有限,被调用者寄存器只有六个,如果递归层数很多了则这种数组是不现实的</p>
<p>只用一个的话就是滚动数组的思想了</p>
<p>在返回之前,由于要返回的值已经用完了,rbx的暂时存放使命完成,可以还给上一层函数了,继续承担上一层函数的暂时存放使命</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/23/%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/23/%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">CSAPP-chapter8 异常与进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-23 18:55:00 / Modified: 19:44:56" itemprop="dateCreated datePublished" datetime="2022-05-23T18:55:00+08:00">2022-05-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="csapp-chapter8">CSAPP-chapter8</h1>
<p>感觉大一上学期c语言还有下学期基于c语言的基础课程设计学得好失败.</p>
<p>当时一个位图放缩,我既不懂位图格式,也不懂二进制文件,还不熟悉glibc函数.</p>
<p>本学期操作系统,更是云里雾里,对虚拟内存,进程等概念从未听过,却上来就要讲缺页置换算法,调度算法等等各种算法</p>
<p>对于CSAPP这本书,只能说相见恨晚,应当替代大一下的基础课程设计,作为计组和操作系统先修课.</p>
<p>欠的债在大二下才还上,可以说亡羊补牢?</p>
<h2 id="异常">异常</h2>
<h3 id="控制流">控制流</h3>
<p>一个没有跳转,正常执行的程序,其执行过程中程序计数器PC总是连续变化的,</p>
<p>假设指令序列为 <span class="math display">\[
I_1,I_2....,I_n
\]</span></p>
<p>指令对应的地址为 <span class="math display">\[
A_1,A_2,...,A_n
\]</span> 由于x86上的指令采用变长编码方式,因此<span
class="math inline">\(A_1,A_2,...,A_n\)</span>有可能不是等差数列,但是可以啃腚的是他们连续,</p>
<p>程序计数器PC的值构成的序列被称为控制流,如果程序一直顺序进行没有调用跳转返回,并且没有发生异常,则PC的值一直连续,这样的控制流称为"平滑的"</p>
<p>当程序中有跳转,函数调用,函数返回,或者异常时,控制流不再平滑,此时控制流被称为"异常控制流"(ECF)
异常控制流包括跳转,调用,返回,异常等</p>
<h3 id="异常的定义">异常的定义</h3>
<p>先说一些必要的废话</p>
<p>定义:异常就是控制流中的突变,按照这个定义,跳转,调用,返回,异常处理程序都是</p>
<p>异常是异常控制流(ECF)的一种,需要硬件和操作系统协同实现.</p>
<h3 id="异常处理的过程">异常处理的过程</h3>
<h4 id="序幕异常的触发">序幕:异常的触发</h4>
<p>异常是<strong>如何触发</strong>的呢?</p>
<p>处理器中的<strong>重大</strong>状态变化,状态可以是某些寄存器中的某些位等,被处理器检测到(检测电平的变化对于处理器来说易如反掌,可以实现)</p>
<blockquote>
<p>就好像一个人走着走着感觉低血糖了
,这人自然就感觉到了,然后对低血糖的对策应该吃点糖.这吃点糖就是异常处理程序</p>
<p>吃完糖然后缓过来了继续走路</p>
<p>这就是控制还给之前正在执行的指令</p>
<p>如果低血糖非常厉害,人直接寄了,相当于发生了终止,先前的进程不再进行</p>
</blockquote>
<h4 id="开端异常的察觉与定性">开端:异常的察觉与定性</h4>
<p>处理器根据状态位的变化判断,发生甚么事了</p>
<blockquote>
<p>就好像这个走路的人走着走着感觉头晕,无力,快要饿死,这三种状态一组合,人就知道发生了低血糖</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518201336935.png"
alt="image-20220518201336935" />
<figcaption aria-hidden="true">image-20220518201336935</figcaption>
</figure>
<p>每种事件在制作处理器时都已经交给处理器一个编号,发生某种事件处理器就可以知道对应哪个编号</p>
<blockquote>
<p>就好比从小就教给这个人,</p>
<p>高血糖编号0,</p>
<p>低血糖编号1,</p>
<p>尿急编号2,...</p>
<p>然后有一天这个人犯了低血糖,他就知道自己犯了编号为1的毛病</p>
</blockquote>
<blockquote>
<p>但是这个人知道了自己犯了1号病有啥意义呢?实践生活中也确实没有这样整,应该是怪没有意义的</p>
<p>那么给<strong>事件编号的意义</strong>又是啥?</p>
<p>这种编号感觉类似协议,处理器调用异常处理程序的时候只需要根据特定的编号去调用特定的处理程序,而处理程序的代码不是处理器管,是操作系统维护的异常表管的,那么处理器用什么信息去查表调用相关的异常处理程序呢?</p>
<p>如果现实中也是这样,人知道了自己犯了1号毛病,去了门诊直接说"我犯了1号病",大夫就知道应该开葡萄糖的药,不需要病人<strong>费一大堆话描述</strong>"我犯了
头晕无力饿 的病"</p>
<p>同样,处理器在查表之前将自己的各种状态量化成一个魔数,把最困难的事自己解决了,然后用这个魔数去查表岂不是轻轻松松</p>
<p>但是现实生活中并没有给低血糖这种病编号,看起来这种方法很简单快捷,为什么不用?</p>
<p>一是人生活中要记的事情已经太多,病的编号记不住,二是病人觉得是1号病但是大夫可能不这样认为,有可能是更大的毛病</p>
<p>但是对机器来说,没有这么多的可能,根据状态位的变化,已经可以清楚地确定发生了甚么,并且每种毛病的编号都已经被写入硬件,永远牢记,因此可以使用这种方式</p>
</blockquote>
<h4 id="发展根据事件号查异常表">发展:根据事件号查异常表</h4>
<p>处理器确定事件及事件编号之后,要根据事件编号采取相应的异常处理程序,这时需要去查异常表</p>
<blockquote>
<p>异常表是由操作系统启动时分配和初始化的,存放在主存中,事件编号作为下标,异常处理程序的地址作为表项</p>
</blockquote>
<p>用事件编号作为下标去查异常表,获得的表项是异常处理程序的地址,然后控制交给该异常处理程序</p>
<blockquote>
<p>整个查表的过程与页表的工作方式很像</p>
<p>单级页表的下标是虚拟页号VPN,页表项是物理页号</p>
</blockquote>
<blockquote>
<p>处理器怎么知道表在哪里的呢?</p>
<p>异常表的起始地址会专门被一个寄存器--异常表基址寄存器(exception table
base regsiter)保存,这个寄存器在CPU里</p>
<p>查表的时候</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518203658495.png"
alt="image-20220518203658495" />
<figcaption aria-hidden="true">image-20220518203658495</figcaption>
</figure>
<p>etbr寄存器中存放基址,异常号(可能存放在某个寄存器中)作为偏移量,两个加起来去访问数组项</p>
</blockquote>
<h4 id="高潮异常处理">高潮:异常处理</h4>
<p>刚才查完异常表之后处理器已经获得了异常处理程序的首地址,处理器只需要把PC值改为该异常处理程序的首地址</p>
<p>看到这里不禁疑惑,如果异常不是很严重可以被处理,处理完了怎么回到刚才的程序呢?谁来保存刚才进程的执行现场呢?</p>
<p>CSAPP用异常处理和函数调用的对比解决了这个疑惑</p>
<p>执行异常处理程序之前,处理器会将<strong>返回时的指令地址</strong>,以及其他一些状态(通用寄存器,堆栈指针,程序状态字等等)统统滴压入<strong>内核栈</strong>,注意不是用户栈</p>
<blockquote>
<p>这里从异常处理程序返回时的指令地址只有两种,要么是触发异常的指令地址,要么是下一条指令,</p>
<p>具体是那一条要根据事件类型确定,即根据事件编号确定.</p>
<p>这是后话</p>
</blockquote>
<blockquote>
<p>为什么要压入内核栈?我的猜测是</p>
<p>异常处理程序要运行在内核状态,访问内核栈方便</p>
<p>为什么异常处理程序要运行在内核状态?我的猜测是</p>
<p>异常处理程序需要请求一些内核的资源,比如缺页异常处理程序会进行磁盘到内存换页的操作,设计了IO操作.而这些在用户状态没有权限做到</p>
</blockquote>
<p>上述进程信息都压内核栈保存之后,PC置为异常处理程序的地址,控制交给异常处理程序(或者说异常处理程序占用处理器)</p>
<h4 id="结局异常处理完了返回">结局:异常处理完了返回</h4>
<blockquote>
<p>首先考虑一个人大街上走着低血糖了可能怎么处理</p>
<p>一是轻微的,吃块糖缓过来接着走</p>
<p>二是稍微严重,回家歇着了,改天再出来</p>
<p>三是非常严重,人暴毙了(虽然几率不大),这辈子不可能再走路了,也省了处理的麻烦</p>
</blockquote>
<p>根据引发异常的事件类型,异常处理完后的返回也可以分成三种</p>
<p>1.返回给当前指令(触发异常的指令),重新进行,比如缺页异常</p>
<p>2.返回给当前指令的下一条指令</p>
<blockquote>
<p>下一条指不发生异常时下一条应该执行的指令</p>
</blockquote>
<p>3.发生异常的程序被中断,不再执行</p>
<h2 id="异常的类别">异常的类别</h2>
<p>异常就四种,中断,陷阱,故障,终止</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518210426662.png"
alt="image-20220518210426662" />
<figcaption aria-hidden="true">image-20220518210426662</figcaption>
</figure>
<p>其中只有属于异步异常的中断发生在CPU之外,只能由IO设备产生,比如按下键盘,点击鼠标,打印到屏幕,等等各种事件</p>
<p>陷阱是有意为之的,目的是从是处理器从用户态陷入内核态(通过修改某种标志位),作用是拥有使用任意资源的权限,比如syscall指令</p>
<p>故障和终止都是不希望发生的,区别是故障算是比较轻微的异常,比如缺页,通过牺牲物理页换入缺页就可以解决</p>
<p>但是终止就是比较严重的异常,程序无法继续运行了,比如栈缓冲区溢出被金丝雀检测到</p>
<h3 id="中断">中断</h3>
<p>此处的"中断"更确切的是说"外部中断"或者"硬件中断",即IO外设导致的中断,不是程序有意产生的中断</p>
<p>up九曲阑干举例是键盘输入导致的中断</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518211331500.png"
alt="image-20220518211331500" />
<figcaption aria-hidden="true">image-20220518211331500</figcaption>
</figure>
<p>在这个计算机的模型机中,内存总线和IO总线不是一路,但是汇集到IO桥,然后IO桥通过系统总线连接到CPU中的总线接口,总线接口是与CPU内部寄存器相连的</p>
<blockquote>
<p>IO总线上挂着的都是IO外设,比如USB,显示器,键鼠,磁盘等等,计算机就算没有这些东西也可以运行</p>
</blockquote>
<p>按下键盘的时候,键盘控制器会向处理器的中断引脚发送中断信号,并且会把异常号通过IO总线,IO桥,系统总线传递给CPU,</p>
<p>中断信号的目的是提醒CPU应该处理中断了,异常号的作用是告诉CPU是键盘出现异常,而不是鼠标</p>
<p>中断信号和异常号都是CPU判断异常事件需要用到的信息</p>
<p>由于键盘发送信号和CPU处理指令是<strong>异步</strong>的,因此当键盘发送中断信号的时候,CPU有可能还在执行一条命令.CPU必须完成了手头上那一条命令之后,才可以处理中断.</p>
<p>完成手头上的指令后,CPU检测到中断引脚那里发生了电位变化,因此知道发生中断了,然后通过异常号知道是哪个IO设备发生了中断,根据这两个信息CPU就能确定发生了什么事,下面就可以异常处理了</p>
<p>异常处理完之后,应该返回什么地方呢?由于刚才手头上的最后一条指令已经被彻底执行了,自然应该返回下一条指令.</p>
<blockquote>
<p>这就好比</p>
<p>正在写作业,突然有人敲门,为了防止当前正在解决的数学问题思路被打断重来,我先做完这道题,然后去处理访客的问题</p>
<p>到了门口得先问问是谁在敲门,是熟人就开门</p>
<p>然后得端茶倒水儿,把客人招待好,等客人走了把门一关回去接着做下一道题</p>
<p>这里数学题就相当于CPU正在执行的指令,</p>
<p>敲门这个信号就相当于中断引脚上的电位变化,</p>
<p>做完这道题再去开门就相当于CPU执行完当前一条指令然后再去处理中断,</p>
<p>询问访客姓名和敲门合起来,相当于CPU确定事件号,</p>
<p>招待客人的过程相当于执行中断处理程序</p>
<p>客人走了继续做下一道题相当于中断处理完成之后返回下一条指令</p>
</blockquote>
<p>综上,中断处理过程的流程图表示为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518212631468.png"
alt="image-20220518212631468" />
<figcaption aria-hidden="true">image-20220518212631468</figcaption>
</figure>
<p>从数学作业的角度来说,中间招待客人的时候,数学作业没有被处理,但是作业本子也不知道这个做题的是玩电脑去了还是蹲坑去了还是招待客人去了.反正这不重要.重要的是不管中间干了啥,数学作业都是被完整做完的.</p>
<p>因为访客和做作业是异步的,所以招待客人和数学作业玩不玩成一点关系都没有</p>
<p>从正在执行的进程角度看,发生中断被抢占CPU和被其他进程抢占CPU没有区别,进程也没有因为中断被改变什么</p>
<h3 id="陷阱系统调用">陷阱(系统调用)</h3>
<p>陷阱又可以理解为软件<strong>主动</strong>产生的"软中断",是有意为之的</p>
<p><strong>系统调用</strong>,陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，又叫做系统调用。</p>
<blockquote>
<p>在网上搜索的时候,感觉有一种<strong>广义</strong>的"系统调用",表示一整个从用户程序到硬件然后再返回用户程序的过程</p>
<p>感觉还有一种<strong>狭义</strong>的系统调用,就是导致CPU从用户态改变到内核态那关键的一条汇编指令<code>int $0x80</code></p>
</blockquote>
<p><strong>系统级函数</strong>,比如<code>open(),read(),close()</code>等等,涉及IO操作,显然只在用户态是干不成事情的,需要使用内核的资源,需要陷入内核态,因此需要去执行系统调用</p>
<p>我们写的程序怎么陷入内核态呢?在c源代码层面上只需要调用glibc中的系统级函数</p>
<p><strong>汇编语言层面观察系统级函数write的实现</strong></p>
<blockquote>
<p>CSAPP上给出的x86-64linux系统调用号表(感觉这里系统级函数和系统调用的概念有些混淆,应该是广义的系统调用)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518215022569.png"
alt="image-20220518215022569" />
<figcaption aria-hidden="true">image-20220518215022569</figcaption>
</figure>
<p>调用write</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519074321305.png"
alt="image-20220519074321305" />
<figcaption aria-hidden="true">image-20220519074321305</figcaption>
</figure>
<p>系统调用号用rax传递</p>
<p>文件描述符用rdi传递</p>
<p>字符串用rsi传递</p>
<p>字符串长度用rdx传递</p>
<p><strong>syscall即侠义的系统调用</strong></p>
</blockquote>
<h4
id="在用户视角下系统调用过程示意图">在<strong>用户视角下</strong>系统调用过程示意图</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519073514392.png"
alt="image-20220519073514392" />
<figcaption aria-hidden="true">image-20220519073514392</figcaption>
</figure>
<blockquote>
<p>程序员视角意味着"陷阱处理程序"是一个抽象的概念,程序员知道系统要做这么一个陷阱处理,但是具体做了啥程序员不知道,</p>
<p>程序员可以知道的是自己的程序会调用syscall,然后CPU的使用权就不属于自己的程序了,而是属于陷阱处理.程序员还知道的是陷阱处理之后的结果,比如调用write之后将缓冲区<code>char buffer[20];</code>中的字符打印到了屏幕上</p>
</blockquote>
<p><strong>废话:为什么要有陷阱(系统调用)这种异常?</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522191723763.png"
alt="image-20220522191723763" />
<figcaption aria-hidden="true">image-20220522191723763</figcaption>
</figure>
<p><strong>c库函数,系统级函数,系统调用的关系</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522170002447.png"
alt="image-20220522170002447" />
<figcaption aria-hidden="true">image-20220522170002447</figcaption>
</figure>
<p><strong>c库函数</strong></p>
<p>libc和glibc都是Linux下的c函数库</p>
<blockquote>
<p><strong>glibc</strong>是linux下面c标准库的实现，即GNU C
Library。glibc本身是GNU旗下的C标准库，<strong>后来逐渐成为了Linux的标准c库，而Linux下原来的标准c库Linux
libc逐渐不再被维护</strong>。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux
libc，但是<strong>glibc无疑是用得最多的</strong>。glibc在/lib目录下的.so文件为libc.so.6。</p>
</blockquote>
<p>c函数库中的函数非常多,可以按照有没有涉及系统调用进行分类</p>
<blockquote>
<p>涉及系统调用的<code>printf,scanf,malloc,free</code>等,这些函数都是<strong>系统级函数</strong>,这些函数执行系统调用陷入内核</p>
<p>不涉及系统调用的<code>itoa,strstr</code>等</p>
</blockquote>
<p>关于库函数和内核函数的区别,这个问题中文站点搜了好多,全在扯淡,最后参考了
<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31873923/difference-fork-and-sys-fork">stackoverflow</a></p>
<blockquote>
<p>比如内核函数sys_fork就是c库函数fork系统调用入口,即当我们的的代码中使用<code>fork</code>函数的时候,fork函数会去自己调用<code>sys_fork</code>而不是调用<code>sys_write</code></p>
<blockquote>
<p>为啥要这样套娃呢?</p>
<p>因为<code>sys_call</code>是内核函数,依赖于系统</p>
<p>但是<code>fork</code>是c库函数,要求POSIX可移植</p>
<p>这就好似协议分层,<code>fork</code>所在高层只管调用内核提供的一个叫<code>sys_fork</code>函数,内核具体怎么实现这个函数不关心</p>
<p>而内核也不知道上层会有什么,只管根据人的需要涉及<code>sys_fork</code>的参数返回值,功能等等</p>
</blockquote>
<blockquote>
<p>fork函数大体的调用链(踢皮球链)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fork() -&gt; glibc wrapper -&gt; raw syscall invocation -&gt; transition to kernel mode -&gt; syscall lookup -&gt; sys_fork() -&gt; do_fork().</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p><strong>内核函数</strong></p>
<p>kernel函数即内核函数</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.tutorialspoint.com/assembly_programming/assembly_system_calls.htm">Assembly
- System Calls
(tutorialspoint.com)</a>给出了一个x86linux上调用write时,在内核函数层面发生的事情</p>
<p>x86linux内核函数表:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518215333246.png"
alt="image-20220518215333246" />
<figcaption aria-hidden="true">image-20220518215333246</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	edx,4		; message length						;要打印的信息长度用edx传递</span><br><span class="line">mov	ecx,msg		; message to write						;要打印的信息msg用ecx寄存器传递</span><br><span class="line">mov	ebx,1		; file descriptor (stdout)				;文件描述符,魔数1表示标准输出,即显示器</span><br><span class="line">mov	eax,4		; system call number (sys_write)		;eax存放内核函数号,决定调用sys_write函数</span><br><span class="line">int	0x80		; call kernel						   ;陷入内核,根据先前放在eax中的系统调用号决定执行什么命令</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>系统命令和系统调用的关系</strong></p>
<p>系统命令比如<code>ls</code>,<code>ifconfig</code>,<code>mv</code>,<code>cp</code>等等是由一个或者多个c库函数实现的,可能其中会用到系统调用.系统命令和系统调用之间还有一段距离</p>
<p>CSAPP上就有练习题让我们用<code>&lt;stdio.h&gt;</code>等头文件里面c库函数写一个<code>mv</code>命令之类的</p>
<h4 id="操作系统视角下的系统调用过程">操作系统视角下的系统调用过程</h4>
<p>用户进程通过eax寄存器将内核函数号交给<code>system_call</code>函数,这时已经下到kernel模式了</p>
<p><code>system_call</code>函数的作用是,根据内核函数号去查<code>system_call_table</code>表,执行相应的sys_开头的内核函数,</p>
<p>内核函数执行完毕之后执行<code>syscall_exit</code>返回到<code>system_call</code>函数</p>
<p><code>system_call</code>函数执行<code>resume_userspace</code>返回用户空间</p>
<h4 id="系统调用的整个过程">系统调用的整个过程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522212228880.png"
alt="image-20220522212228880" />
<figcaption aria-hidden="true">image-20220522212228880</figcaption>
</figure>
<p>例如<code>getpid</code>函数系统调用的简化过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522210953699.png"
alt="image-20220522210953699" />
<figcaption aria-hidden="true">image-20220522210953699</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getpid()</span><br><span class="line">	int 0x80</span><br><span class="line">		system_call</span><br><span class="line">			sys_getpid()</span><br></pre></td></tr></table></figure>
<h4 id="实验添加系统调用">实验:添加系统调用</h4>
<p>添加一个系统调用不只是向系统调用号表中添加一个表项,要考虑内核中整个系统调用过程</p>
<p>1.根据系统调用类型查系统调用号表获得系统调用号</p>
<p>2.系统调用号查内核函数跳转表找到应该执行的内核函数</p>
<p>3.执行内核函数</p>
<p>各部分的具体作用和位置如下</p>
<h5
id="系统调用号表unistd_32.h">系统调用号表<code>unistd_32.h</code></h5>
<blockquote>
<p>前置知识:c语言宏定义</p>
</blockquote>
<p>在我校的操作系统实验中,使用的操作系统内核版本是<code>linux-2.6.32.60</code></p>
<p>在<code>/usr/src/linux-2.6.32.60/arch/x86/include/asm/unistd_32.h</code>位置</p>
<p>该文件中全是宏定义,形如<code>#define __NR_exit        1</code>,将每一个系统调用号魔数定义为一个有实际意义的字面量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file contains the system call numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit		  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork		  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read		  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write		  4</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_syscalls 337			<span class="comment">//系统调用总个数</span></span></span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>感觉类似于DNS协议</p>
<p>将ip地址号映射到一个方便人类记忆的域名</p>
<p>将一个域名解析到一个ip地址号</p>
</blockquote>
<h5
id="内核函数跳转表syscall_table_32.s">内核函数跳转表<code>syscall_table_32.S</code></h5>
<blockquote>
<blockquote>
<p>前置知识x86汇编语言</p>
</blockquote>
<p>.S:汇编语言源程序;预处理,汇编</p>
<p>也就是说该文件是汇编写的</p>
</blockquote>
<p>内核函数跳转表以系统调用好表中的系统调用号为下标,总个数也是在<code>unistd_32.h</code>中宏定义的<code>#define NR_syscalls 337</code></p>
<p>系统调用号和内核函数跳转表项是一个萝卜一个坑的关系,修改系统调用号就得修改跳转表项,因此现有的不要乱改</p>
<p>如果系统调用号没有对应下标的内核跳转表表项,则默认指向函数调用表中,教材中说是<code>sys_ni_syscall()</code></p>
<p>在我校的操作系统实验课程的安排中,这个内核函数跳转表的位置在<code>/usr/src/linux-2.6.32.60/arch/x86/kernel/syscall_table_32.S</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">	.<span class="type">long</span> sys_restart_syscall	<span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line">	.<span class="type">long</span> sys_exit</span><br><span class="line">	.<span class="type">long</span> ptregs_fork</span><br><span class="line">	.<span class="type">long</span> sys_read</span><br><span class="line">	.<span class="type">long</span> sys_write</span><br><span class="line">	.<span class="type">long</span> sys_open		<span class="comment">/* 5 */</span></span><br><span class="line">	.<span class="type">long</span> sys_close</span><br><span class="line">	.<span class="type">long</span> sys_waitpid</span><br></pre></td></tr></table></figure>
<p>这个跳转表也比较类似CSAPP第三章上介绍的switch跳转表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523075250116.png"
alt="image-20220523075250116" />
<figcaption aria-hidden="true">image-20220523075250116</figcaption>
</figure>
<blockquote>
<p>系统调用号表和内核函数跳转表有一一对应关系</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522215928689.png"
alt="image-20220522215928689" />
<figcaption aria-hidden="true">image-20220522215928689</figcaption>
</figure>
</blockquote>
<h5 id="内核函数声明syscalls.h">内核函数声明<code>syscalls.h</code></h5>
<p>该声明在<code>/usr/src/linux-2.6.32.60/include/linux/syscalls.h</code>中</p>
<p>就是一个头文件,里面都是函数声明,在链接时起到引用的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_time</span><span class="params">(<span class="type">time_t</span> __user *tloc)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_stime</span><span class="params">(<span class="type">time_t</span> __user *tptr)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval __user *tv,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> timezone __user *tz)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_settimeofday</span><span class="params">(<span class="keyword">struct</span> timeval __user *tv,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> timezone __user *tz)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_adjtimex</span><span class="params">(<span class="keyword">struct</span> timex __user *txc_p)</span>;</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_times</span><span class="params">(<span class="keyword">struct</span> tms __user *tbuf)</span>;</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_gettid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_nanosleep</span><span class="params">(<span class="keyword">struct</span> timespec __user *rqtp, <span class="keyword">struct</span> timespec __user *rmtp)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于asmlinkage修饰符:</p>
<blockquote>
<p>需要前置知识,x86汇编语言和调用约定</p>
</blockquote>
<p>类似位置的修饰符我们见过<code>__cdecl</code>,<code>__fastcall</code>,这里<code>asmlinkage</code>也是一种调用约定的修饰符,试想如果不声明该修饰符,则linux上按照System
V AMD64
ABI约定的函数传参方法,前六个参数是通过<code>edi,esi,edx,ecx,r8d,r9d</code>这六个寄存器传递的,返回值是通过eax寄存器传递的.</p>
<p>而对于内核函数</p>
<p><code>asmlinkage</code>是一个宏定义<code>#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))</code>,</p>
<p>其作用是使用<code>eax,ebx,ecx</code>传递参数,<code>eax</code>始终传递系统调用号(内核函数号)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523084202556.png"
alt="eax传递内核函数号" />
<figcaption aria-hidden="true">eax传递内核函数号</figcaption>
</figure>
<p>比如write函数从用户态下到内核态system_call时的调用过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	edx,4		; message length						;要打印的信息长度用edx传递</span><br><span class="line">mov	ecx,msg		; message to write						;要打印的信息msg用ecx寄存器传递</span><br><span class="line">mov	ebx,1		; file descriptor (stdout)				;文件描述符,魔数1表示标准输出,即显示器</span><br><span class="line">mov	eax,4		; system call number (sys_write)		;eax存放内核函数号,决定调用sys_write函数</span><br><span class="line">int	0x80		; call kernel						   ;陷入内核,根据先前放在eax中的系统调用号决定执行什么命令</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="内核函数实现sys.c">内核函数实现<code>sys.c</code></h5>
<p>内核函数的定义实现在<code>/usr/src/linux-2.6.32.60/kernel/sys.c</code>里</p>
<p>该源文件开幕就是版权声明,是龙得卧着,是虎得盘着,我Linus是什么人不用我自己说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  linux/kernel/sys.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 1991, 1992  Linus Torvalds</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>然后include了一大堆头文件,其中就有<code>syscalls.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">.....</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>然后就见鬼了,一个<code>sys_</code>开头的函数实现都没有找到,这样<code>syscalls.h</code>岂不是include了个寂寞</p>
<p>在<code>syscalls.h</code>的宏定义中我们可以找到答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE0(name)	   asmlinkage long sys_##name(void)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE(name) asmlinkage long sys_##name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line"><span class="meta">	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__));		\</span></span><br><span class="line"><span class="meta">	static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">	asmlinkage long SyS##name(__SC_LONG##x(__VA_ARGS__))		\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		__SC_TEST##x(__VA_ARGS__);				\</span></span><br><span class="line"><span class="meta">		return (long) SYSC##name(__SC_CAST##x(__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	SYSCALL_ALIAS(sys##name, SyS##name);				\</span></span><br><span class="line"><span class="meta">	static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即<code>asmlinkage long sys_##name</code>这种格式的函数接口都被统一地宏定义为<code>__SYSCALL_DEFINEx(x, name, ...)</code></p>
<blockquote>
<p>统一定义成<code>SYSCALL_DEFINE0</code>到<code>SYSCALL_DEFINE6</code>这7种宏定义,作用是是实现起来方便</p>
</blockquote>
<p>而<code>sys.c</code>中就有<code>__SYSCALL_DEFINEx(x,name,...)</code>这类函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(setpriority, <span class="type">int</span>, which, <span class="type">int</span>, who, <span class="type">int</span>, niceval)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ugh. To avoid negative return values, &quot;getpriority()&quot; will</span></span><br><span class="line"><span class="comment"> * not return the normal nice-value, but a negated value that</span></span><br><span class="line"><span class="comment"> * has been offset by 20 (ie it returns 40..1 instead of -20..19)</span></span><br><span class="line"><span class="comment"> * to stay compatible.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(getpriority, <span class="type">int</span>, which, <span class="type">int</span>, who)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自定义的内核函数又少又简单,没有必要也遵守这种宏定义,直接在<code>sys.c</code>中按照<code>syscalls.h</code>中的函数声明去实现函数即可.反正宏定义只是起别名,叫绰号和叫原名都不会错</p>
<h5 id="我们需要做的">我们需要做的</h5>
<p>考虑上述各部分的作用,我们需要做的</p>
<p><strong>1.添加系统调用表<code>unistd_32.h</code>项</strong></p>
<p>修改之前:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220522222645579.png"
alt="image-20220522222645579" />
<figcaption aria-hidden="true">image-20220522222645579</figcaption>
</figure>
<p>格式比着葫芦画个瓢,修改之后</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/QQ%E6%88%AA%E5%9B%BE20220522222731.png"
alt="QQ截图20220522222731" />
<figcaption aria-hidden="true">QQ截图20220522222731</figcaption>
</figure>
<p>注意下面<code>#define NR_syscalls 338</code>也得跟着改,</p>
<p>这个值表示的是系统调用的总数,由于系统调用号从0开始编号,因此当我们新增一个337号时,总数有338个</p>
<p><strong>2.添加内核函数跳转表<code>syscall_table_32.S</code>表项</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/QQ%E6%88%AA%E5%9B%BE20220522223100.png"
alt="QQ截图20220522223100" />
<figcaption aria-hidden="true">QQ截图20220522223100</figcaption>
</figure>
<p>只需要在最后一行添加一项,格式比着葫芦画个瓢</p>
<p><strong>3.在<code>syscalls.h</code>中增加一条函数声明</strong></p>
<p>注意以root打开文件才有权限修改</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523073622059.png"
alt="image-20220523073622059" />
<figcaption aria-hidden="true">image-20220523073622059</figcaption>
</figure>
<p><strong>4.在<code>sys.c</code>中增加内核函数的实现</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523074428529.png"
alt="image-20220523074428529" />
<figcaption aria-hidden="true">image-20220523074428529</figcaption>
</figure>
<p>这里最后手残写了一个S一开始没发现,编译就是不通过,在形成<code>sys.o</code>时报错,回来看笔记才发现多一个S</p>
<p><strong>5.编译内核</strong></p>
<blockquote>
<p>前置知识</p>
<p>linux内核</p>
<p>链接</p>
<p>makefile的编写</p>
<p>我几乎都不会</p>
</blockquote>
<p>学校给的实验环境中写好了makefile,好长一个,整个内核的编译,我唧己啃腚写不出来.</p>
<p>并且makefile涉及链接操作,在CSAPP第七章有比较详细的介绍,这是后话了</p>
<p>然后就是makefile的语法,这我目前也不会,这也是后话了</p>
<p>总之就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig <span class="comment">#修改一下内核名称这种无关紧要的东西,其他的不敢改也不会改,在这里我</span></span><br><span class="line">make	<span class="comment">#执行makefile文件,开始漫长的编译过程</span></span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>如果上述四步都能完整执行,真的烧高香了</p>
<p>编译完了会形成一个vmlinux.o目标模块,链接后会形成vmlinux这么一个32位ELF可执行文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523115115233.png"
alt="image-20220523115115233" />
<figcaption aria-hidden="true">image-20220523115115233</figcaption>
</figure>
<p>后面两步完了之后会在<code>/lib/modules</code>下面生成</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/QQ%E6%88%AA%E5%9B%BE20220523115917.png"
alt="QQ截图20220523115917" />
<figcaption aria-hidden="true">QQ截图20220523115917</figcaption>
</figure>
<p><code>2.6.32-28-generic</code>是系统原来自带的</p>
<p><code>2.6.32.60XXXXXXXXXXXXh</code>是实验一生成的</p>
<p><code>2.6.32.60XXXXXXXXXXXXf</code>是本次实验生成的</p>
<p>然后使用<code>update-initramfs -c -k 2.6.32.60XXXXXXXXXXf</code>生成"虚拟盘文件"</p>
<p>我们正在玩一个大型橙光游戏,动辄编译个把小时,以防万一,此时拍一个快照吧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523121014189.png"
alt="image-20220523121014189" />
<figcaption aria-hidden="true">image-20220523121014189</figcaption>
</figure>
<p><strong>6.修改<code>grub.cfg</code></strong></p>
<p><code>grub.cfg</code>在<code>/boot/grub/grub.cfg</code></p>
<p>比着葫芦画瓢,照抄一个稍微改一下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/QQ%E6%88%AA%E5%9B%BE20220523120814.png"
alt="QQ截图20220523120814" />
<figcaption aria-hidden="true">QQ截图20220523120814</figcaption>
</figure>
<p>完了保存重启</p>
<p><strong>7.验证</strong></p>
<p><code>/mnt/hgfs/share/test.c</code>中这样写</p>
<blockquote>
<p>选这么一个位置纯粹是因为共享文件夹,可以在本机直接用vscode编写,虚拟机输入个字符都卡的要死</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test sjf&#x27;s syscall,%d\n&quot;</span>,syscall(<span class="number">337</span>,<span class="number">13</span>));<span class="comment">//调用337号系统调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523130855962.png"
alt="image-20220523130855962" />
<figcaption aria-hidden="true">image-20220523130855962</figcaption>
</figure>
<p>然后使用<code>dmesg</code>命令查看我们在自定义的内核函数中的输出<code>printk</code>,最后一行是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220523131010973.png"
alt="image-20220523131010973" />
<figcaption aria-hidden="true">image-20220523131010973</figcaption>
</figure>
<p>这与我们编写的是相同的,证明我们自己新增的系统调用的整个过程奏效了</p>
<h3 id="故障">故障</h3>
<p>由错误情况引起,可能被故障处理程序修正.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519073802747.png"
alt="image-20220519073802747" />
<figcaption aria-hidden="true">image-20220519073802747</figcaption>
</figure>
<p>比如缺页异常</p>
<h3 id="终止">终止</h3>
<p>发生致命错误,程序直接寄掉,处理程序将控制返回<code>abort</code>历程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519073854260.png"
alt="image-20220519073854260" />
<figcaption aria-hidden="true">image-20220519073854260</figcaption>
</figure>
<h3 id="异常号">异常号</h3>
<p>发现异常的时候会用事件号查事件表.这里的异常号不是事件号,而是对每个异常都进行编号</p>
<p><code>0~31</code>号异常由Intel架构师定义</p>
<p><code>32~255</code>号异常由操作系统设计师定义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519074127003.png"
alt="image-20220519074127003" />
<figcaption aria-hidden="true">image-20220519074127003</figcaption>
</figure>
<h2 id="进程">进程</h2>
<p>进程上下文:程序正确运行所需的状态组合,包括堆栈,代码和数据,通用寄存器,程序计数器,环境变量,打开的文件描述符集合</p>
<h3 id="私有虚拟地址空间">私有虚拟地址空间</h3>
<p>用户栈往下的部分都是进程独立的虚拟地址空间</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519075052410.png"
alt="image-20220519075052410" />
<figcaption aria-hidden="true">image-20220519075052410</figcaption>
</figure>
<p>私有虚拟地址空间,不是私有物理地址空间.</p>
<p>共享库在主存中只有一块物理地址空间,但是在两个进程虚拟地址空间中映射到不同部分</p>
<h3 id="用户态和内核态">用户态和内核态</h3>
<p>设置两种状态的作用是,限制进程对内核数据结构的访问修改,只有操作系统进程可以运行在内核态.用户应用进程永远不可能运行在内核态,用户应用进程只能通过系统调用,请操作系统去完成目的.</p>
<p>异常处理程序都运行在内核态</p>
<p>用户态和内核态怎么区分的?通过CPU中某个控制寄存器中的某个模式位</p>
<h3 id="上下文切换">上下文切换</h3>
<p>高层次的异常</p>
<p>进程上下文包括堆栈,数据和代码,各种寄存器,程序状态字,内核栈,内核各种数据结构比如页表</p>
<p>上下文切换的意思是,挂起当前正在运行的进程,保存其运行现场,然后执行其他进程.当该进程再次被<strong>调度</strong>时还原其运行现场</p>
<p>发生上下文切换时,操作系统会1.保存当前进程的上下文(放在内存里),2.恢复先前某个被挂起的进程执行现场3.控制交给该进程</p>
<p>上下文切换发生的时机:</p>
<p>1.系统调用可能引发上下文切换,比如当前进程使用系统级函数<code>write</code>向标准输出打印,这个过程对于CPU来说非常漫长.CPU会切换到执行另一个进程,不会等待数据写到显示器.更加明显的是<code>sleep</code>系统调用,不妨把话说得更明白些,直接让进程睡觉.</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519080431478.png"
alt="image-20220519080431478" />
<figcaption aria-hidden="true">image-20220519080431478</figcaption>
</figure>
</blockquote>
<p>2.软件中断,进程时间片用光了,该让给另一个进程执行了.</p>
<p>在程序员视角,进程的状态只有三种</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519082556372.png"
alt="image-20220519082556372" />
<figcaption aria-hidden="true">image-20220519082556372</figcaption>
</figure>
<h3 id="进程控制">进程控制</h3>
<p>控制进程的函数都是系统级函数</p>
<h4 id="获取进程id">获取进程ID</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pid_t int</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;		<span class="comment">//获取当前进程id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">//获得父进程id</span></span><br></pre></td></tr></table></figure>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid=getpid();</span><br><span class="line">    <span class="type">int</span> ppid=getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,ppid=%d&quot;</span>,pid,ppid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在bash shell命令行上编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    9 pts/0    00:00:00 bash</span><br><span class="line">   41 pts/0    00:00:00 ps</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line">pid=42,ppid=9</span><br></pre></td></tr></table></figure>
<p>bash调用ps程序,因此bash是ps的父进程</p>
<p>由于proc进程是由bash创建的,因此bash是proc的父进程</p>
<p>进程号只会越来越大,不会重复利用一个已经完成的进程的进程号</p>
<h4 id="创建进程">创建进程</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//子进程返回0,父进程返回子进程pid</span></span><br></pre></td></tr></table></figure>
<p>非常疑惑的一点是为什么一个函数调用可以返回两次</p>
<blockquote>
<p>对两个进程分别返回一次</p>
</blockquote>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in father process 0\n&quot;</span>);	<span class="comment">//fork之前只会被父进程执行一次</span></span><br><span class="line">    <span class="type">int</span> pid=fork();						<span class="comment">//此处子进程和父进程并行</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;		<span class="comment">//对于子进程来说,它确实有一个正整数进程号,但是fork返回的不是</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in son process 1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in father process 1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process 0</span><br><span class="line"><span class="keyword">in</span> father process 1</span><br><span class="line"><span class="keyword">in</span> son process 1</span><br></pre></td></tr></table></figure>
<p>不管什么进程,其进程号都是正数,不可能是0.fork对子进程的返回值为0并不代表一个进程号,而是区分子进程和父进程的标志</p>
<p>根据fork的返回值不同,这是一模一样的代码区分是父进程在执行还是子进程在执行的唯一标志</p>
<blockquote>
<p>这里c风格fork创建进程和C++中使用thread创建线程差别很大</p>
<p>thread创建线程,只需创建一个thread对象,对其构造函数传递一个函数,后面该函数就会自己开一条线程执行,thread对象就是线程的句柄.可以在函数线程之外,比如主线程处,通过thread对象,很自然地操作线程的行为比如detach或者join</p>
<p>而在这里唯一能区分线程的句柄就是一个整数pid,并且这个pid位于进程之中,只能在运行时通过pid判断是哪一个进程.不能在进程之外操作进程的行为</p>
</blockquote>
<p>fork之后原来的进程照旧执行,一个新的进程会拥有原进程的一模一样的虚拟地址空间的<strong>拷贝</strong>,包括代码数据寄存器堆栈等等.子进程和父进程的虚拟地址空间相互独立</p>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in son process: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in father process: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global=%d,local=%d\n&quot;</span>,global++,local++);<span class="comment">//这里有修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process: global=10,<span class="built_in">local</span>=20</span><br><span class="line"><span class="keyword">in</span> son process: global=10,<span class="built_in">local</span>=20	<span class="comment">#两个打印相同说明global有两个,local有两个</span></span><br></pre></td></tr></table></figure>
<p>父进程和子进程都打印到屏幕说明父子进程共享父进程已经打开的文件描述符1</p>
<p>用进程图描述fork是比较直观的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519084511671.png"
alt="image-20220519084511671" />
<figcaption aria-hidden="true">image-20220519084511671</figcaption>
</figure>
<h5 id="进程图如何实现">进程图如何实现</h5>
<p>1.main上多个分支</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519092351240.png"
alt="image-20220519092351240" />
<figcaption aria-hidden="true">image-20220519092351240</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pids[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> fpid=getpid();<span class="comment">//fpid在fork之前先计算好,此后即使所有子进程都拷贝,也只是拷贝的父进程号</span></span><br><span class="line">    <span class="keyword">if</span>(fpid==getpid())&#123;<span class="comment">//getpid在每个进程都不同,只有父进程中才会有fpid=getpid</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">            pids[i]=fork();<span class="comment">//实际上后来的子进程的pids也会存有数据,原因是父进程在创建第i个子进程时,pids已经写入前i-1个子进程号了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fpid==getpid())&#123;<span class="comment">//getpid在每个进程都不同,只有父进程中才会有fpid=getpid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in father process,pid=%d\n&quot;</span>,fpid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pid%d=%d,&quot;</span>,i,pids[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实际上的进程图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519093748088.png"
alt="image-20220519093748088" />
<figcaption aria-hidden="true">image-20220519093748088</figcaption>
</figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process,pid=222</span><br><span class="line">pid0=223,pid1=224,pid2=226,pid3=230,pid4=235,</span><br></pre></td></tr></table></figure>
<p>2.main和第一个子进程同时分支</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519093425314.png"
alt="image-20220519093425314" />
<figcaption aria-hidden="true">image-20220519093425314</figcaption>
</figure>
<p>这个很容易实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fork();</span><br><span class="line">fork();</span><br></pre></td></tr></table></figure>
<h5 id="fork前后"><strong>fork前后</strong></h5>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> pid0=getpid();          <span class="comment">//fork之前getpid</span></span><br><span class="line">    <span class="type">int</span> forkid=fork();          <span class="comment">//forkid只是用来</span></span><br><span class="line">    <span class="type">int</span> pid1=getpid();          <span class="comment">//fork之后getpid</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(forkid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in son process,pid0=%d,pid1=%d,forkid=%d\n&quot;</span>,pid0,pid1,forkid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in father process,pid0=%d,pid1=%d,forkid=%d\n&quot;</span>,pid0,pid1,forkid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process,pid0=116,pid1=116,forkid=117</span><br><span class="line"><span class="keyword">in</span> son process,pid0=116,pid1=117,forkid=0</span><br></pre></td></tr></table></figure>
<p>不管是父进程还是子进程,<code>pid0=116</code>相同,而<code>pid1</code>却不同,这是因为,pid0是fork之前执行的,当fork执行时,pid0已经被计算出了,作为一个局部变量压栈了,子进程不会再去计算pid0,而是从父进程堆栈的拷贝上直接拿.</p>
<p>但是pid1的情况不同,fork之后,子进程已经获得了父进程堆栈的拷贝,此后两个进程地址空间独立,后来的pid1就是分别计算之后分别存放在自己的堆栈里</p>
<p>看起来像是数据不管是fork前后都会被复制,实际上只复制了fork前的数据,此后进程各自维护自己的数据</p>
<h4 id="终止进程">终止进程</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;<span class="comment">//以status状态码返回</span></span><br></pre></td></tr></table></figure>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> forkid=fork();</span><br><span class="line">    <span class="type">int</span> pid=getpid();</span><br><span class="line">    <span class="keyword">if</span>(forkid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in son process,pid=%d\n&quot;</span>,pid);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);			<span class="comment">//让子进程结束运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in father process,pid=%d\n&quot;</span>,pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process %d is still running\n&quot;</span>,pid);		<span class="comment">//此句打印表明还在运行的进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process,pid=134</span><br><span class="line">process 134 is still running</span><br><span class="line"><span class="keyword">in</span> son process,pid=135</span><br></pre></td></tr></table></figure>
<h4 id="回收子进程">回收子进程</h4>
<p>进程终止之后并不会立刻消失地无影无踪,而是处于一种等待被父进程回收的状态,父进程回收终止子进程时,内核将子进程的exit状态传递给父进程.子进程被回收后才会消失地无影无踪</p>
<p>如果父进程一直没有回收已经终止的子进程,子进程就一直存在,称为"僵死进程"</p>
<p>如果父进程提前结束呢?内核会安排init进程成为孤儿进程的父进程</p>
<p>这就好比未成年的孩子父母双亡,被警察局送给孤儿院收养</p>
<p>这里起孤儿院作用的init进程,其pid=1,在系统启动时被内核创建,除非关机,否则永不终止.是所有进程的老祖宗.孤儿进程终止后,init会回收之</p>
<h5 id="waitpid">waitpid</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *statusp,<span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Attention!!!</strong>当第三个参数options不设置的时候,函数的默认行为是:<strong>挂起调用进程，直到有满足条件的子进程终止</strong>。</p>
<p>参数意义:</p>
<p><strong>1.<code>pid_t pid</code></strong></p>
<p>如果<code>pid&gt;0</code>则等待该指定pid的子进程终止</p>
<p>如果<code>pid=-1</code>则等待该进程的<strong>所有子进程</strong>,如果有其中的一个终止则waitpid返回该终止子进程的pid</p>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> fpid=getpid();</span><br><span class="line"><span class="type">int</span> forkid=fork();</span><br><span class="line"><span class="keyword">if</span>(forkid==<span class="number">0</span>)&#123;<span class="comment">//子进程中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in son process,id=%d\n&quot;</span>,getpid());</span><br><span class="line">  <span class="type">int</span> n=<span class="number">1000000</span>;</span><br><span class="line">  <span class="keyword">while</span>(n--);<span class="comment">//拖延时间</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//父进程中</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;in father process,id=%d\n&quot;</span>,fpid);</span><br><span class="line">  waitpid(forkid,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//指定等待唯一的子进程返回			//只指定第一个参数,其他使用缺省值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;son process %d exit\n&quot;</span>,forkid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process %d is still running\n&quot;</span>,getpid());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process,<span class="built_in">id</span>=273</span><br><span class="line"><span class="keyword">in</span> son process,<span class="built_in">id</span>=274		<span class="comment">#父进程需要等待子进程完成</span></span><br><span class="line">son process 274 <span class="built_in">exit</span></span><br><span class="line">process 273 is still running</span><br></pre></td></tr></table></figure>
<p><strong>2.<code>int *stausp</code></strong></p>
<p>如果statusp非空,则waitpid就会在statusp中记录子进程的exit
status,使用指针引用传递</p>
<p><code>proc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> fpid=getpid();</span><br><span class="line"><span class="type">int</span> forkid=fork();<span class="comment">//区分父子进程</span></span><br><span class="line"><span class="keyword">if</span>(forkid==<span class="number">0</span>)&#123;<span class="comment">//子进程中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in son process,id=%d\n&quot;</span>,getpid());</span><br><span class="line">  <span class="type">int</span> n=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">while</span>(n--);<span class="comment">//拖延时间</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程以status=0状态终止</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//父进程中</span></span><br><span class="line">  <span class="type">int</span> status=<span class="number">999</span>;<span class="comment">//设置status初始值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;in father process,id=%d\n&quot;</span>,fpid);</span><br><span class="line">  waitpid(forkid,&amp;status,<span class="number">0</span>);<span class="comment">//使用status承载子进程的exit状态值		//缺省第三个参数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;son process %d exit with status= %d\n&quot;</span>,forkid,status);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;WIFEXITED(status)=%d\n&quot;</span>,WIFEXITED(status));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;WEXITSTATUS(status)=%d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WIFSIGNALED(status)=%d\n&quot;</span>,WIFSIGNALED(status));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;WTERMSIG(status)=%d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WIFSTOPPED(status)=%d\n&quot;</span>,WIFSTOPPED(status));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WSTOPSIG(status)=%d\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WIFCONTINUED(status)=%d\n&quot;</span>,WIFCONTINUED(status));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process %d is still running\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./proc</span><br><span class="line"><span class="keyword">in</span> father process,<span class="built_in">id</span>=41</span><br><span class="line"><span class="keyword">in</span> son process,<span class="built_in">id</span>=42</span><br><span class="line">son process 42 <span class="built_in">exit</span> with status= 256	</span><br><span class="line">WIFEXITED(status)=1</span><br><span class="line">WEXITSTATUS(status)=1	<span class="comment">#这是exit(status)中的status</span></span><br><span class="line">WIFSIGNALED(status)=0</span><br><span class="line">WTERMSIG(status)=0</span><br><span class="line">WIFSTOPPED(status)=0</span><br><span class="line">WSTOPSIG(status)=1</span><br><span class="line">WIFCONTINUED(status)=0</span><br><span class="line">process 41 is still running</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释status的几个宏定义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220521075243518.png"
alt="image-20220521075243518" />
<figcaption aria-hidden="true">image-20220521075243518</figcaption>
</figure>
<p>奇怪的是,status明明是一个整数,为什么还能使用类似函数调用的宏,得到不同的结果?</p>
<p>推测status这个双字整形的每一位都携带着某种信息,实际上相当于一个布尔值的返回值集合,这些宏定义通过按位运算相当于在这个返回值集合中取了一部分值做运算</p>
</blockquote>
<p><strong>3.<code>int options</code>修改子进程的处理方式</strong></p>
<p>在<code>waitflags.h</code>中有这么几个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bits in the third argument to `waitpid&#x27;.  */</span>				<span class="comment">//waitpid的第三个参数 其中的一些位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	WNOHANG		1	<span class="comment">/* Don&#x27;t block waiting.  */</span>						<span class="comment">//01</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	WUNTRACED	2	<span class="comment">/* Report status of stopped children.  */</span>		  <span class="comment">//10</span></span></span><br></pre></td></tr></table></figure>
<p>函数的默认行为是:<strong>挂起调用进程，直到有满足条件的子进程终止</strong></p>
<p>指定options之后,函数的行为:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr>
<th>options</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WNOHANG</code></td>
<td>如果指定的子进程或者等待集合中的子进程都没有终止则立即返回0</td>
</tr>
<tr>
<td><code>WUNTRACED</code></td>
<td>挂起父进程,直到等待集合中的一个进程变成已终止<strong>或者被停止</strong>,返回该子进程pid</td>
</tr>
<tr>
<td><code>WCONTINUED</code></td>
<td>挂起父进程,直到等待集合中一个正在运行的进程终止或者等待集合中一个被停职的进程收到SIGCONT信号重新开始</td>
</tr>
<tr>
<td><code>WNOHANG | WUNTRACED</code></td>
<td>立即返回.如果等待集合中的子进程都没有被停止或者终止,返回0.如果有一个子进程停止或者终止,返回该子进程pid</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p>如果调用<code>waitpid</code>的进程没有任何子进程则<code>waitpid</code>返回-1,并设置<code>errno=EINTR</code></p>
<h6 id="wait">wait</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusup)</span>;</span><br></pre></td></tr></table></figure>
<p><code>wait(&amp;status)</code>等价于<code>waitpid(-1,&amp;status,0)</code></p>
<p>父进程挂起,等待子进程之一终止则返回其pid</p>
<h5 id="sleep">sleep</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br></pre></td></tr></table></figure>
<p>休眠secs秒,睡够了觉则sleep返回0否则返回还要睡多久</p>
<h5 id="pause">pause</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>让调用者进程休眠,直到该进程接收到信号</p>
<h4 id="加载并运行程序execve">加载并运行程序execve</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">const</span> <span class="type">char</span> *argv[],<span class="type">const</span> <span class="type">char</span> * envp[])</span>;<span class="comment">//成功则不返回,失败则返回-1</span></span><br></pre></td></tr></table></figure>
<p>执行filename指向的文件,参数为argv,环境为envp</p>
<p>例如:</p>
<p><code>execve.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali@Executor:/mnt/c/Users/86135/desktop/os$ gcc execve.c -O0 -o execve</span><br><span class="line"></span><br><span class="line">kali@Executor:/mnt/c/Users/86135/desktop/os$ ./execve</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>执行之后shell由bash换成了sh</p>
<blockquote>
<p>关于参数<code>const char *envp[]</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220521094616486.png"
alt="image-20220521094616486" />
<figcaption aria-hidden="true">image-20220521094616486</figcaption>
</figure>
<p>必须使用get或者set方法访问或者修改环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;<span class="comment">//返回name键对应的value值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *str)</span>;<span class="comment">//这里str的格式为name=value,将[name,value]键值对放在环境表中,如果name键存在则覆盖之</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">const</span> <span class="type">char</span> *newvalue,<span class="type">int</span> overwrite)</span>;<span class="comment">//[name,newvalue]键值对放在环境表中,如果name键存在则根据overwrite是否为1决定是否覆盖</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;<span class="comment">//清除环境表中的[name,value]键值对,如果name键不存在则什么都不会发生</span></span><br></pre></td></tr></table></figure>
<p><code>myecho.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;HOME&quot;</span>));<span class="comment">//home起始目录</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;SHELL&quot;</span>));<span class="comment">//用户首选shell名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;PWD&quot;</span>));<span class="comment">//当前工作目录绝对路径</span></span><br><span class="line">   </span><br><span class="line">    setenv(<span class="string">&quot;SHELL&quot;</span>,<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>);<span class="comment">//将用户首选的shell改成/bin/sh,overwrite=0表示如果已经存在name=SHELL的键则啥也不干</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;SHELL&quot;</span>));</span><br><span class="line">   </span><br><span class="line">    setenv(<span class="string">&quot;SHELL&quot;</span>,<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">1</span>);<span class="comment">//将用户首选的shell改成/bin/sh,overwrite=1表示如果已经存在name=SHELL的键则覆盖原来的value</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;SHELL&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ gcc myecho.c -Og -o myecho</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./myecho</span><br><span class="line">/home/kali</span><br><span class="line">/bin/bash</span><br><span class="line">/mnt/c/Users/86135/desktop/os</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/sh</span><br></pre></td></tr></table></figure>
<p><code>setenv</code>还可以新建环境变量,如果<code>name</code>键没有找到则新建环境变量</p>
<p>环境变量表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220521100230271.png"
alt="image-20220521100230271" />
<figcaption aria-hidden="true">image-20220521100230271</figcaption>
</figure>
<p>在当前进程中修改环境变量对当前进程无效,但是对该进程后续建立的子进程有效</p>
<blockquote>
<p>这里注意<code>putenv</code>和<code>setenv</code>在<code>overwrite=1</code>时的区别</p>
<p>一是参数的格式,<code>putenv</code>中<code>char *str</code>让写的是<code>name=value</code>这种格式,而<code>setenv</code>中<code>name</code>和<code>value</code>分开成为两个参数</p>
<p>二是参数的类型,<code>putenv</code>中的参数没有<code>const</code>修饰,这就意味着<strong>str是可以被修改的</strong></p>
<p>而<code>setenv</code>中的name和newvalue都带有const修饰,不可修改</p>
<p>实际上<code>putenv</code>不会为新的环境变量另外开空间,而是直接把传入的参数(不管是堆上还是栈上还是全局的)填入环境表</p>
<p><code>setenv</code>则会另开空间拷贝一份环境变量放进环境表</p>
<p>比如下面例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;myid=deutschball&quot;</span>;</span><br><span class="line">    putenv(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;myid&quot;</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;myid=dustball&quot;</span>);				<span class="comment">//此处修改str将会导致环境表中键myid的值变化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;myid&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[]=<span class="string">&quot;myunit&quot;</span>;</span><br><span class="line">    <span class="type">char</span> value[]=<span class="string">&quot;empire&quot;</span>;</span><br><span class="line">    setenv(name,value,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(name));</span><br><span class="line">    <span class="built_in">strcpy</span>(value,<span class="string">&quot;rebel&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(name));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ gcc myecho.c -Og -o myecho</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/os]</span><br><span class="line">└─$ ./myecho</span><br><span class="line">deutschball</span><br><span class="line">dustball					<span class="comment">#此处值发生了变化</span></span><br><span class="line">empire</span><br><span class="line">empire						<span class="comment">#此处值不发生改变</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>此处应有一个编个shell的实验,但是工程量太大,现在不想写,留作后话吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/07/datastruct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/datastruct/" class="post-title-link" itemprop="url">数据结构在汇编语言下的表现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-07 17:19:00" itemprop="dateCreated datePublished" datetime="2022-05-07T17:19:00+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-23 19:19:29" itemprop="dateModified" datetime="2022-05-23T19:19:29+08:00">2022-05-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构在汇编语言下的表现">数据结构在汇编语言下的表现</h1>
<h2 id="数组">数组</h2>
<h3 id="栈上数组">栈上数组</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local_array[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    local_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    local_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    local_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    local_array[index]=<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -O0 -o main.exe</span><br><span class="line">ida64 main.exe					<span class="comment">#需要将ida的根目录添加到环境变量path</span></span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的反汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; 64位windows上不再有__fastcall和_cdecl等调用约定的区别,只有一个同一的微软x64调用约定</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; void __fastcall func()</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_10          = dword ptr -10h			</span><br><span class="line">.text:0000000000401560 var_C           = dword ptr -0Ch</span><br><span class="line">.text:0000000000401560 var_8           = dword ptr -8</span><br><span class="line">.text:0000000000401560 var_4           = dword ptr -4</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 10h        ; 栈上开0x10=16字节的空间,用于存放局部变量(int local_array[3] 数组和int index变量,恰好4个int*一个int占用4字节)</span><br><span class="line">.text:0000000000401568                 mov     [rbp+var_4], 2  ; int index=2,可以判断var_4变量对应index</span><br><span class="line">.text:000000000040156F                 mov     [rbp+var_10], 0Ah ; 0x0Ah=10,对应local_array[0]=10;可以判断var_10对应local_array[0]</span><br><span class="line">.text:0000000000401576                 mov     [rbp+var_C], 14h ; 同理var_C=local_array[1]</span><br><span class="line">.text:000000000040157D                 mov     [rbp+var_8], 1Eh ; 同理var_8=local_array[2]</span><br><span class="line">.text:0000000000401584                 mov     eax, [rbp+var_4] ; 把index变量放在寄存器中,为0x401589的寻址做准备</span><br><span class="line">.text:0000000000401587                 cdqe					  ;将eax寄存器拓展为rax寄存器,该指令只作用于eax寄存器</span><br><span class="line">.text:0000000000401589                 mov     [rbp+rax*4+var_10], 28h ; local_array[index]=40</span><br><span class="line">.text:0000000000401591                 nop</span><br><span class="line">.text:0000000000401592                 add     rsp, 10h			;函数执行完毕,退栈</span><br><span class="line">.text:0000000000401596                 pop     rbp				;还原rbp原始功能</span><br><span class="line">.text:0000000000401597                 retn</span><br><span class="line">.text:0000000000401597 func            endp</span><br><span class="line">.text:0000000000401597</span><br></pre></td></tr></table></figure>
<p>函数栈帧基于rbp帧指针,主函数没有对其传递参数,栈帧中
有返回值,rbp保存值,还有四个变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502203420528.png"
alt="image-20220502203420528" />
<figcaption aria-hidden="true">image-20220502203420528</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502204300823.png"
alt="image-20220502204300823" />
<figcaption aria-hidden="true">image-20220502204300823</figcaption>
</figure>
<p>源程序中写的数组<code>int local_array[3]</code>被拆成了3个独立的int变量</p>
<p>只有在<code>.text:0000000000401589                 mov     [rbp+rax*4+var_10], 28h</code>这里可以隐约看出实在对数组进行寻址操作</p>
<p><code>var_10(rbp,rax,4)=M[rbp+rax*4+var_10]</code></p>
<p><code>rax</code>中存放的是index的值,用rax*4是因为一个int占4字节,<code>rbp+var_10</code>是数组的基地址,<code>rax*4</code>是偏移量</p>
<p>在分析出<code>var_8,var_C,var_10</code>同属于一个基地址<code>var_10</code>的数组结构后,可以在func函数的栈帧视图下高亮这三个变量,使用右键菜单的<code>array</code>选项将其合并为一个数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502205958995.png"
alt="image-20220502205958995" />
<figcaption aria-hidden="true">image-20220502205958995</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502205827491.png"
alt="image-20220502205827491" />
<figcaption aria-hidden="true">image-20220502205827491</figcaption>
</figure>
<p>​ 合并后回到反汇编视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502210142961.png"
alt="image-20220502210142961" />
<figcaption aria-hidden="true">image-20220502210142961</figcaption>
</figure>
<p>发现三个变量合并为一个<code>var_10</code>,其地址<code>rbp-10h</code>,刚好和<code>var_4</code>相差<code>0xC=12字节</code>即三个int类型变量</p>
<p>然后可以在反汇编视图下使用右键菜单的<code>rename</code>功能将变量命名有意义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502210513069.png"
alt="image-20220502210513069" />
<figcaption aria-hidden="true">image-20220502210513069</figcaption>
</figure>
<p>rename之后后文相关位置都会重新命名</p>
<h3 id="全局数组">全局数组</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_array[<span class="number">3</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    global_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    global_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    global_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    local_array[index]=<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的反汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame				;局部变量和参数在栈帧中的地址基于rbp帧指针</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; void __fastcall func()</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_4           = dword ptr -4			;局部变量只有一个,只能对应index</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 10h				</span><br><span class="line">.text:0000000000401568                 mov     [rbp+var_4], 2		;int index=2</span><br><span class="line">.text:000000000040156F                 lea     rax, global_array		;R[rax]=&amp;global_array,将global_array的地址放在rax</span><br><span class="line">.text:0000000000401576                 mov     dword ptr [rax], 0Ah  ;寄存器寻址,然后dword ptr指定双字访问内存,global_array[0]=10</span><br><span class="line">.text:000000000040157C                 lea     rax, global_array	;重复R[rax]=&amp;global_array,目的是防止上一次装载和本次之间rax有变化</span><br><span class="line">.text:0000000000401583                 mov     dword ptr [rax+4], 14h ;寄存器+立即数寻址,双字访问内存</span><br><span class="line">.text:000000000040158A                 lea     rax, global_array</span><br><span class="line">.text:0000000000401591                 mov     dword ptr [rax+8], 1Eh</span><br><span class="line">.text:0000000000401598                 lea     rax, global_array</span><br><span class="line">.text:000000000040159F                 mov     edx, [rbp+var_4]		 ;将var_4的拷贝到edx寄存器中</span><br><span class="line">.text:00000000004015A2                 movsxd  rdx, edx				;edx有符号拓展到rdx</span><br><span class="line">.text:00000000004015A5                 mov     dword ptr [rax+rdx*4], 28h ; 基址比例变址寻址,然后放入40</span><br><span class="line">.text:00000000004015AC                 nop</span><br><span class="line">.text:00000000004015AD                 add     rsp, 10h</span><br><span class="line">.text:00000000004015B1                 pop     rbp</span><br><span class="line">.text:00000000004015B2                 retn</span><br><span class="line">.text:00000000004015B2 func            endp</span><br><span class="line">.text:00000000004015B2</span><br></pre></td></tr></table></figure>
<p>问题是<code>global_array</code>貌似没有体现出声明来就直接使用了,左键双击<code>global_array</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public global_array</span><br><span class="line">.bss:0000000000407970 global_array     db    ? ;               ; DATA XREF: func+F↑o</span><br><span class="line">.bss:0000000000407970                                         ; func+1C↑o ...</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 db    ? ;</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 db    ? ;</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br></pre></td></tr></table></figure>
<p>发现<code>global_array</code>是位于bss段的,确实<code>global_array</code>在声明的时候并没有初始化,就应该放在bss段</p>
<p><code>global_array</code>以<code>db=define byte</code>即字节为单位,在bss段留了<code>0407970~040797F</code>一共16个字节的空间</p>
<p>如果在<code>func</code>函数的反汇编视图下修改<code>global_array</code>的名字改成空即显示ida给他命的哑名<code>unk_407970</code>,unk为unknown未知的缩写</p>
<p>如果在源代码中不写全局函数<code>global_array</code>,改用三个int类型变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l0;</span><br><span class="line"><span class="type">int</span> l1;</span><br><span class="line"><span class="type">int</span> l2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    l0=<span class="number">10</span>;</span><br><span class="line">    l1=<span class="number">20</span>;</span><br><span class="line">    l2=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时三个全局变量在bss段中的分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public l2</span><br><span class="line">.bss:0000000000407970 l2              db    ? ;               ; DATA XREF: func+1E↑o</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 public l0</span><br><span class="line">.bss:0000000000407974 l0              db    ? ;               ; DATA XREF: func+4↑o</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 public l1</span><br><span class="line">.bss:0000000000407978 l1              db    ? ;               ; DATA XREF: func+11↑o</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br><span class="line">.bss:0000000000407980                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>很诡异的是三个变量的分布是没有顺序的,l2和l0都分到了4个db即4字节的空间,但是l1却分到了8字节的空间</p>
<p>如果试图使用<code>*(&amp;l0+2)</code>来得到l2实际上会算得<code>*(0x407974+2*sizeof(int))=*(0x40797C)</code></p>
<p>而实际上<code>l2</code>在<code>0x407970</code>,刚才指针运算得到的值是属于l1"管理"的</p>
<h3 id="堆上数组">堆上数组</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *heap_array=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    heap_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    heap_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    heap_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    heap_array[index]=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">free</span>(heap_array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_C           = dword ptr -0Ch			;var_C显然为index</span><br><span class="line">.text:0000000000401560 Block           = qword ptr -8			;Block为堆上申请空间的指针</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 30h		;蜜汁操作,栈上分配了0x30h=48字节的巨大空间,但是只有两个局部变量</span><br><span class="line">.text:0000000000401568                 mov     ecx, 0Ch        ; Size,第一个参数使用ecx寄存器传递,这里0x0C=12字节相当于给出了堆上数组的大小</span><br><span class="line">.text:000000000040156D                 call    malloc			;malloc遵守 微软64位调用约定</span><br><span class="line">.text:0000000000401572                 mov     [rbp+Block], rax	;rax寄存器带着malloc函数的返回值,即堆上地址的指针,赋值给Block</span><br><span class="line">.text:0000000000401576                 mov     [rbp+var_C], 2	;int index=2</span><br><span class="line">.text:000000000040157D                 mov     rax, [rbp+Block]	;将堆上指针放到rax中</span><br><span class="line">.text:0000000000401581                 mov     dword ptr [rax], 0Ah	;字访问rax指向的地址,放入10</span><br><span class="line">.text:0000000000401587                 mov     rax, [rbp+Block]		;将堆上指针再次放到rax中</span><br><span class="line">.text:000000000040158B                 add     rax, 4				;rax中的指针副本后移4字节,恰好移过一个int</span><br><span class="line">.text:000000000040158F                 mov     dword ptr [rax], 14h		;单字访问rax指向的地址,放入20</span><br><span class="line">.text:0000000000401595                 mov     rax, [rbp+Block]	</span><br><span class="line">.text:0000000000401599                 add     rax, 8</span><br><span class="line">.text:000000000040159D                 mov     dword ptr [rax], 1Eh</span><br><span class="line">.text:00000000004015A3                 mov     eax, [rbp+var_C]			;将index放到eax中</span><br><span class="line">.text:00000000004015A6                 cdqe								;拓展eax到rax</span><br><span class="line">.text:00000000004015A8                 lea     rdx, ds:0[rax*4]			;将ds:0+rax*4这个地址放到rdx寄存器</span><br><span class="line">.text:00000000004015B0                 mov     rax, [rbp+Block]			;rax寄存器获得Block堆指针的拷贝</span><br><span class="line">.text:00000000004015B4                 add     rax, rdx					;rax指向Block+4*rax即heap_array[index]</span><br><span class="line">.text:00000000004015B7                 mov     dword ptr [rax], 28h ; 单字访问rax指向的地址,放入40</span><br><span class="line">.text:00000000004015BD                 mov     rax, [rbp+Block]			;rax获得Block堆指针拷贝</span><br><span class="line">.text:00000000004015C1                 mov     rcx, rax        ; rcx获得拷贝,准备作为参数传递给free函数</span><br><span class="line">.text:00000000004015C4                 call    free</span><br><span class="line">.text:00000000004015C9                 nop</span><br><span class="line">.text:00000000004015CA                 add     rsp, 30h</span><br><span class="line">.text:00000000004015CE                 pop     rbp</span><br><span class="line">.text:00000000004015CF                 retn</span><br><span class="line">.text:00000000004015CF func            endp</span><br><span class="line">.text:00000000004015CF</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://diveintosystems.org/book/C2-C_depth/_images/program_memory.png"
alt="The parts of program memory showing a stack variable pointing to dynamically allocated heap memory." />
<figcaption aria-hidden="true">The parts of program memory showing a
stack variable pointing to dynamically allocated heap
memory.</figcaption>
</figure>
<p>堆上数组的特征还是比较明显的</p>
<p>综上,使用变量下标访问数组时更容易察觉数组结构的存在,而使用常量下标访问数组时汇更像访问独立的变量</p>
<h2 id="结构体">结构体</h2>
<h3 id="对齐">对齐</h3>
<p>对齐在大多数情况下不是硬性要求,不对齐的话x86-64的硬件也是可以干活的,</p>
<p>但是为了提高性能intel建议对齐,编译器默认情况下是会自动对齐的</p>
<h4 id="基本数据类型的对齐规则">基本数据类型的对齐规则:</h4>
<p>某种类型的对象,其地址必须是K的倍数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503010303191.png"
alt="image-20220503010303191" />
<figcaption aria-hidden="true">image-20220503010303191</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> achar;</span><br><span class="line">	<span class="type">char</span> bchar;</span><br><span class="line">	<span class="type">int</span> aint;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>, &amp;achar, &amp;bchar, &amp;aint);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -g -o main.out</span><br><span class="line">gdb -tui -q main.out</span><br></pre></td></tr></table></figure>
<p>使用gdb进行调试,观察运行时的堆栈</p>
<p>1.在func函数处下断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503013023486.png"
alt="image-20220503013023486" />
<figcaption aria-hidden="true">image-20220503013023486</figcaption>
</figure>
<p>2.在断点处停下,打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /mnt/c/Users/86135/Desktop/reverse/mytest/main.exe</span><br><span class="line"></span><br><span class="line">Breakpoint 1, func () at main.c:7</span><br><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7fffffffdc90</span><br><span class="line">(gdb) p &amp;achar</span><br><span class="line"><span class="variable">$2</span> = 0x7fffffffdc8f <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;bchar</span><br><span class="line"><span class="variable">$3</span> = 0x7fffffffdc8e <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;aint</span><br><span class="line"><span class="variable">$4</span> = (int *) 0x7fffffffdc88</span><br></pre></td></tr></table></figure>
<p>帧指针<code>rbp</code>指向<code>0x7fffffffdc90</code></p>
<p>achar是一个char类型,无对齐要求,必然在紧接着帧指针下方<code>0x7fffffffdc8f</code>,bchar同理在achar下方<code>0x7fffffffdc8e</code></p>
<p>但是aint并没有紧挨着bchar在<code>0x7fffffffdc8d</code>,而是在<code>0x7fffffffdc88</code></p>
<p>栈向下增长,但是小端模式下,栈中的元素的起始位置是低地址,然后向高地址增长,比如aint就从<code>0x7fffffffdc88</code>然后向高地址增长直到<code>0x7fffffffdc8b</code></p>
<p><code>func</code>函数的栈帧:</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>相对rbp的偏移量</th>
<th>存储内容</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>1</code></td>
<td>返回值地址</td>
</tr>
<tr>
<td><code>0x7fffffffdc90</code></td>
<td><code>0</code></td>
<td><code>rbp</code>帧指针保存地址</td>
</tr>
<tr>
<td><code>0x7fffffffdc8f</code></td>
<td><code>-1</code></td>
<td><code>achar</code></td>
</tr>
<tr>
<td><code>0x7fffffffdc8e</code></td>
<td><code>-2</code></td>
<td><code>bchar</code></td>
</tr>
<tr>
<td></td>
<td><code>-3</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-4</code></td>
<td></td>
</tr>
<tr>
<td><code>0x7fffffffdc8b</code></td>
<td><code>-5</code></td>
<td><code>aint</code>高位</td>
</tr>
<tr>
<td></td>
<td><code>-6</code></td>
<td><code>aint</code></td>
</tr>
<tr>
<td></td>
<td><code>-7</code></td>
<td><code>aint</code></td>
</tr>
<tr>
<td><code>0x7fffffffdc88</code></td>
<td><code>-8</code></td>
<td><code>aint</code>低位</td>
</tr>
<tr>
<td></td>
<td><code>-9</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-10</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>...</td>
<td></td>
</tr>
<tr>
<td></td>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<p>这里aint就没有从-6到-3,而是为了对齐采用-8到-5</p>
<blockquote>
<h4 id="小端模式">小端模式</h4>
<p>小端模式:假如<code>int aint=10d=0xAh=0x0000 0000 0000 0000 0000 0000 0000 1010 b</code></p>
<p>那么<code>0x7fffffffdc88</code>这个低地址上应该存放<code>aint</code>的低八位即<code>0000 1010b=0x10h</code></p>
<p>为了观察这个事情</p>
<p>使用几乎相同的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> achar;</span><br><span class="line">	<span class="type">char</span> bchar;</span><br><span class="line">	<span class="type">int</span> aint=<span class="number">10</span>;<span class="comment">//注意此处给aint赋值10,小端模式下应该存放在&amp;aint的第一个字节单元</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>, &amp;achar, &amp;bchar, &amp;aint);</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gdb在第7行下断点,然后运行到第七行的时候停下,打印&amp;aint,结果为<code>0x7fffffffe2e8</code>,然后<code>x/1 0x7fffffffe2e8</code>打印从该地址开始的第一个单元(单位字节)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503020706566.png"
alt="image-20220503020706566" />
<figcaption aria-hidden="true">image-20220503020706566</figcaption>
</figure>
<p>结果为10,即证明低地址存放低位,小端模式</p>
</blockquote>
<h4 id="结构体的对齐规则">结构体的对齐规则</h4>
<p>结构体各项目依然满足基本数据类型的对齐方式</p>
<p>结构体自身也有对齐要求,其==基地址必须是最大成员大小的整数倍==</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name;</span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> a ;</span><br><span class="line">	Edge e;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>,&amp;a,&amp;e,&amp;b);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;	</span><br><span class="line">	func();</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -g -o main.exe</span><br><span class="line">gdb -tui -q main.exe</span><br></pre></td></tr></table></figure>
<p>在<code>func</code>函数处下断点然后在该断点处停下,打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;e</span><br><span class="line"><span class="variable">$4</span> = (Edge *) 0x7fffffffdc80</span><br><span class="line">(gdb) p &amp;e.name</span><br><span class="line"><span class="variable">$5</span> = 0x7fffffffdc80 <span class="string">&quot;&quot;</span>						;e.name的位置</span><br><span class="line">(gdb) p &amp;e.from</span><br><span class="line"><span class="variable">$6</span> = (int *) 0x7fffffffdc84					;e.from的位置</span><br><span class="line">(gdb) p &amp;e.to</span><br><span class="line"><span class="variable">$7</span> = (int *) 0x7fffffffdc88					;e.to的位置</span><br><span class="line">(gdb) p &amp;b</span><br><span class="line"><span class="variable">$8</span> = 0x7fffffffdc7f <span class="string">&quot;&quot;</span>						;char b的位置</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line"><span class="variable">$9</span> = 0x7fffffffdc8f <span class="string">&quot;&quot;</span>					    ;char a的位置</span><br><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$10</span> = (void *) 0x7fffffffdc90				;帧指针位置</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的栈帧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503111359404.png"
alt="image-20220503111359404" />
<figcaption aria-hidden="true">image-20220503111359404</figcaption>
</figure>
<p><strong>首先在结构体内部安排对齐</strong>:</p>
<p><code>name</code>放在偏移量为0的位置,然后<code>int from</code>放在偏移量为4的倍数的最小位置,显然是4,然后<code>int to</code>同理放在8,from和name之间就空出了3字节,原因就是考虑对齐</p>
<p><strong>然后对结构体整体安排对齐</strong>:</p>
<blockquote>
<p><strong>为什么要进行整体对齐?</strong></p>
<p>如果不进行此步,只进行内部对齐,那么考虑如下情形</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503112100035.png"
alt="image-20220503112100035" />
<figcaption aria-hidden="true">image-20220503112100035</figcaption>
</figure>
<p>左右两种排列方法均满足结构体内对齐,对于右侧,<code>e.from</code>的起始地址是<code>0x7fffffffdc85</code>显然不满足int的对齐规则,而左侧经过整体对齐,<code>e.from</code>在<code>0x7fffffffdc84</code>是可以整除4的,满足int的对齐规则</p>
<p>此时sizeof(e)=12,而不是1+4+4=9</p>
</blockquote>
<p>整体对齐要求结构体的起始地址必须是最大成员大小的整数倍,在这里是int,4字节</p>
<p>因此结构体e的起始地址应当是能够整除4的并且距离rbp最近的并且能够放得下结构体e的地方,显然是<code>0x7fffffffdc80</code></p>
<blockquote>
<p>整体对齐只是考虑了最大成员大小的整数倍,一定能保证所有成员的对齐吗?</p>
<p>由于任意基本数据类型的大小都是2的幂次,因此最大成员的大小一定是任意成员大小的整数倍,那么起始地址是最大成员大小的整数倍的同时,也一定是任意成员大小的整数倍</p>
</blockquote>
<h4 id="pragma-packn指定对齐">#pragma pack(n)指定对齐</h4>
<p>如果不写该语句则默认n=8字节对齐,所有对象的对齐方式改为:</p>
<p>地址值是<span
class="math inline">\(min\{自己大小,n\}的整数倍\)</span></p>
<p>同样的程序在一开始时加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br></pre></td></tr></table></figure>
<p>指定一字节对齐,任意对象的地址是<span
class="math inline">\(min\{自己大小,1\}的整数倍=1的整数倍\)</span>,即没有对齐</p>
<p>然后使用gdb调试观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7fffffffe2f0</span><br><span class="line">(gdb) p sizeof(e)</span><br><span class="line"><span class="variable">$2</span> = 9</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line"><span class="variable">$3</span> = 0x7fffffffe2ef <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;b</span><br><span class="line"><span class="variable">$4</span> = 0x7fffffffe2e5 <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;e.name</span><br><span class="line"><span class="variable">$5</span> = 0x7fffffffe2e6 <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;e.from</span><br><span class="line"><span class="variable">$6</span> = (int *) 0x7fffffffe2e7</span><br><span class="line">(gdb) p &amp;e.to</span><br><span class="line"><span class="variable">$7</span> = (int *) 0x7fffffffe2eb</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503115539724.png"
alt="image-20220503115539724" />
<figcaption aria-hidden="true">image-20220503115539724</figcaption>
</figure>
<p>此时栈帧就非常紧凑了,从rbp向下顺次紧密排列</p>
<blockquote>
<p>反汇编观察栈的分布</p>
<p>无对齐时的func函数的反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001139 func            proc near               ; CODE XREF: main+9↓p</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 var_B           = byte ptr -0Bh</span><br><span class="line">.text:0000000000001139 var_A           = byte ptr -0Ah		;var_A放在rbp-10</span><br><span class="line">.text:0000000000001139 var_1           = byte ptr -1</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 ; __unwind &#123;</span><br><span class="line">.text:0000000000001139                 push    rbp</span><br><span class="line">.text:000000000000113A                 mov     rbp, rsp</span><br><span class="line">.text:000000000000113D                 sub     rsp, 10h				;此处申请了16字节的栈空间</span><br><span class="line">.text:0000000000001141                 lea     rcx, [rbp+var_B]</span><br><span class="line">.text:0000000000001145                 lea     rdx, [rbp+var_A]</span><br><span class="line">.text:0000000000001149                 lea     rax, [rbp+var_1]</span><br><span class="line">.text:000000000000114D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001150                 lea     rax, format     ; &quot;%x,%x,%x&quot;</span><br><span class="line">.text:0000000000001157                 mov     rdi, rax        ; format</span><br><span class="line">.text:000000000000115A                 mov     eax, 0</span><br><span class="line">.text:000000000000115F                 call    _printf</span><br><span class="line">.text:0000000000001164                 nop</span><br><span class="line">.text:0000000000001165                 leave</span><br><span class="line">.text:0000000000001166                 retn</span><br><span class="line">.text:0000000000001166 ; &#125; // starts at 1139</span><br><span class="line">.text:0000000000001166 func            endp</span><br></pre></td></tr></table></figure>
<p>默认对齐时的<code>func</code>函数反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001139 func            proc near               ; CODE XREF: main+9↓p</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 var_11          = byte ptr -11h</span><br><span class="line">.text:0000000000001139 var_10          = byte ptr -10h			;var_10放在rbp-16</span><br><span class="line">.text:0000000000001139 var_1           = byte ptr -1</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 ; __unwind &#123;</span><br><span class="line">.text:0000000000001139                 push    rbp</span><br><span class="line">.text:000000000000113A                 mov     rbp, rsp</span><br><span class="line">.text:000000000000113D                 sub     rsp, 20h			;此处申请了32字节的栈空间</span><br><span class="line">.text:0000000000001141                 lea     rcx, [rbp+var_11]</span><br><span class="line">.text:0000000000001145                 lea     rdx, [rbp+var_10]</span><br><span class="line">.text:0000000000001149                 lea     rax, [rbp+var_1]</span><br><span class="line">.text:000000000000114D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001150                 lea     rax, format     ; &quot;%x,%x,%x&quot;</span><br><span class="line">.text:0000000000001157                 mov     rdi, rax        ; format</span><br><span class="line">.text:000000000000115A                 mov     eax, 0</span><br><span class="line">.text:000000000000115F                 call    _printf</span><br><span class="line">.text:0000000000001164                 nop</span><br><span class="line">.text:0000000000001165                 leave</span><br><span class="line">.text:0000000000001166                 retn</span><br><span class="line">.text:0000000000001166 ; &#125; // starts at 1139</span><br><span class="line">.text:0000000000001166 func            endp</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="全局结构体">全局结构体</h4>
<p>以网络流中可能会用到的边结构体举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;		<span class="comment">//源</span></span><br><span class="line">	<span class="type">int</span> to;			<span class="comment">//目的</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;<span class="comment">//距离</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;<span class="comment">//流量</span></span><br><span class="line">&#125;Edge;<span class="comment">//边结构体</span></span><br><span class="line"></span><br><span class="line">Edge e;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;<span class="comment">//初始化边e</span></span><br><span class="line">	e.from=<span class="number">1</span>;</span><br><span class="line">	e.to=<span class="number">2</span>;</span><br><span class="line">	e.dist=<span class="number">1e12</span>;</span><br><span class="line">	e.flow=<span class="number">1e13</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5
id="ida观察带gdb调试信息的exe文件">ida观察带gdb调试信息的exe文件</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -g -O0 -o main.exe</span><br><span class="line">ida64 main.exe</span><br></pre></td></tr></table></figure>
<p><code>init</code>函数的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560 ; void __cdecl init()</span><br><span class="line">.text:0000000000401560                 public init</span><br><span class="line">.text:0000000000401560 init            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 lea     rax, e			;把e的地址放在rax中</span><br><span class="line">.text:000000000040156B                 mov     dword ptr [rax], 1	;把1放在rax指向地址的第一个字</span><br><span class="line">.text:0000000000401571                 lea     rax, e				</span><br><span class="line">.text:0000000000401578                 mov     dword ptr [rax+4], 2	;把2放在rax指向地址偏移4字节之后的字中</span><br><span class="line">.text:000000000040157F                 lea     rax, e</span><br><span class="line">.text:0000000000401586                 mov     rdx, 0E8D4A51000h	;把1e12放在rdx中</span><br><span class="line">.text:0000000000401590                 mov     [rax+8], rdx			;把rdx中的值放在rax+8位置,宽度以rdx的64位为准</span><br><span class="line">.text:0000000000401594                 lea     rax, e</span><br><span class="line">.text:000000000040159B                 mov     rcx, 9184E72A000h	;把1e13放在rcx中</span><br><span class="line">.text:00000000004015A5                 mov     [rax+10h], rcx		;把rcx中的值放在rax+10位置,64位宽</span><br><span class="line">.text:00000000004015A9                 nop</span><br><span class="line">.text:00000000004015AA                 pop     rbp</span><br><span class="line">.text:00000000004015AB                 retn</span><br><span class="line">.text:00000000004015AB init            endp</span><br></pre></td></tr></table></figure>
<p>值得庆幸的是e被ida识别为一个Edge结构体的对象,这是因为使用<code>gcc -g</code>命令,编译形成的exe带有gbd调试信息</p>
<p>可以看出使用e的基地址+成员的偏移量进行结构体成员访问</p>
<p>其中e在bss段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public e</span><br><span class="line">.bss:0000000000407970 ; Edge e</span><br><span class="line">.bss:0000000000407970 e               Edge &lt;?&gt;                ; DATA XREF: init+4↑o</span><br><span class="line">.bss:0000000000407970                                         ; init+11↑o ...</span><br><span class="line">.bss:0000000000407988                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>e在bss段的地址<code>[0x407970,407987]</code>共24字节</p>
<blockquote>
<p>默认8字节对齐下,最大成员long
long正好8字节,因此任何成员都是按照地址是自己大小倍数进行对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;		<span class="comment">//源</span></span><br><span class="line">	<span class="type">int</span> to;			<span class="comment">//目的</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;<span class="comment">//距离</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;<span class="comment">//流量</span></span><br><span class="line">&#125;Edge;<span class="comment">//边结构体</span></span><br></pre></td></tr></table></figure>
<p>from和to恰好占用第一个8字节,然后dist占用第二个8字节,然后flow占用第三个8字节,合计24字节</p>
</blockquote>
<p>双击Edge可以观察其Structures视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 Edge            struc ; (sizeof=0x18, align=0x8, copyof_102)	;大小0x18=24字节,8字节对齐</span><br><span class="line">00000000                                         ; XREF: .bss:e/r</span><br><span class="line">00000000 from            dd ?	;dword双字类型</span><br><span class="line">00000004 to              dd ?	;dword双字类型</span><br><span class="line">00000008 dist            dq ?	;quad四字类型</span><br><span class="line">00000010 flow            dq ?	;quad四字类型</span><br><span class="line">00000018 Edge            ends</span><br></pre></td></tr></table></figure>
<h5 id="ida观察不带调试信息的exe">ida观察不带调试信息的exe</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -O0 -o main.exe			;不使用-g</span><br><span class="line">ida64 main.exe</span><br></pre></td></tr></table></figure>
<p><code>init</code>函数的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560                 public init</span><br><span class="line">.text:0000000000401560 init            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 lea     rax, e</span><br><span class="line">.text:000000000040156B                 mov     dword ptr [rax], 1</span><br><span class="line">.text:0000000000401571                 lea     rax, e</span><br><span class="line">.text:0000000000401578                 mov     dword ptr [rax+4], 2</span><br><span class="line">.text:000000000040157F                 lea     rax, e</span><br><span class="line">.text:0000000000401586                 mov     rdx, 0E8D4A51000h</span><br><span class="line">.text:0000000000401590                 mov     [rax+8], rdx</span><br><span class="line">.text:0000000000401594                 lea     rax, e</span><br><span class="line">.text:000000000040159B                 mov     rcx, 9184E72A000h</span><br><span class="line">.text:00000000004015A5                 mov     [rax+10h], rcx</span><br><span class="line">.text:00000000004015A9                 nop</span><br><span class="line">.text:00000000004015AA                 pop     rbp</span><br><span class="line">.text:00000000004015AB                 retn</span><br><span class="line">.text:00000000004015AB init            endp</span><br></pre></td></tr></table></figure>
<p>到此和刚才带有调试信息的情况几乎相同,但是当我们双击e试图观察e是个什么东西时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public e</span><br><span class="line">.bss:0000000000407970 e               db    ? ;               ; DATA XREF: init+4↑o</span><br><span class="line">.bss:0000000000407970                                         ; init+11↑o ...</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 db    ? ;</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 db    ? ;</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br><span class="line">.bss:0000000000407980                 db    ? ;</span><br><span class="line">.bss:0000000000407981                 db    ? ;</span><br><span class="line">.bss:0000000000407982                 db    ? ;</span><br><span class="line">.bss:0000000000407983                 db    ? ;</span><br><span class="line">.bss:0000000000407984                 db    ? ;</span><br><span class="line">.bss:0000000000407985                 db    ? ;</span><br><span class="line">.bss:0000000000407986                 db    ? ;</span><br><span class="line">.bss:0000000000407987                 db    ? ;</span><br><span class="line">.bss:0000000000407988                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>e退化为bss段上的24个字节,看不出结构体的痕迹了,</p>
<p>但是至少我们可以知道有这么一个叫做e的集合,它管理着24个字节</p>
<p>此时的结构体更像是一个鱼龙混杂的数组,有着不同大小的元素</p>
<h4 id="栈上结构体">栈上结构体</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;</span><br><span class="line">&#125;Edge;</span><br><span class="line">Edge <span class="title function_">newEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> d,<span class="type">long</span> <span class="type">long</span> f)</span>&#123;<span class="comment">//获取新的边对象,功能模仿构造函数</span></span><br><span class="line">	Edge e;</span><br><span class="line">	e.from=u;</span><br><span class="line">	e.to=v;</span><br><span class="line">	e.dist=d;</span><br><span class="line">	e.flow=f;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Edge e=newEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1e12</span>,<span class="number">1e13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="带调试信息">带调试信息</h5>
<p><code>newEdge</code>函数的反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560 ; Edge *__cdecl newEdge(Edge *__return_ptr __struct_ptr retstr, int u, int v, __int64 d, __int64 f)</span><br><span class="line">.text:0000000000401560                 public newEdge</span><br><span class="line">.text:0000000000401560 newEdge         proc near               ; CODE XREF: main+38↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 e               = Edge ptr -20h			;可以识别出结构体e</span><br><span class="line">.text:0000000000401560 arg_0           = qword ptr  10h			;蜜汁操作,多一个arg_0参数</span><br><span class="line">.text:0000000000401560 u               = dword ptr  18h			;由于带调试信息,ida认识四个参数名</span><br><span class="line">.text:0000000000401560 v               = dword ptr  20h</span><br><span class="line">.text:0000000000401560 d               = qword ptr  28h</span><br><span class="line">.text:0000000000401560 f               = qword ptr  30h</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 20h</span><br><span class="line">.text:0000000000401568                 mov     [rbp+arg_0], rcx</span><br><span class="line">.text:000000000040156C                 mov     [rbp+u], edx</span><br><span class="line">.text:000000000040156F                 mov     [rbp+v], r8d</span><br><span class="line">.text:0000000000401573                 mov     [rbp+d], r9</span><br><span class="line">.text:0000000000401577                 mov     eax, [rbp+u]</span><br><span class="line">.text:000000000040157A                 mov     [rbp+e.from], eax</span><br><span class="line">.text:000000000040157D                 mov     eax, [rbp+v]</span><br><span class="line">.text:0000000000401580                 mov     [rbp+e.to], eax</span><br><span class="line">.text:0000000000401583                 mov     rax, [rbp+d]</span><br><span class="line">.text:0000000000401587                 mov     [rbp+e.dist], rax</span><br><span class="line">.text:000000000040158B                 mov     rax, [rbp+f]</span><br><span class="line">.text:000000000040158F                 mov     [rbp+e.flow], rax</span><br><span class="line">.text:0000000000401593                 mov     rcx, [rbp+arg_0]</span><br><span class="line">.text:0000000000401597                 mov     rax, qword ptr [rbp+e.from]</span><br><span class="line">.text:000000000040159B                 mov     rdx, [rbp+e.dist]</span><br><span class="line">.text:000000000040159F                 mov     [rcx], rax</span><br><span class="line">.text:00000000004015A2                 mov     [rcx+8], rdx</span><br><span class="line">.text:00000000004015A6                 mov     rax, [rbp+e.flow]</span><br><span class="line">.text:00000000004015AA                 mov     [rcx+10h], rax</span><br><span class="line">.text:00000000004015AE                 mov     rax, [rbp+arg_0]</span><br><span class="line">.text:00000000004015B2                 add     rsp, 20h</span><br><span class="line">.text:00000000004015B6                 pop     rbp</span><br><span class="line">.text:00000000004015B7                 retn</span><br><span class="line">.text:00000000004015B7 newEdge         endp</span><br></pre></td></tr></table></figure>
<h5 id="不带调试信息">不带调试信息</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;</span><br><span class="line">&#125;Edge;</span><br><span class="line">Edge <span class="title function_">newEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> d,<span class="type">long</span> <span class="type">long</span> f)</span>&#123;<span class="comment">//获取新的边对象,功能模仿构造函数</span></span><br><span class="line">	Edge e;</span><br><span class="line">	e.from=u;</span><br><span class="line">	e.to=v;</span><br><span class="line">	e.dist=d;</span><br><span class="line">	e.flow=f;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Edge e=newEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1e12</span>,<span class="number">1e13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004015B8 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004015B8                 public main</span><br><span class="line">.text:00000000004015B8 main            proc near               ; CODE XREF: __tmainCRTStartup+22F↑p</span><br><span class="line">.text:00000000004015B8</span><br><span class="line">.text:00000000004015B8 var_30          = qword ptr -30h			</span><br><span class="line">.text:00000000004015B8 var_20          = byte ptr -20h</span><br><span class="line">.text:00000000004015B8</span><br><span class="line">.text:00000000004015B8                 push    rbp</span><br><span class="line">.text:00000000004015B9                 mov     rbp, rsp</span><br><span class="line">.text:00000000004015BC                 sub     rsp, 50h				</span><br><span class="line">.text:00000000004015C0                 call    __main				</span><br><span class="line">.text:00000000004015C5                 lea     rax, [rbp+var_20]	;&amp;var_20-&gt;rax</span><br><span class="line">.text:00000000004015C9                 mov     rdx, 9184E72A000h	 ;1e13-&gt;rdx</span><br><span class="line">.text:00000000004015D3                 mov     [rsp+50h+var_30], rdx ;1e13-&gt;rdx-&gt;*(var_30+50h)</span><br><span class="line">.text:00000000004015D8                 mov     r9, 0E8D4A51000h		;1e12-&gt;r9</span><br><span class="line">.text:00000000004015E2                 mov     r8d, 2				;2放在r8</span><br><span class="line">.text:00000000004015E8                 mov     edx, 1				;1放在rdx</span><br><span class="line">.text:00000000004015ED                 mov     rcx, rax				;rax是var_20的栈地址</span><br><span class="line">.text:00000000004015F0                 call    newEdge</span><br><span class="line">.text:00000000004015F5                 mov     eax, 0</span><br><span class="line">.text:00000000004015FA                 add     rsp, 50h</span><br><span class="line">.text:00000000004015FE                 pop     rbp</span><br><span class="line">.text:00000000004015FF                 retn</span><br><span class="line">.text:00000000004015FF main            endp</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/07/xctf-reverse-%E6%96%B0%E6%89%8B12%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/xctf-reverse-%E6%96%B0%E6%89%8B12%E9%A2%98/" class="post-title-link" itemprop="url">xctf攻防世界-reverse-新手村</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-07 17:16:00" itemprop="dateCreated datePublished" datetime="2022-05-07T17:16:00+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-03 16:27:03" itemprop="dateModified" datetime="2022-06-03T16:27:03+08:00">2022-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xctf攻防世界-reverse-新手村">xctf攻防世界-reverse-新手村</h1>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507171516740.png"
alt="image-20220507171516740" />
<figcaption aria-hidden="true">image-20220507171516740</figcaption>
</figure>
<h2 id="logmein">002logmein</h2>
<h3 id="main函数">main函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">var_90= qword ptr -90h;很奇怪的是,申请了好多变量,有四字的也有双字的还有字节的</span><br><span class="line">var_88= qword ptr -88h</span><br><span class="line">var_80= qword ptr -80h</span><br><span class="line">var_74= dword ptr -74h</span><br><span class="line">var_70= qword ptr -70h</span><br><span class="line">var_64= dword ptr -64h</span><br><span class="line">var_60= dword ptr -60h</span><br><span class="line">var_5C= dword ptr -5Ch</span><br><span class="line">var_57= byte ptr -57h</span><br><span class="line">var_56= byte ptr -56h</span><br><span class="line">var_55= byte ptr -55h</span><br><span class="line">var_54= dword ptr -54h</span><br><span class="line">s= byte ptr -50h</span><br><span class="line">var_2C= dword ptr -2Ch</span><br><span class="line">var_28= qword ptr -28h</span><br><span class="line">var_20= byte ptr -20h</span><br><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">;开端:</span><br><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 90h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     rdi, offset format ; &quot;Welcome to the RC3 secure password gues&quot;...</span><br><span class="line">mov     [rbp+var_4], 0</span><br><span class="line"></span><br><span class="line">;一系列蜜汁操作</span><br><span class="line">mov     rax, ds:qword_4008B0					;0x5E54525F4C41223A;</span><br><span class="line">mov     qword ptr [rbp+var_20], rax</span><br><span class="line">mov     rax, ds:qword_4008B8					;0x342F362B3F2E2A4C;</span><br><span class="line">mov     qword ptr [rbp+var_20+8], rax</span><br><span class="line">mov     cx, ds:word_4008C0						;0x36;</span><br><span class="line">mov     word ptr [rbp+var_20+10h], cx</span><br></pre></td></tr></table></figure>
<p>分析一下这里将数据传来传去干了啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506112847647.png"
alt="image-20220506112847647" />
<figcaption aria-hidden="true">image-20220506112847647</figcaption>
</figure>
<p><code>var_20</code>占据了栈上<code>rbp-20到rbp-9</code>共24字节空间</p>
<p><code>0x5E54525F4C41223A</code>放在栈上<code>var_20</code>,占用四字8字节,</p>
<p><code>0x342F362B3F2E2A4C</code>放在栈上<code>var_20+8</code>,恰好顺着刚才的<code>var_20</code>存放八个字节</p>
<p><code>0x36</code>放在栈上<code>var_20+10h</code>即<code>var_20+16</code>也是顺着放的</p>
<p>到此为止,<code>var_20</code>一共使用了<code>0~16</code>共17字节,十六进制的表示为:<code>0x36342F362B3F2E2A4C5E54525F4C41223A</code></p>
<p>表示成ascii码为:<code>64/6+?.*L^TR_LA":</code>,下面的字符啥也没写即为<code>'\0'</code>结束符号,一定要考虑清楚小端模式</p>
<p>由此可见<code>var_20</code>应当是开在栈上的一个字符数组,大小是<code>24bytes</code>,实际使用<code>17bytes</code></p>
<p>然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, qword ptr ds:byte_4008D0			 ;<span class="number">0x65626D61726168</span>;</span><br><span class="line">mov     [rbp+var_28], rax</span><br></pre></td></tr></table></figure>
<p><code>0x65626D61726168</code>一个四字放在栈中<code>var_28</code>上,<code>var_28</code>恰好也是8字节四字长度,表示成8个ascii字符为<code>ebmarah</code>刚好7个字符</p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     [rbp+var_2C], 7</span><br></pre></td></tr></table></figure>
<p><code>var_2C</code>是个双字但是却只放了一个7,可能会与<code>var_28</code>长度7有染</p>
<p>接着下面的反汇编应该调整一下指令顺序,调用<code>_printf</code>或者<code>_scanf</code>函数返回后立刻处理eax中的返回值,看起来比较直观,并且不影响程序逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;打印第一句废话</span><br><span class="line">mov     rdi, offset format ; &quot;Welcome to the RC3 secure password gues&quot;...</span><br><span class="line">mov     ...</span><br><span class="line">call    _printf				;printf函数返回值是实际打印字符数</span><br><span class="line">mov     [rbp+var_5C], eax	</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;打印第二句废话</span><br><span class="line">mov     rdi, offset aToContinueYouM ; &quot;To continue, you must enter the correct&quot;...</span><br><span class="line">call    _printf</span><br><span class="line">mov     [rbp+var_60], eax</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;打印第三句废话</span><br><span class="line">mov     rdi, offset aEnterYourGuess ; &quot;Enter your guess: &quot;</span><br><span class="line">call    _printf</span><br><span class="line">mov     [rbp+var_64], eax</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;调用scanf获取输入</span><br><span class="line">mov     rdi, offset a32s ; &quot;%32s&quot;</span><br><span class="line">lea     rsi, [rbp+s]    ; s作为scanf的缓冲区,获取输入</span><br><span class="line">call    ___isoc99_scanf		;scanf返回值是实际获取到的输入字符数</span><br><span class="line">mov     [rbp+var_74], eax	;输入字符数-&gt;eax</span><br><span class="line"></span><br><span class="line">;获取输入长度</span><br><span class="line">lea     rdi, [rbp+var_20]	;&amp;var_20-&gt;rdi</span><br><span class="line">lea     rsi, [rbp+s]	    ;&amp;s-&gt;rsi</span><br><span class="line">mov     [rbp+var_70], rdi	;&amp;var_20-&gt;rdi-&gt;var_70</span><br><span class="line">mov     rdi, rsi        	;&amp;s-&gt;rdi </span><br><span class="line">call    _strlen				;strlen(s)-&gt;rax</span><br><span class="line">mov     [rbp+var_80], rax	;strlen(s)-&gt;rax-&gt;var_80</span><br><span class="line"></span><br><span class="line">;获取存好的字符串长度</span><br><span class="line">mov     rdi, [rbp+var_70] 	;&amp;var_20-&gt;var_70-&gt;rdi	 </span><br><span class="line">call    _strlen				;strlen(&amp;var_20)-&gt;rax</span><br><span class="line">mov     rsi, [rbp+var_80]	;strlen(s)-&gt;var_80-&gt;rsi</span><br><span class="line"></span><br><span class="line">;比较两个长度是否相同</span><br><span class="line">cmp     rsi, rax			;比较s和var_20的长度(17)是否一致,即判断是否输入了17个字符</span><br><span class="line">jnb     loc_400700			;如果不一致则跳转报告失败,否则继续检查</span><br></pre></td></tr></table></figure>
<p>下面即将进入循环,现在我们已知的是输入要17个字符</p>
<h4 id="循环体分析">循环体分析</h4>
<p><code>sub_4007c0</code>函数报告失败,不妨给他起名<code>failure</code></p>
<p><code>sub_4007F0</code>函数报告成功,不妨给他起名<code>success</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506120601387.png"
alt="image-20220506120601387" />
<figcaption aria-hidden="true">image-20220506120601387</figcaption>
</figure>
<p>进入循环之前有一个<code>var_54=0</code>很自然可以想到的一种循环结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里<code>var_54</code>是循环变量i吗?</p>
<p>再看最下方的<code>loc_40079E</code>,其中对<code>var_54</code>进行了++,然后跳转<code>loc_400707</code>即循环开头,那么<code>var_54</code>基本上可以确定为循环变量i了</p>
<p>将反汇编翻译为伪代码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506124657651.png"
alt="image-20220506124657651" />
<figcaption aria-hidden="true">image-20220506124657651</figcaption>
</figure>
<p>解密算法已经很明显了,把<code>var_20</code>和<code>var_28</code>都看成字符数组然后<code>decrypt[i]=var_20[i]^var_28[i%7]</code>即可</p>
<h3 id="解密算法">解密算法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string var_20 = <span class="string">&quot;64/6+?.*L^TR_LA\&quot;:&quot;</span>;</span><br><span class="line">string var_28 = <span class="string">&quot;ebmarah&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">reverse</span>(var_<span class="number">20.</span><span class="built_in">begin</span>(), var_<span class="number">20.</span><span class="built_in">end</span>());<span class="comment">//反转一下是因为string字符串最左面的字符是低位,而小端模式下最右边是低位</span></span><br><span class="line">	<span class="built_in">reverse</span>(var_<span class="number">28.</span><span class="built_in">begin</span>(), var_<span class="number">28.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; var_<span class="number">20.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="type">int</span> temp = (<span class="type">int</span>)var_20[i] ^ (<span class="type">int</span>)var_28[i % <span class="number">7</span>];</span><br><span class="line">		cout &lt;&lt; (<span class="type">char</span>)temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC3-2016-XORISGUD</span><br></pre></td></tr></table></figure>
<h2 id="insanity">003insanity</h2>
<h3 id="信息收集">信息收集</h3>
<p>每次运行都根开盲盒似的,等待大约5秒之后给出一个结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line">Your ability to hack is about as good as my ability to have free will.</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line"><span class="comment">#define YOU &quot;massive failure&quot;</span></span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line">I<span class="string">&#x27;ve got a good feeling about this one..... wait no. Maybe next time.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">#define YOU &quot;massive failure&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">Your ability to hack is about as good as my ability to have free will.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">rm -rf / : Permission denied</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">Your ability to hack is about as good as my ability to have free will.</span></span><br></pre></td></tr></table></figure>
<h3 id="静态分析">静态分析</h3>
<p>一张图截完,题啃腚不难</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507122441995.png"
alt="image-20220507122441995" />
<figcaption aria-hidden="true">image-20220507122441995</figcaption>
</figure>
<p>实际上点进s或者任意一个存好的字符串到rodata区看一下就找到答案了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507171407247.png"
alt="image-20220507171407247" />
<figcaption aria-hidden="true">image-20220507171407247</figcaption>
</figure>
<p>下面分析一下程序逻辑</p>
<p>猜测是这样的:假设rodata区有n条语句组成一个数组,生成一个随机数然后对n取模,取该值对应下标的语句打印</p>
<p><code>main</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">public main</span><br><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">argc= dword ptr  8</span><br><span class="line">argv= dword ptr  0Ch</span><br><span class="line">envp= dword ptr  10h</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">and     esp, 0FFFFFFF0h													</span><br><span class="line">sub     esp, 10h</span><br><span class="line">mov     dword ptr [esp], offset s ; &quot;Reticulating splines, please wait..&quot;		;废话压栈</span><br><span class="line">call    _puts																;打印废话</span><br><span class="line">mov     dword ptr [esp], 5 ; seconds										;5秒压栈</span><br><span class="line">call    _sleep																;休眠5秒</span><br><span class="line"></span><br><span class="line">;生成随机数种子</span><br><span class="line">mov     dword ptr [esp], 0 ; timer											;time(0)</span><br><span class="line">call    _time</span><br><span class="line">mov     [esp], eax      ; seed												;time(0)的返回值作为参数</span><br><span class="line">call    _srand																;srand(time(0))</span><br><span class="line"></span><br><span class="line">;获得一个随机数</span><br><span class="line">call    _rand																;rand()-&gt;eax</span><br><span class="line">mov     ecx, eax															;rand()-&gt;eax-&gt;ecx</span><br><span class="line"></span><br><span class="line">;下面这一系列操作好迷啊</span><br><span class="line">mov     edx, 0CCCCCCCDh														;3435973837这个魔数是啥呢</span><br><span class="line">mul     edx																	;eax*edx-&gt;edx:eax</span><br><span class="line">shr     edx, 3																;edx/8</span><br><span class="line">lea     eax, [edx+edx*4]													;5edx-&gt;eax</span><br><span class="line">add     eax, eax															;10edx-&gt;eax</span><br><span class="line">sub     ecx, eax															;10edx</span><br><span class="line">;分析了一阵子屁用没有</span><br><span class="line"></span><br><span class="line">;取对应字符串并打印</span><br><span class="line">mov     eax, strs[ecx*4]													;ecx是下标,相邻亮指针偏移4字节</span><br><span class="line">mov     [esp], eax      ; s													</span><br><span class="line">call    _puts																</span><br><span class="line">xor     eax, eax															</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 80483F0</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507162916682.png"
alt="image-20220507162916682" />
<figcaption aria-hidden="true">image-20220507162916682</figcaption>
</figure>
<p>全篇没有看出一个取模来,难道是我老眼昏花了?</p>
<h3 id="取模时的编译优化">取模时的编译优化</h3>
<p>这里应该就是取模,但是其实现好迷啊</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call    _rand																;rand()-&gt;eax假设为16</span><br><span class="line">mov     ecx, eax															;rand()=16-&gt;eax-&gt;ecx</span><br><span class="line"></span><br><span class="line">;下面这一系列操作好迷啊</span><br><span class="line">mov     edx, 0CCCCCCCDh														;3435973837这个魔数是啥呢</span><br><span class="line">mul     edx																	;eax*edx-&gt;edx:eax=Ch:CCCCCCD0h</span><br><span class="line">shr     edx, 3																;edx/8=C/8=1</span><br><span class="line">lea     eax, [edx+edx*4]													;		5-&gt;eax</span><br><span class="line">add     eax, eax															;		10-&gt;eax</span><br><span class="line">sub     ecx, eax															;	16-10=6			</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/Wang_1997/article/details/104775975">(5条消息)
逆向-取模运算_嘻嘻兮的博客-CSDN博客_取模的逆运算</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507170255414.png"
alt="image-20220507170255414" />
<figcaption aria-hidden="true">image-20220507170255414</figcaption>
</figure>
<h2 id="re1">006re1</h2>
<h3 id="信息收集-1">信息收集</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\xctf12\re1&gt; ./re1   </span><br><span class="line">欢迎来到DUTCTF呦</span><br><span class="line">这是一道很可爱很简单的逆向题呦</span><br><span class="line">输入flag吧:123456</span><br><span class="line">flag不太对呦，再试试呗，加油呦</span><br><span class="line">请按任意键继续. . . </span><br></pre></td></tr></table></figure>
<p>输入flag之后必然会flag不对,然后程序阻塞,并且提示"请按任意键继续..."</p>
<p>这个题的图视图竟然可以用一个截屏截下来,必然简单</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507101716875.png"
alt="image-20220507101716875" />
<figcaption aria-hidden="true">image-20220507101716875</figcaption>
</figure>
<h3 id="逆向分析">逆向分析</h3>
<h4 id="开端">开端</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 44h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="防止栈缓冲区溢出">防止栈缓冲区溢出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401006                 mov     eax, ___security_cookie</span><br><span class="line">.text:0040100B                 xor     eax, ebp</span><br><span class="line">.text:0040100D                 mov     [ebp+var_4], eax</span><br></pre></td></tr></table></figure>
<h4
id="装填flag指令顺序有改动但是不影响逻辑">装填flag,指令顺序有改动但是不影响逻辑</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00401018                 xor     eax, eax					;eax归零</span><br><span class="line">.text:00401010                 movdqu  xmm0, ds:xmmword_413E34	;3074656D30633165577B465443545544h</span><br><span class="line">															;即 0tem0c1eW&#123;FTCTUD</span><br><span class="line">.text:0040101F                 movdqu  [ebp+var_44], xmm0			;0tem0c1eW&#123;FTCTUD-&gt;var_44	</span><br><span class="line">.text:00401024                 mov     [ebp+var_2C], eax			;eax=0-&gt;var_2C	</span><br><span class="line">.text:00401027                 movq    xmm0, ds:qword_413E44		;7D465443545544h即 &#125;FTCTUD</span><br><span class="line">.text:0040102F                 movq    [ebp+var_34], xmm0			;&#125;FTCTUD -&gt;var_34</span><br><span class="line">.text:00401034                 mov     [ebp+var_28], ax				;0-&gt;var_28</span><br></pre></td></tr></table></figure>
<h4 id="打印废话">打印废话</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0040101A                 push    offset aDutctf  ; &quot;欢迎来到DUTCTF呦\n&quot;	;废话压栈作为参数</span><br><span class="line">.text:00401038                 call    _printf						;打印第一句废话</span><br><span class="line">.text:0040103D                 push    offset asc_413E60 ; &quot;这是一道很可爱很简单的逆向题呦\n&quot;</span><br><span class="line">.text:00401042                 call    _printf</span><br><span class="line">.text:00401047                 push    offset aFlag    ; &quot;输入flag吧:&quot;</span><br><span class="line">.text:0040104C                 call    _printf</span><br></pre></td></tr></table></figure>
<h4 id="获取输入输入存储到var_24">获取输入,输入存储到var_24</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401051                 lea     eax, [ebp+var_24]</span><br><span class="line">.text:00401054                 push    eax</span><br><span class="line">.text:00401055                 push    offset Format   ; &quot;%s&quot;</span><br><span class="line">.text:0040105A                 call    _scanf</span><br></pre></td></tr></table></figure>
<h4 id="加载输入和flag">加载输入和flag</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0040105F                 add     esp, 14h</span><br><span class="line">.text:00401062                 lea     eax, [ebp+var_24]		;输入字符串的地址</span><br><span class="line">.text:00401065                 lea     ecx, [ebp+var_44]		;flag的地址</span><br></pre></td></tr></table></figure>
<h4
id="循环比较输入和flag每次比较两个字节">循环比较输入和flag,每次比较两个字节</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:00401068 loc_401068:                             ; CODE XREF: _main+82↓j</span><br><span class="line">.text:00401068                 mov     dl, [ecx]			;flag[0]值放在dl</span><br><span class="line">.text:0040106A                 cmp     dl, [eax]			;比较flag[0]和输入值的大小</span><br><span class="line">.text:0040106C                 jnz     short loc_401088		;如果不为零即输入和flag不相等则跳转,大概率跳转到寄</span><br><span class="line">.text:0040106E                 test    dl, dl				;dl中存放的是flag[i]如果为0说明遍历完毕,循环跳出</span><br><span class="line">.text:00401070                 jz      short loc_401084		;如果遍历完毕则跳转loc_401084</span><br><span class="line">.text:00401072                 mov     dl, [ecx+1]			</span><br><span class="line">.text:00401075                 cmp     dl, [eax+1]</span><br><span class="line">.text:00401078                 jnz     short loc_401088</span><br><span class="line">.text:0040107A                 add     ecx, 2</span><br><span class="line">.text:0040107D                 add     eax, 2</span><br><span class="line">.text:00401080                 test    dl, dl</span><br><span class="line">.text:00401082                 jnz     short loc_401068</span><br></pre></td></tr></table></figure>
<h4
id="两种情况置eax为0或1然后合并判断">两种情况,置eax为0或1然后合并判断</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+70↑j</span><br><span class="line">.text:00401084                 xor     eax, eax				;eax归零</span><br><span class="line">.text:00401086                 jmp     short loc_40108D		 ;跳转loc_401108D</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401088 loc_401088:                             ; CODE XREF: _main+6C↑j</span><br><span class="line">.text:00401088                                         ; _main+78↑j</span><br><span class="line">.text:00401088                 sbb     eax, eax			;带借位减法,eax=-1=0xFFFFFFFF</span><br><span class="line">.text:0040108A                 or      eax, 1			;eax=1&amp;0xFFFFFFF=1</span><br></pre></td></tr></table></figure>
<h4 id="合并.根据刚才的eax判断">合并.根据刚才的eax判断</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0040108D loc_40108D:                             ; CODE XREF: _main+86↑j</span><br><span class="line">.text:0040108D                 test    eax, eax					;判断eax是否为0</span><br><span class="line">.text:0040108F                 jnz     short loc_401098			 ;如果eax!=0则跳转loc_401098</span><br><span class="line">.text:00401091                 push    offset unk_413E90;flag get ;否则eax=0表示成功,&quot;flag get&quot;的地址压栈准备打印</span><br><span class="line">.text:00401096                 jmp     short loc_40109D			 ;跳转loc_40109D</span><br><span class="line">.text:00401098 loc_401098:                             ; CODE XREF: _main+8F↑j</span><br><span class="line">.text:00401098                 push    offset aFlag_0  ; &quot;flag不太对呦&quot;		;&quot;flag不太对呦&quot;地址压栈,准备打印</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="尾声">尾声</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0040109D loc_40109D:                             ; CODE XREF: _main+96↑j</span><br><span class="line">.text:0040109D                 call    _printf				;打印刚才压入栈中的缓冲区</span><br><span class="line">.text:004010A2                 add     esp, 4				;退栈4</span><br><span class="line">.text:004010A5                 push    offset Command  ; &quot;pause&quot;  ;&quot;pause&quot;串的地址压栈,准备为system函数传参</span><br><span class="line">.text:004010AA                 call    _system					;程序阻塞暂停</span><br><span class="line"></span><br><span class="line">;以下部分可能是在检查栈缓冲区溢出?</span><br><span class="line">.text:004010AF                 mov     ecx, [ebp+var_4]			</span><br><span class="line">.text:004010B2                 add     esp, 4</span><br><span class="line">.text:004010B5                 xor     ecx, ebp        ; StackCookie</span><br><span class="line">.text:004010B7                 xor     eax, eax</span><br><span class="line">.text:004010B9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:004010BE                 mov     esp, ebp</span><br><span class="line">.text:004010C0                 pop     ebp</span><br><span class="line">.text:004010C1                 retn</span><br><span class="line">.text:004010C1 _main           endp</span><br></pre></td></tr></table></figure>
<h3 id="security_cookie">___security_cookie</h3>
<p><a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">参考微软官方文档</a></p>
<blockquote>
<p>全局安全 Cookie 用于在使用 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/gs-buffer-security-check?view=msvc-170">/GS（缓冲区安全检查）</a>编译的代码中和使用异常处理的代码中提供缓冲区溢出保护。
进入受到溢出保护的函数时，Cookie
被置于堆栈之上；退出时，会将堆栈上的值与全局 Cookie 进行比较。
它们之间存在任何差异则表示已经发生缓冲区溢出，并导致该程序的立即终止。</p>
<p>通常， <strong><code>__security_init_cookie</code></strong>
在初始化时由 CRT 调用。 如果你跳过 CRT 初始化（例如，如果使用 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170"><code>/ENTRY</code></a>
指定入口点），则必须自己调用
<strong><code>__security_init_cookie</code></strong> 。 如果
<strong><code>__security_init_cookie</code></strong> 不调用，全局安全
cookie 将设置为默认值，并且会危及缓冲区溢出保护。 由于攻击者可利用此默认
Cookie 值使缓冲区溢出检查无效，我们建议，在定义自己的入口点时，始终调用
<strong><code>__security_init_cookie</code></strong>。</p>
<p>在进入任何受到溢出保护的函数前，必须调用
<strong><code>__security_init_cookie</code></strong>，否则将检测到虚假的缓冲区溢出。
有关详细信息，请参阅 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/c-runtime-error-r6035?view=msvc-170">C
运行时错误 R6035</a>。</p>
</blockquote>
<h2 id="game">007game</h2>
<h3 id="信息收集-2">信息收集</h3>
<p>一个32位exe程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                     |------------／ --------△--------|</span><br><span class="line">                     |-----------------------●--------|</span><br><span class="line">                     |------------／ --------◇--------|</span><br><span class="line">                     |-----------------------■--------|</span><br><span class="line">|--------------------|------------／ --------☆--------|</span><br><span class="line">|                    |------------／ --------▽--------|</span><br><span class="line">|                    |------------／ -----(￣▽￣)／---|</span><br><span class="line">|                    |--------------------(*°▽°)=3--|</span><br><span class="line">二                                                     |</span><br><span class="line">|           by 0x61                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">input n,n(1-8)</span><br><span class="line">1.△ 2.○ 3.◇ 4.□ 5.☆ 6.▽ 7.(￣▽￣)／ 8.(;°Д°) 0.restart</span><br><span class="line">n=</span><br></pre></td></tr></table></figure>
<p>一个开灯和关灯的游戏,大意是:</p>
<p>有八栈灯编号为1到8,每次可以选择一盏灯改变其开关状态,并且其左右的灯也会改变开关状态,认为8号灯和1号灯也是相邻的</p>
<p>初始时八盏灯都是灭的</p>
<p>当八盏灯都亮起来的时候,就给flag</p>
<h3 id="算法解决">算法解决</h3>
<p>首先考虑这个问题是否有解?</p>
<p>方便取模运算,将灯号从0编到7</p>
<table>
<thead>
<tr>
<th>灯号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第一次</td>
<td>1</td>
<td>==1==</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第二次</td>
<td>1</td>
<td>0</td>
<td>==0==</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第三次</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==1==</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第四次</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==0==</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>第五次</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==1==</td>
</tr>
</tbody>
</table>
<p>经过五次变化之后,我们可以得到一栈两着的灯,并且其他暗着的灯我们可以视为一直暗着</p>
<p>==因此同时改变三栈灯的状态是可以推出等价于只改变一盏灯的状态==</p>
<p>从1号灯开始的变化导致了7号灯变化</p>
<p>同理可知从2号灯开始的变化导致0号灯变化</p>
<p>...</p>
<p>从i号灯开始的变化导致(i+6)%8的灯变化,其路径为<code>i%8,(i+1)%8,(i+3)%8,(i+4)%8,(i+6)%8</code>共五次变化</p>
<p>则8盏灯全部由暗变亮需要40次变化</p>
<p>可以编写解密脚本打印出这40个数字然后粘贴进game.exe解密</p>
<p>解密脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//实际上还得是从1开始编号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">1</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">3</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">4</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">6</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">		change(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果粘贴进<code>game.exe</code>之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done!!! the flag is zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态分析-1">静态分析</h3>
<h4 id="尝试1">尝试1</h4>
<p>假设我们不会玩这个游戏,但是可以猜测,这⑧盏灯是可以都点亮的,诚如是,则程序交出flag,退出</p>
<p>那么在反汇编图视图中应当有一些没有后继的叶子块,即成功的分支</p>
<p>满足条件的块只有一个,如图所示红色块</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506234409960.png"
alt="image-20220506234409960" />
<figcaption aria-hidden="true">image-20220506234409960</figcaption>
</figure>
<p>但是这个块实际上干了和栈有关一些事,具体啥事也不想管了,总之这样猜测是错的</p>
<p>刚才用算法方法点亮了所有的灯,程序也给出了flag但是程序依然在执行</p>
<h4 id="尝试2">尝试2</h4>
<p>每次输入改变灯状态之后会有一个对所有灯的状态检查,要么是在循环开始,要么是在循环尾部</p>
<p>这八盏灯的状态可能是在放在一个字节里的八位,通过按位操作改变状态</p>
<p>或者每个灯一个单元,放在一个数组里</p>
<p>观察反汇编的图视图,发现有这么八块基本相同的结构,大概率就是逐次判断灯的状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507075557175.png"
alt="image-20220507075557175" />
<figcaption aria-hidden="true">image-20220507075557175</figcaption>
</figure>
<p>观察其中的一块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, 1					;1-&gt;eax</span><br><span class="line">shl     eax, 0					</span><br><span class="line">movzx   ecx, byte_532E28[eax]	  ;byte_532E28[1]-&gt;ecx</span><br><span class="line">cmp     ecx, 1					;cmp byte_532E28[1],1</span><br><span class="line">jnz     short loc_45F671		 ;不为0则表明灯灭,跳转从头再来</span><br></pre></td></tr></table></figure>
<p>那么如果八块均不跳转jnz,那么紧接着就应该给出flag了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507080122539.png"
alt="image-20220507080122539" />
<figcaption aria-hidden="true">image-20220507080122539</figcaption>
</figure>
<p>结果该函数开头给出了好长一坨字符数组,然后给了这么一个循环,明显是有加密算法的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507081140177.png"
alt="image-20220507081140177" />
<figcaption aria-hidden="true">image-20220507081140177</figcaption>
</figure>
<p>蓝色块用作打印,和加密算法无关,暂时不关心</p>
<p>结尾<code>loc_45EB61</code>将var_94++,显然是作为循环变量的,</p>
<p>开头<code>loc_45EB70</code>将<code>var_94</code>和<code>0x38h=56</code>进行比较,应该是判断循环结束条件,循环56次</p>
<p><code>loc_45EB70</code>之前有一个<code>mov [ebp+var_94],0</code>显然是循环变量var_94一开始是下标0</p>
<p>那么不妨给<code>var_94</code>重命名i</p>
<p>循环体:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+i]</span><br><span class="line">movsx   ecx, [ebp+eax+var_44]			;var_44[i]-&gt;ecx</span><br><span class="line">mov     edx, [ebp+i]					</span><br><span class="line">movsx   eax, [ebp+edx+var_88]			;var_88[i]-&gt;eax</span><br><span class="line">xor     eax, ecx						;var_44[i]^var_88[i]-&gt;eax</span><br><span class="line">mov     ecx, [ebp+i]					</span><br><span class="line">mov     [ebp+ecx+var_88], al			;var_44[i]^var_88[i]-&gt;var_88[i]</span><br><span class="line">mov     eax, [ebp+i]</span><br><span class="line">movsx   ecx, [ebp+eax+var_88]			;var_88[i]-&gt;ecx</span><br><span class="line">xor     ecx, 13h						;var_88[i]^13h-&gt;ecx</span><br><span class="line">mov     edx, [ebp+i]					</span><br><span class="line">mov     [ebp+edx+var_88], cl			;var_88[i]^13h-&gt;var_88[i]</span><br><span class="line">jmp     short loc_45EB61				</span><br></pre></td></tr></table></figure>
<p>这么一长段干了一件事 <span class="math display">\[
var\_88[i]=var\_88[i]\oplus var\_44[i]\oplus 0x13
\]</span>
<code>var_88</code>在内存中占用-88到-50刚好0x38大小,与循环变量i的范围相同</p>
<p>同理<code>var_44</code>应当占用<code>-44</code>到<code>-C</code></p>
<p>在栈视图下编好数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507083640431.png"
alt="image-20220507083640431" />
<figcaption aria-hidden="true">image-20220507083640431</figcaption>
</figure>
<p>回到反汇编视图</p>
<p>接下来考虑怎样把mov进入var_44数组的值提取出来放到一个数组里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507084508649.png"
alt="image-20220507084508649" />
<figcaption aria-hidden="true">image-20220507084508649</figcaption>
</figure>
<p>如果高亮<code>.text:0045E975</code>到<code>.text:0045EA55</code>之后右键convert
to C/C++ array(DWORD)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507084855688.png"
alt="image-20220507084855688" />
<figcaption aria-hidden="true">image-20220507084855688</figcaption>
</figure>
<p>得到的数组是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x45E975</span> - <span class="number">0x45EA55</span> (<span class="number">224</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> data[<span class="number">56</span>] = &#123;</span><br><span class="line">    <span class="number">0x12BC45C6</span>, <span class="number">0x40BD45C6</span>, <span class="number">0x62BE45C6</span>, <span class="number">0x05BF45C6</span>, <span class="number">0x02C045C6</span>, <span class="number">0x04C145C6</span>, <span class="number">0x06C245C6</span>, <span class="number">0x03C345C6</span>, </span><br><span class="line">    <span class="number">0x06C445C6</span>, <span class="number">0x30C545C6</span>, <span class="number">0x31C645C6</span>, <span class="number">0x41C745C6</span>, <span class="number">0x20C845C6</span>, <span class="number">0x0CC945C6</span>, <span class="number">0x30CA45C6</span>, <span class="number">0x41CB45C6</span>, </span><br><span class="line">    <span class="number">0x1FCC45C6</span>, <span class="number">0x4ECD45C6</span>, <span class="number">0x3ECE45C6</span>, <span class="number">0x20CF45C6</span>, <span class="number">0x31D045C6</span>, <span class="number">0x20D145C6</span>, <span class="number">0x01D245C6</span>, <span class="number">0x39D345C6</span>, </span><br><span class="line">    <span class="number">0x60D445C6</span>, <span class="number">0x03D545C6</span>, <span class="number">0x15D645C6</span>, <span class="number">0x09D745C6</span>, <span class="number">0x04D845C6</span>, <span class="number">0x3ED945C6</span>, <span class="number">0x03DA45C6</span>, <span class="number">0x05DB45C6</span>, </span><br><span class="line">    <span class="number">0x04DC45C6</span>, <span class="number">0x01DD45C6</span>, <span class="number">0x02DE45C6</span>, <span class="number">0x03DF45C6</span>, <span class="number">0x2CE045C6</span>, <span class="number">0x41E145C6</span>, <span class="number">0x4EE245C6</span>, <span class="number">0x20E345C6</span>, </span><br><span class="line">    <span class="number">0x10E445C6</span>, <span class="number">0x61E545C6</span>, <span class="number">0x36E645C6</span>, <span class="number">0x10E745C6</span>, <span class="number">0x2CE845C6</span>, <span class="number">0x34E945C6</span>, <span class="number">0x20EA45C6</span>, <span class="number">0x40EB45C6</span>, </span><br><span class="line">    <span class="number">0x59EC45C6</span>, <span class="number">0x2DED45C6</span>, <span class="number">0x20EE45C6</span>, <span class="number">0x41EF45C6</span>, <span class="number">0x0FF045C6</span>, <span class="number">0x22F145C6</span>, <span class="number">0x12F245C6</span>, <span class="number">0x10F345C6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上存储的是指令不是我们要的数值</p>
<p>但是可以发现,每个数据的高两个16进制位是我们要的数值</p>
<p>比如<code>0x12BC45C6</code>高两位那么将每个16进制数按位与<code>0xFF000000</code>即可只保留高两位,或者直接右移24位即可转化为低两位</p>
<p>但是对于<code>var_88</code>这个数组,它头几个元素赋值的指令占了7字节,可以手动抄到数组里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507090007954.png"
alt="image-20220507090007954" />
<figcaption aria-hidden="true">image-20220507090007954</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_88_2[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x7b000000</span>, <span class="number">0x20000000</span>, <span class="number">0x12000000</span>, <span class="number">0x62000000</span>, <span class="number">0x77000000</span>, <span class="number">0x6C000000</span>, <span class="number">0x41000000</span>, <span class="number">0x29000000</span>,</span><br><span class="line">    <span class="number">0x7C8045C6</span>, <span class="number">0x508145C6</span>, <span class="number">0x7D8245C6</span>, <span class="number">0x268345C6</span>, <span class="number">0x7C8445C6</span>, <span class="number">0x6F8545C6</span>, <span class="number">0x4A8645C6</span>, <span class="number">0x318745C6</span>, </span><br><span class="line">    <span class="number">0x538845C6</span>, <span class="number">0x6C8945C6</span>, <span class="number">0x5E8A45C6</span>, <span class="number">0x6C8B45C6</span>, <span class="number">0x548C45C6</span>, <span class="number">0x068D45C6</span>, <span class="number">0x608E45C6</span>, <span class="number">0x538F45C6</span>, </span><br><span class="line">    <span class="number">0x2C9045C6</span>, <span class="number">0x799145C6</span>, <span class="number">0x689245C6</span>, <span class="number">0x6E9345C6</span>, <span class="number">0x209445C6</span>, <span class="number">0x5F9545C6</span>, <span class="number">0x759645C6</span>, <span class="number">0x659745C6</span>, </span><br><span class="line">    <span class="number">0x639845C6</span>, <span class="number">0x7B9945C6</span>, <span class="number">0x7F9A45C6</span>, <span class="number">0x779B45C6</span>, <span class="number">0x609C45C6</span>, <span class="number">0x309D45C6</span>, <span class="number">0x6B9E45C6</span>, <span class="number">0x479F45C6</span>, </span><br><span class="line">    <span class="number">0x5CA045C6</span>, <span class="number">0x1DA145C6</span>, <span class="number">0x51A245C6</span>, <span class="number">0x6BA345C6</span>, <span class="number">0x5AA445C6</span>, <span class="number">0x55A545C6</span>, <span class="number">0x40A645C6</span>, <span class="number">0x0CA745C6</span>, </span><br><span class="line">    <span class="number">0x2BA845C6</span>, <span class="number">0x4CA945C6</span>, <span class="number">0x56AA45C6</span>, <span class="number">0x0DAB45C6</span>, <span class="number">0x72AC45C6</span>, <span class="number">0x01AD45C6</span>, <span class="number">0x75AE45C6</span>, <span class="number">0x7EAF45C6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解密脚本">解密脚本</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_44[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x12BC45C6</span>, <span class="number">0x40BD45C6</span>, <span class="number">0x62BE45C6</span>, <span class="number">0x05BF45C6</span>, <span class="number">0x02C045C6</span>, <span class="number">0x04C145C6</span>, <span class="number">0x06C245C6</span>, <span class="number">0x03C345C6</span>,</span><br><span class="line">	<span class="number">0x06C445C6</span>, <span class="number">0x30C545C6</span>, <span class="number">0x31C645C6</span>, <span class="number">0x41C745C6</span>, <span class="number">0x20C845C6</span>, <span class="number">0x0CC945C6</span>, <span class="number">0x30CA45C6</span>, <span class="number">0x41CB45C6</span>,</span><br><span class="line">	<span class="number">0x1FCC45C6</span>, <span class="number">0x4ECD45C6</span>, <span class="number">0x3ECE45C6</span>, <span class="number">0x20CF45C6</span>, <span class="number">0x31D045C6</span>, <span class="number">0x20D145C6</span>, <span class="number">0x01D245C6</span>, <span class="number">0x39D345C6</span>,</span><br><span class="line">	<span class="number">0x60D445C6</span>, <span class="number">0x03D545C6</span>, <span class="number">0x15D645C6</span>, <span class="number">0x09D745C6</span>, <span class="number">0x04D845C6</span>, <span class="number">0x3ED945C6</span>, <span class="number">0x03DA45C6</span>, <span class="number">0x05DB45C6</span>,</span><br><span class="line">	<span class="number">0x04DC45C6</span>, <span class="number">0x01DD45C6</span>, <span class="number">0x02DE45C6</span>, <span class="number">0x03DF45C6</span>, <span class="number">0x2CE045C6</span>, <span class="number">0x41E145C6</span>, <span class="number">0x4EE245C6</span>, <span class="number">0x20E345C6</span>,</span><br><span class="line">	<span class="number">0x10E445C6</span>, <span class="number">0x61E545C6</span>, <span class="number">0x36E645C6</span>, <span class="number">0x10E745C6</span>, <span class="number">0x2CE845C6</span>, <span class="number">0x34E945C6</span>, <span class="number">0x20EA45C6</span>, <span class="number">0x40EB45C6</span>,</span><br><span class="line">	<span class="number">0x59EC45C6</span>, <span class="number">0x2DED45C6</span>, <span class="number">0x20EE45C6</span>, <span class="number">0x41EF45C6</span>, <span class="number">0x0FF045C6</span>, <span class="number">0x22F145C6</span>, <span class="number">0x12F245C6</span>, <span class="number">0x10F345C6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_88[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x7b000000</span>, <span class="number">0x20000000</span>, <span class="number">0x12000000</span>, <span class="number">0x62000000</span>, <span class="number">0x77000000</span>, <span class="number">0x6C000000</span>, <span class="number">0x41000000</span>, <span class="number">0x29000000</span>,<span class="comment">//手动补的</span></span><br><span class="line">	<span class="number">0x7C8045C6</span>, <span class="number">0x508145C6</span>, <span class="number">0x7D8245C6</span>, <span class="number">0x268345C6</span>, <span class="number">0x7C8445C6</span>, <span class="number">0x6F8545C6</span>, <span class="number">0x4A8645C6</span>, <span class="number">0x318745C6</span>,</span><br><span class="line">	<span class="number">0x538845C6</span>, <span class="number">0x6C8945C6</span>, <span class="number">0x5E8A45C6</span>, <span class="number">0x6C8B45C6</span>, <span class="number">0x548C45C6</span>, <span class="number">0x068D45C6</span>, <span class="number">0x608E45C6</span>, <span class="number">0x538F45C6</span>,</span><br><span class="line">	<span class="number">0x2C9045C6</span>, <span class="number">0x799145C6</span>, <span class="number">0x689245C6</span>, <span class="number">0x6E9345C6</span>, <span class="number">0x209445C6</span>, <span class="number">0x5F9545C6</span>, <span class="number">0x759645C6</span>, <span class="number">0x659745C6</span>,</span><br><span class="line">	<span class="number">0x639845C6</span>, <span class="number">0x7B9945C6</span>, <span class="number">0x7F9A45C6</span>, <span class="number">0x779B45C6</span>, <span class="number">0x609C45C6</span>, <span class="number">0x309D45C6</span>, <span class="number">0x6B9E45C6</span>, <span class="number">0x479F45C6</span>,</span><br><span class="line">	<span class="number">0x5CA045C6</span>, <span class="number">0x1DA145C6</span>, <span class="number">0x51A245C6</span>, <span class="number">0x6BA345C6</span>, <span class="number">0x5AA445C6</span>, <span class="number">0x55A545C6</span>, <span class="number">0x40A645C6</span>, <span class="number">0x0CA745C6</span>,</span><br><span class="line">	<span class="number">0x2BA845C6</span>, <span class="number">0x4CA945C6</span>, <span class="number">0x56AA45C6</span>, <span class="number">0x0DAB45C6</span>, <span class="number">0x72AC45C6</span>, <span class="number">0x01AD45C6</span>, <span class="number">0x75AE45C6</span>, <span class="number">0x7EAF45C6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; <span class="title function_">preprocesser</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> arr[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; <span class="title function_">v</span><span class="params">(length)</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">		v[i] = arr[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; result = preprocesser(var_44, <span class="number">56</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; key = preprocesser(var_88, <span class="number">56</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; ++i) &#123;</span><br><span class="line">		result[i] = result[i] ^ key[i] ^ <span class="number">0x13</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (<span class="type">char</span>)result[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hellocctf">008Helloc,CTF</h2>
<h3 id="没见过的指令">没见过的指令</h3>
<p>在分析之前,补几个指令</p>
<p>关于CSAPP上没有见过的指令</p>
<p>1.rep/repne</p>
<p>2.movsd/movsw/movsb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep movsd               ; 没有见过的指令</span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查阅<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27804852/assembly-rep-movs-mechanism">x86
- Assembly: REP MOVS mechanism - Stack Overflow</a></p>
<p>According to <a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff561504(v=vs.85).aspx">MSDN</a>,
"The instruction can be prefixed by REP to repeat the operation the
number of times specified by the ecx register."</p>
<p>rep的操作数是一个指令,rep的作用是将该指令重复若干次,以ecx中的数字为重复次数,(每次ecx中的数字-1直到归零)</p>
<p>repne 当ecx!=0且ZF!=0,重复执行后边的指令,每执行一次ecx的值减1</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506171358295.png"
alt="image-20220506171358295" />
<figcaption aria-hidden="true">image-20220506171358295</figcaption>
</figure>
</blockquote>
<p>3.stosd/stosw/stosb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep stosd</span><br><span class="line">stosw</span><br><span class="line">stosb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI
中偏移量指向的内存位置。</p>
<p>EDI 根据方向标志位的状态递增或递减。</p>
</blockquote>
<p>4.scasd/scasw/scasb</p>
<blockquote>
<p>SCASB、SCASW 和 SCASD 指令分别将 AL/AX/EAX 中的值与 EDI
寻址的一个字节 / 字 / 双字进行比较。</p>
<p>这些指令可用于在字符串或数组中寻找一个数值。</p>
<p>结合 REPE（或 REPZ）前缀，当 ECX &gt; 0 且 AL/AX/EAX
的值等于内存中每个连续的值时，不断扫描字符串或数组。</p>
</blockquote>
<h3 id="收集信息">收集信息</h3>
<p>输入比较短的字符串会报告wrong!然后让重新输入,输入很长的字符串报告wrong!之后程序退出</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506163947900.png"
alt="image-20220506163947900" />
<figcaption aria-hidden="true">image-20220506163947900</figcaption>
</figure>
<p>ida打开之后</p>
<p>main函数开端部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mov     esi, offset a437261636b4d65 ; &quot;437261636b4d654a757374466f7246756e&quot;</span><br><span class="line">lea     edi, [esp+70h+var_24]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里有一串16进制编码,其他不管先解一下,<code>CrackMeJustForFun</code>"撬我只是为了娱乐",看上去是有一定语言意义的,作为flag交上去试试就对了</p>
<h3 id="反汇编分析">反汇编分析</h3>
<p>下面分析一下程序都干了啥</p>
<h4 id="开端-1">开端</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">sub     esp, 60h</span><br><span class="line">mov     ecx, 8			</span><br><span class="line">push    ebx;寄存器值保存</span><br><span class="line">push    ebp</span><br><span class="line">push    esi</span><br><span class="line">push    edi</span><br><span class="line"></span><br><span class="line">mov     esi, offset a437261636b4d65 ; esi存放flag的地址</span><br><span class="line">lea     edi, [esp+70h+var_24] ; &amp;var_24-&gt;edi</span><br><span class="line">rep movsd               ;ecx事先放好了8,这里重复执行movsd八次</span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<p>这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep movsd  </span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三句话,让我蒙蔽了18分钟,我真是一个计组学的一塌糊涂的虚蛋</p>
<p>参考博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33443333/article/details/113010189">标志寄存器df_标志寄存器_shikaao14的博客-CSDN博客</a></p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506171615659.png" /></p>
<p>这里干了一个字符串拷贝的事情,<code>offset a437261636b4d65</code>这个位置的字符串作为源,<code>esp+70h+var_24</code>这个位置的缓冲区作为目的进行拷贝.</p>
<p>为什么用到了三条指令?</p>
<p>源串:<code>437261636b4d654a757374466f7246756e</code>共占用了35字节
<span class="math display">\[
35\div 4=8··\ ·3
\]</span>
首先<code>rep movsd</code>重复8次,每次拷贝4字节,一共拷贝了32字节,剩下了3个字节,拆成一个字用movsw然后最后一个字节用movsb</p>
</blockquote>
<p>上述部分做的就是拷贝.data上的字符串到栈上<code>var_24</code>开始的35个字节</p>
<p>下面进入循环体</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506181931623.png"
alt="image-20220506181931623" />
<figcaption aria-hidden="true">image-20220506181931623</figcaption>
</figure>
<h4 id="外循环外侧蓝线">外循环(外侧蓝线)</h4>
<p>这个循环体的结构很容易猜想,收集信息时我们知道如果输入字符数比较少则程序会一直重复运行,不存在循环变量,终止条件之类.因此循环体完全可以按照单独一次执行进行饭分析</p>
<h5 id="loc_40101a"><code>loc_40101A</code></h5>
<p>这是循环体的起始部分</p>
<p>一些参数及其函数调用距离太远不直观,这里调整了一些语句位置,但是不改变程序逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">loc_40101A:</span><br><span class="line">mov     ecx, 8				;rep的帮凶</span><br><span class="line">xor     eax, eax			;eax归零</span><br><span class="line">lea     edi, [esp+70h+var_48] ; edi指向了&amp;var_48</span><br><span class="line">rep stosd					;STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI 中偏移量指向的内存位置。</span><br><span class="line">stosw</span><br><span class="line">stosb</span><br><span class="line">;eax被xor指令清零了,那么这里三条指令的作用是让var_48开始的35字节的栈空间置0</span><br><span class="line"></span><br><span class="line">;打印第一句废话</span><br><span class="line">push    offset aPleaseInputYou ; &quot;please input your serial:&quot;</span><br><span class="line">call    _printf</span><br><span class="line"></span><br><span class="line">;准备获取用户输入</span><br><span class="line">lea     eax, [esp+74h+var_5C]	;eax指向&amp;var_5C</span><br><span class="line">push    eax             ;&amp;var_5C压栈作为scanf的缓冲区</span><br><span class="line">push    offset aS       ; &quot;%s&quot;压栈作为第一个参数</span><br><span class="line">call    _scanf</span><br><span class="line"></span><br><span class="line">;检查是否给了太多字符</span><br><span class="line">lea     edi, [esp+7Ch+var_5C] ; &amp;var_5C-&gt;edi</span><br><span class="line">or      ecx, 0FFFFFFFFh ; ecx置全1</span><br><span class="line">xor     eax, eax		;eax归零,如果eax为0则ZF置零,eax存放scanf返回值,即实际输入字符数</span><br><span class="line">add     esp, 0Ch		;退栈12字节,不会修改ZF位</span><br><span class="line">repne scasb				;ecx中全是1,相当于无限大,只要scanf有输入则repne成立;从var_5C指向的缓冲区中寻找0(eax中放的是0),每次ecx-1</span><br><span class="line">not     ecx             ;ecx取反</span><br><span class="line">dec     ecx             ;ecx-1</span><br><span class="line">cmp     ecx, 11h        ;检查ecx和11h=17的大小</span><br><span class="line"></span><br><span class="line">ja      loc_40110D		;跳转则寄</span><br><span class="line"></span><br><span class="line">xor     ebx, ebx		;ebx寄存器归零,在loc_40101A的结尾干了这么一件事,不明觉厉,实际上是为后来的内圈循环初始化循环变量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查输入字符数是怎样实现的?</p>
<p>1.第25行的<code>scasb</code>从edi指向的缓冲区检查,是否存在eax中的字符,因此之前(第21行)就安置好了edi<code>lea     edi, [esp+7Ch+var_5C]</code></p>
<p>2.22行ecx置全1,需要减<code>2^8</code>次才能归零,因此该条件对第25行的repne指令没有限制作用</p>
<p>3.23行eax中是scanf的返回值,根据其值置ZF位(假设scanf获取到了输入,则eax不为0,则ZF为0),然后eax归零</p>
<p>4.24行退栈啥作用不知道,推测一开始预先多开了一些栈空间,可能是防止栈缓冲区溢出</p>
<p>5.25行repne成立的条件是<code>ecx!=0,ZF!=1</code>显然当scanf有获取到输入时是成立的,重复执行scasb,即在edi指向的<code>&amp;var_5C</code>中寻找eax中存放的值<code>0</code>,即寻找<code>var_5C</code>的结束字符,每次ecx-1</p>
<p>6.26行ecx取反,然后第27行ecx-1,啥作用呢?</p>
<blockquote>
<p>假设输入了ABC就三个字符,scanf返回后eax存3,<code>var_5C=&#123;'A','B','C',0,0,...,0&#125;</code>,</p>
<p>此时repne条件成立,在第四次检查时检查到0,目前的值为0xFFFFFFFB</p>
<p>然后ecx取反得到0b0100=4</p>
<p>然后ecx-1=3即输入字符数</p>
</blockquote>
<p>即这两步执行完后ecx存放输入字符数</p>
<p>7.28行ecx和11h进行比较,如果ecx中的值大则跳转loc_40110D,即判断输入字符是否超过了11h=17个,</p>
<p>而我们一开始收集到的信息也是字符数很多时直接程序退出</p>
<p>8.loc_40110D作用是报告失败</p>
</blockquote>
<p><code>loc_40101A</code>的作用就是获取输入并检查输入长度是否超过17字节,超过则寄,没超过则进一步检查</p>
<h5 id="loc_40105f内侧绿线"><code>loc_40105F</code>(内侧绿线)</h5>
<blockquote>
<p>在研究该部分之前,先要弄明白<code>sprintf</code>函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506184650282.png"
alt="image-20220506184650282" />
<figcaption aria-hidden="true">image-20220506184650282</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>
<p>返回值是实际str接收到的字符数,将源缓冲区从基地址到'\0'以某种格式输出到str目的缓冲区</p>
</blockquote>
<p>内圈循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">loc_40105F:</span><br><span class="line">mov     al, [esp+ebx+70h+var_5C]	;在进入循环体之前,loc_40101A最的最后,ebx置零,这里又和var_5C结合使用,可以大胆推测这是一个基址变址寻址,基址是esp+70h+var_5c即&amp;var_5C,变址即偏移量ebx,以后都记作i</span><br><span class="line">test    al, al					</span><br><span class="line">jz      short loc_4010B0			;如果var_5c[i]为0即i遍历到var_5c字符串的末尾则跳转loc_4010B0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;如果jz条件跳转未实现则var_5C[i]!=0即不是字符串末尾</span><br><span class="line">;以下将var_5C处的字符串转化成16进制格式的字符串然后放到var_48位置</span><br><span class="line"></span><br><span class="line">;将var_5c[i]转化成16进制字符串,放到buffer</span><br><span class="line">movsx   ecx, al						;var_5c[i]-&gt;ecx	;字节拓展双字</span><br><span class="line">push    ecx							;var_5c[i]-&gt;ecx-&gt;压栈作为参数</span><br><span class="line">lea     edx, [esp+74h+Buffer]		 ;&amp;Buffer-&gt;edx,			;Buffer是栈上两个字节</span><br><span class="line">push    offset Format   ; &quot;%x&quot;		  ;%x压栈作为参数</span><br><span class="line">push    edx             ; Buffer	  ;&amp;Buffer-&gt;edx-&gt;压栈作为参数</span><br><span class="line">call    _sprintf					;sprintf(&amp;Buffer,&quot;%x&quot;,&amp;var_5c[i]),返回值(写入字符总数)放eax</span><br><span class="line">							;这里sprintf函数把var_5c[i]以十六进制字符格式转换成字符串放到Buffer</span><br><span class="line">							;(Buffer两个字节,一个ascii码的16进制字符串也是两个字节)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea     edi, [esp+7Ch+Buffer]		 ;&amp;Buffer-&gt;edi</span><br><span class="line">or      ecx, 0FFFFFFFFh				;ecx置全1</span><br><span class="line">xor     eax, eax					;根据eax置ZF,然后eax置零</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">repne scasb							;寻找buffer的结束位置</span><br><span class="line">not     ecx							;ecx存放buffer的结束字符下标</span><br><span class="line">sub     edi, ecx					;edi-ecx之后edi回退到Buffer起始位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;下面加载var_48并确定其末尾位置</span><br><span class="line">lea     edx, [esp+70h+var_48]		 ;&amp;var_48-&gt;edx,		;var_48是栈上一个32字节的缓冲区</span><br><span class="line">mov     ebp, ecx					;ebp暂时保存之前的ecx</span><br><span class="line">or      ecx, 0FFFFFFFFh</span><br><span class="line"></span><br><span class="line">mov     esi, edi					;edi存放Buffer基地址,放到esi</span><br><span class="line">mov     edi, edx					;edx存放var_48基地址,放到edi		</span><br><span class="line"></span><br><span class="line">repne scasb							;寻找edi中var_48串的结束字符位置</span><br><span class="line">dec     edi							;减1后edi指向var_48的最后一个字符</span><br><span class="line"></span><br><span class="line">;这里看似是蜜汁操作,啥也没干,但是我感觉是因为没有用编译优化,编译器在将Buffer向var_48拷贝的时候,没有考虑Buffer的长度,而是假设Buffer是一个不知长度的字符串,先以最大效率双字拷贝,然后最后剩下的不足双字的1或者2或者3个字节使用字节拷贝</span><br><span class="line">;这蜜汁操作想了一下午才想明白</span><br><span class="line">mov     ecx, ebp					;ebp把之前暂时保存的值还给ecx</span><br><span class="line">shr     ecx, 2						;ecx之前存放buffer结束字符下标,现在/4必然是0</span><br><span class="line">rep movsd							;按双字拷贝,但是Buffer长度/4=0,因此实际上这三句话啥也没干</span><br><span class="line"></span><br><span class="line">mov     ecx, ebp					;ebp把之前暂时保存的值还给ecx</span><br><span class="line">and     ecx, 3						;ecx保留低2位(模4余数)</span><br><span class="line">rep movsb							;Buffer按字节拷贝到var_48</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc     ebx							;++i;</span><br><span class="line">cmp     ebx, 11h					;判断i是否遍历完了var_5C</span><br><span class="line">jl      short loc_40105F			;如果i&lt;17则跳到本部分开头重新内圈循环,如果i&gt;=17则意味着遍历完毕,跳出内圈循环</span><br></pre></td></tr></table></figure>
<p>内圈循环做的就是将var_5c存放的串换成16进制格式,输出到var_48位置的串,以Buffer作为转换过渡</p>
<p><code>var_5c[i]--sprintf--&gt;Buffer--strcat--&gt;var_48</code></p>
<h5 id="loc_4040b0"><code>loc_4040B0</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loc_4010B0:	</span><br><span class="line">lea     esi, [esp+70h+var_24]		;var_24事先放好了flag的16进制表示					&amp;var_24-&gt;esi</span><br><span class="line">lea     eax, [esp+70h+var_48]		;var_48是刚才内圈循环时将输入转换成16进制串的表示	 &amp;var_28-&gt;eax</span><br></pre></td></tr></table></figure>
<p>两个16进制数都放好了,可想而知下面要对两个数比较判断是否相同了,显然直接调用strcmp这种函数太过于明显,可能会采用逐个字节比较的方式</p>
<p>但是这样也比较容易发现,</p>
<p>当比较完了<code>*var_24</code>和<code>*var_48</code>即<code>var_24[0]</code>和<code>var_48[0]</code>之后,如果要继续比较<code>var_24[1]</code>和<code>var_48[1]</code>,需要移动一下指针,即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc esi;</span><br><span class="line">inc eax;</span><br></pre></td></tr></table></figure>
<p>这类的指令</p>
<h5 id="loc_4010b8"><code>loc_4010B8</code></h5>
<p>按照刚才的猜想,这里应该有一个循环,实际上也是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506205727285.png"
alt="image-20220506205727285" />
<figcaption aria-hidden="true">image-20220506205727285</figcaption>
</figure>
<p>我们很容易就在<code>.text:004010D2</code>找到了移动指针的语句,只不过是一次性移动两位,因为前面比较了两位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:004010B8 loc_4010B8:                             ; CODE XREF: _main+DA↓j</span><br><span class="line">.text:004010B8                 mov     dl, [eax]			;解引用</span><br><span class="line">.text:004010BA                 mov     bl, [esi]</span><br><span class="line">.text:004010BC                 mov     cl, dl</span><br><span class="line">.text:004010BE                 cmp     dl, bl</span><br><span class="line">.text:004010C0                 jnz     short loc_4010E0		;这个跳转通向 寄 ,如果不让他跳则dl和bl要相同,即两个串对应字符相同</span><br><span class="line">.text:004010C2                 test    cl, cl				;如果cl是0说明指针已经移动到空了,应当跳出循环</span><br><span class="line">.text:004010C4                 jz      short loc_4010DC		;跳出循环,通向 成功</span><br><span class="line">.text:004010C6                 mov     dl, [eax+1]			;一次性比较两个字符</span><br><span class="line">.text:004010C9                 mov     bl, [esi+1]			</span><br><span class="line">.text:004010CC                 mov     cl, dl</span><br><span class="line">.text:004010CE                 cmp     dl, bl</span><br><span class="line">.text:004010D0                 jnz     short loc_4010E0		;跳转就寄</span><br><span class="line">.text:004010D2                 add     eax, 2					;移动指针</span><br><span class="line">.text:004010D5                 add     esi, 2</span><br><span class="line">.text:004010D8                 test    cl, cl</span><br><span class="line">.text:004010DA                 jnz     short loc_4010B8		;本次两个字符都相同,继续循环判断下两个字符是否相同</span><br></pre></td></tr></table></figure>
<h5 id="尾声-1">尾声</h5>
<p>从刚才的循环出来就能够决定命运了,刚才的循环有两种跳转,一是<code>loc_4010DC</code>,另一个是<code>loc_4010E0</code></p>
<p>其中<code>loc_4010DC</code>将eax置零</p>
<p><code>loc_4010E0</code>将eax置-1</p>
<p>然后两路殊途同归到<code>loc_4010E5</code></p>
<p>而<code>loc_4010E5</code>是一个法官,只有eax值为0才让打印成功</p>
<p>如果eax值不为0则跳转<code>loc_4010FB</code>寄</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506205845976.png"
alt="image-20220506205845976" />
<figcaption aria-hidden="true">image-20220506205845976</figcaption>
</figure>
<h2 id="opensource">009opensource</h2>
<p>给出的是一段c程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;<span class="comment">//要求argc=4,argv[0]是自带的程序位置,剩下即要输入3个参数</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);<span class="comment">//第一个参数转化成字符串</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;<span class="comment">//要求first=51966</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);<span class="comment">//second为第二个参数转化成字符串</span></span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;<span class="comment">//要求second 模5不余三,模17余8</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;<span class="comment">//要求argv[3]=&quot;h4cky0u&quot;,长度为7</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line">	<span class="comment">//second%17=8,strlen(argv[3])=7</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个参数可以为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">51966</span> <span class="number">25</span>  h4cky0u</span><br></pre></td></tr></table></figure>
<p>编译之后运行一下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\xctf12\opensource&gt; ./opensource 51966 25  h4cky0u</span><br><span class="line">Brr wrrr grr</span><br><span class="line">Get your key: c0ffee</span><br></pre></td></tr></table></figure>
<h2 id="no-strings-attached">010no-strings-attached</h2>
<p>尽量不依赖工具,比如ida-F5的伪代码,那么应该在以什么为基础进行分析呢?</p>
<p>objdump和ida的反汇编视图起码是可以的,没有必要和0和1组成的二进制码打交道,直接看反汇编即可</p>
<p>ida反汇编的图视图也是可以接受的,毕竟有了反汇编之后我们也可以轻松画出跳转关系和调用关系图,不妨让ida代劳了</p>
<p>ida-F5伪代码可以吗?</p>
<p>如果我能够轻松地将反汇编翻译成伪代码或者代码,那何乐而不为?但是我没这本事.</p>
<p>如果每个题上来就看伪代码对于从反汇编到伪代码的翻译是没有帮助的.</p>
<p>因此我觉得逆向分析应当基于反汇编和图视图,尽量少<del>沉迷美色</del>看伪代码</p>
<p>对于<code>no-strings-attached</code>这个ctf逆向题,前置知识:</p>
<p><code>x86</code>汇编语言(如果不看伪代码的话)</p>
<p>==宽字符==</p>
<p>置换加密算法</p>
<p>ida的使用</p>
<h3 id="main函数-1"><code>main</code>函数</h3>
<p>main函数下调用了四个函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504202713613.png"
alt="image-20220504202713613" />
<figcaption aria-hidden="true">image-20220504202713613</figcaption>
</figure>
<p><code>_setlocale</code>是使用者的区域设定,比如时间,语言之类的,没有卵用</p>
<p><code>banner,prompt_authentication</code>都是打印一些语句作为提示,也没有锤子用</p>
<p><code>authenticate</code>关键在这里</p>
<h3 id="authenticate函数"><code>authenticate</code>函数</h3>
<p>粗略浏览该函数,发现有一个<code>call decrypt</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504202933305.png"
alt="image-20220504202933305" />
<figcaption aria-hidden="true">image-20220504202933305</figcaption>
</figure>
<p>单就从<code>decrypt</code>,这种"解密"名字的函数就应该是关键函数,<code>authenticate</code>的其他部分先不管,直接看<code>decrypt</code>,</p>
<p>another(rename之后的名字)和s分别作为第二个和第一个参数传递给了<code>decrypt</code>函数</p>
<h3 id="decrypt函数"><code>decrypt</code>函数</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504203108886.png"
alt="image-20220504203108886" />
<figcaption aria-hidden="true">image-20220504203108886</figcaption>
</figure>
<p>框框相连,转转不已,也不知道套了多少层循环了</p>
<p>首先按照CSAPP第三章的方法,将汇编翻译成带goto的c伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *another)</span>&#123;</span><br><span class="line">    <span class="type">int</span> slength=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> anotherlength=<span class="built_in">strlen</span>(another);</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">int</span> *)<span class="built_in">malloc</span>(slength+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="keyword">goto</span> loc_80486F7;</span><br><span class="line">    loc_80486AF:</span><br><span class="line">        <span class="type">int</span> var_18=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> loc_80486E7;</span><br><span class="line"></span><br><span class="line">    loc_80486B8:</span><br><span class="line">        dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">        ++var_1C;</span><br><span class="line">        ++var_18;</span><br><span class="line"></span><br><span class="line">    loc_80486E7:<span class="comment">//这一块的分析是比较繁琐的</span></span><br><span class="line">        <span class="keyword">if</span>(var_18&lt;anotherlength&amp;&amp;var_1C&lt;slength)&#123;</span><br><span class="line">            <span class="keyword">goto</span> loc_80486B8;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    loc_80486F7:</span><br><span class="line">        <span class="keyword">if</span>(var_1C&gt;=slength)&#123;</span><br><span class="line">            <span class="keyword">return</span> dest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">goto</span> loc_80486AF;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>loc_80486E7的分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:080486B8 loc_80486B8:                            ; CODE XREF: decrypt+9D↓j</span><br><span class="line">.text:080486B8                 mov     eax, [ebp+var_1C] </span><br><span class="line">.text:080486BB                 shl     eax, 2          </span><br><span class="line">.text:080486BE                 add     eax, [ebp+dest]      ;dest+4*var_1C-&gt;eax</span><br><span class="line">.text:080486C1                 mov     edx, [ebp+var_1C]    </span><br><span class="line">.text:080486C4                 shl     edx, 2</span><br><span class="line">.text:080486C7                 add     edx, [ebp+dest]      ;dest+4*var_1C-&gt;edx</span><br><span class="line">.text:080486CA                 mov     ecx, [edx]           ;[dest+4*var_1C]-&gt;ecx</span><br><span class="line">.text:080486CC                 mov     edx, [ebp+var_18]</span><br><span class="line">.text:080486CF                 shl     edx, 2</span><br><span class="line">.text:080486D2                 add     edx, [ebp+another]   ;another+4*var_18-&gt;edx</span><br><span class="line">.text:080486D5                 mov     edx, [edx]           ;[another+4*var_18]-&gt;edx</span><br><span class="line">.text:080486D7                 mov     ebx, ecx             ;[dest+4*var_1C]-&gt;ebx</span><br><span class="line">.text:080486D9                 sub     ebx, edx             ;[dest+4*var_1C]-[another+4*var_18]-&gt;ebx</span><br><span class="line">.text:080486DB                 mov     edx, ebx             ;[dest+4*var_1C]-[another+4*var_18]-&gt;ebx-&gt;dex</span><br><span class="line">.text:080486DD                 mov     [eax], edx           ;[dest+4*var_1C]=[dest+4*var_1C]-[another+4*var_18]</span><br><span class="line">.text:080486DF                 add     [ebp+var_1C], 1      ;++var_1C</span><br><span class="line">.text:080486E3                 add     [ebp+var_18], 1      ;++var_18</span><br></pre></td></tr></table></figure>
<p>这么一长段用源代码表示就干了稀松的事情</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loc_80486B8:</span><br><span class="line">    dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">    ++var_1C;</span><br><span class="line">    ++var_18;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后翻译成不带goto的c代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *another)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="type">int</span> var_18=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> var_1C=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var_1C&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">        var_18=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(var_18&lt;<span class="built_in">strlen</span>(another)&amp;&amp;var_1C&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">            dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">            ++var_1C;</span><br><span class="line">            ++var_18;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里两层while循环到底干了一个什么事呢?再进一步精简一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *key)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);++i)&#123;</span><br><span class="line">        index=i%<span class="built_in">strlen</span>(key);<span class="comment">//计算s[i]应该减去的key数组中的哪一个元素</span></span><br><span class="line">        dest[i]-=another[index];<span class="comment">//位移密码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个位移密码解密,s是需要解密的字符串,算法是用s
的每一个字符去减key的相应位置的字符,如果key不够长则key循环使用</p>
<h3 id="回到authenticate函数">回到<code>authenticate</code>函数</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504201120562.png"
alt="image-20220504201120562" />
<figcaption aria-hidden="true">image-20220504201120562</figcaption>
</figure>
<p>这个函数还怪长的,不看F5伪代码,应当如何解读呢?</p>
<p>首先,在分析完decrypt函数之后,我们大体上可以知道,<strong>密文和密钥都是在<code>.rodata</code>只读区存好的,然后通过decrypt解密算法得到加密前的明文,下面要做的应该是获取键盘输入,然后将刚才的明文和键盘输入进行对比</strong></p>
<p>至于为什么不直接存储明文然后和获取的键盘输入进行对比?这就好比给一个孩子一艘拼装好的乐高千年隼和一盒子千年隼零件的关系</p>
<p>考察孩子对加密算法的掌握,以及对加密算法汇编形式的掌握呗</p>
<p>然后,基于上述分析,可以推测authenticate函数要做的,大体可以分为四或者五个部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.开端(任何函数都有,通常是压栈保存调用者函数的帧指针rbp,申请函数栈,rbp作为当前函数帧指针)</span><br><span class="line">1.解密</span><br><span class="line">2.输入</span><br><span class="line">3.处理输入(可以算是输入的一部分)</span><br><span class="line">4.字符串对比</span><br><span class="line">5.尾声(任何函数都有,通常是释放函数栈和退栈还原rbp为调用者函数的帧指针)</span><br></pre></td></tr></table></figure>
<p>顺序不一定,但是也就是这几件事了,想不出来还能干什么</p>
<p>实际分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">;0.开端</span><br><span class="line">.text:08048708                 push    ebp</span><br><span class="line">.text:08048709                 mov     ebp, esp</span><br><span class="line">.text:0804870B                 sub     esp, 8028h</span><br><span class="line"></span><br><span class="line">;1.解密获得字符串</span><br><span class="line">.text:08048711                 mov     dword ptr [esp+4], offset another ; another表示密钥,其地址压栈作为第二个参数</span><br><span class="line">.text:08048719                 mov     dword ptr [esp], offset s ; s     ; s表示需要解密的字符串,地址压栈作为参数</span><br><span class="line">.text:08048720                 call    decrypt                           ; 调用decrypt,他需要两个参数</span><br><span class="line">.text:08048725                 mov     [ebp+s2], eax                     ; decrypt返回值-&gt;eax-&gt;s2</span><br><span class="line"></span><br><span class="line">;2.键盘获得输入字符串</span><br><span class="line">.text:08048728                 mov     eax, ds:stdin@@GLIBC_2_0          ;标准键盘输入</span><br><span class="line">.text:0804872D                 mov     [esp+8], eax    ; stream          ;stdin-&gt;eax-&gt;[esp+8]作为第三个参数</span><br><span class="line">.text:08048731                 mov     dword ptr [esp+4], 2000h ; n      ;2000h-&gt;[esp+4]作为第二个参数</span><br><span class="line">.text:08048739                 lea     eax, [ebp+ws]                     ;ws-&gt;eax</span><br><span class="line">.text:0804873F                 mov     [esp], eax      ; ws              ;ws-&gt;eax-&gt;[esp]作为第一个参数</span><br><span class="line">.text:08048742                 call    _fgetws                           ;fgetws函数共需要三个参数,都已经妥善安置入栈</span><br><span class="line"></span><br><span class="line">;3.处理键盘输入</span><br><span class="line">.text:08048747                 test    eax, eax                          ;判断是否读取到至少一个字符</span><br><span class="line">;3.1如果没有获取到输入</span><br><span class="line">.text:08048749                 jz      short loc_804879C                 ;啥也没读到,跳转loc_804879C尾声</span><br><span class="line">;3.2如果获取到了输入</span><br><span class="line">.text:0804874B                 lea     eax, [ebp+ws]                     ;&amp;ws-&gt;eax</span><br><span class="line">.text:08048751                 mov     [esp], eax      ; s               ;&amp;ws-&gt;eax-&gt;[esp]压栈作为参数</span><br><span class="line">.text:08048754                 call    _wcslen                           ;&amp;ws作为参数压栈,传递给_wcslen</span><br><span class="line">.text:08048759                 sub     eax, 1                            ;strlen(ws)-1-&gt;eax</span><br><span class="line">.text:0804875C                 mov     [ebp+eax*4+ws], 0                 ;ws[strlen(ws)-1]=&#x27;\0&#x27;</span><br><span class="line"></span><br><span class="line">; 4.上述两个字符串比较</span><br><span class="line">.text:08048767                 mov     eax, [ebp+s2]                     ;decrypt返回值-&gt;s2-&gt;eax</span><br><span class="line">.text:0804876A                 mov     [esp+4], eax    ; s2              ;decrypt返回值压栈,作为第二个参数</span><br><span class="line">.text:0804876E                 lea     eax, [ebp+ws]                     ;&amp;ws-&gt;eax</span><br><span class="line">.text:08048774                 mov     [esp], eax      ; s1              ;&amp;ws-&gt;eax-&gt;[esp],作为第一个参数</span><br><span class="line">.text:08048777                 call    _wcscmp                           ;类似strcmp,输入字符串和解密后字符串比较</span><br><span class="line">.text:0804877C                 test    eax, eax                          ;判断strcmp是否返回0</span><br><span class="line">; 4.1如果不为0则两个字符串不相等</span><br><span class="line">.text:0804877E                 jnz     short loc_804878F                 ;如果不为0则跳转loc_804878F</span><br><span class="line">; 4.2否哦则即0表明两个字符串相等</span><br><span class="line">.text:08048780                 mov     eax, offset unk_8048B44           ;&amp;&quot;success welcome back&quot;-&gt;eax</span><br><span class="line">.text:08048785                 mov     [esp], eax                        ;&quot;success&quot;-&gt;[esp],作为参数</span><br><span class="line">.text:08048788                 call    _wprintf                          ;打印</span><br><span class="line">.text:0804878D                 jmp     short loc_804879C                 ;跳转尾声</span><br><span class="line">; 4.1续</span><br><span class="line">.text:0804878F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804878F</span><br><span class="line">.text:0804878F loc_804878F:                            ; CODE XREF: authenticate+76↑j</span><br><span class="line">.text:0804878F                 mov     eax, offset unk_8048BA4           ;&amp;&quot;Access denied&quot;-&gt;eax</span><br><span class="line">.text:08048794                 mov     [esp], eax                        ;eax-&gt;[esp]作为参数</span><br><span class="line">.text:08048797                 call    _wprintf                          ;打印</span><br><span class="line">.text:0804879C</span><br><span class="line"></span><br><span class="line">;尾声</span><br><span class="line">.text:0804879C loc_804879C:                            ; CODE XREF: authenticate+41↑j</span><br><span class="line">.text:0804879C                                         ; authenticate+85↑j</span><br><span class="line">.text:0804879C                 mov     eax, [ebp+s2]</span><br><span class="line">.text:0804879F                 mov     [esp], eax      ; ptr</span><br><span class="line">.text:080487A2                 call    _free</span><br><span class="line">.text:080487A7                 leave</span><br><span class="line">.text:080487A8                 retn</span><br><span class="line">.text:080487A8 ; &#125; // starts at 8048708</span><br><span class="line">.text:080487A8 authenticate    endp</span><br></pre></td></tr></table></figure>
<p>分析到此算是了解了authenticate的逻辑,但是有几点是我想继续研究的</p>
<h4 id="offset指令">1.<code>offset</code>指令?</h4>
<p><code>.text:08048711                 mov     dword ptr [esp+4], offset another ;</code>这里offset的作用是什么?</p>
<p>能问出这种问题来属实是我计组学的太虚了</p>
<p>首先参考了博客<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/x54256/p/8097963.html">汇编语言——转移指令（offset，jmp，jcxz）
- 想54256 - 博客园 (cnblogs.com)</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504204638327.png"
alt="image-20220504204638327" />
<figcaption aria-hidden="true">image-20220504204638327</figcaption>
</figure>
<p>又产生新问题,如果说<code>mov si,offset s</code>是将s的地址放到si寄存器中,那么为什么不用类似<code>lea si,[s]</code>的指令加载有效地址?</p>
<p>然后查阅了这篇博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/baoli1008/article/details/46691497">汇编语言LEA和OFFSET区别_Baoli1008的博客-CSDN博客_lea与offset的区别</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504204837123.png"
alt="image-20220504204837123" />
<figcaption aria-hidden="true">image-20220504204837123</figcaption>
</figure>
<p>数据定义伪指令:</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/20191220121930628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aW9uZzUzNS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"
alt="数据定义伪指令" />
<figcaption aria-hidden="true">数据定义伪指令</figcaption>
</figure>
<h4
id="fgetwsfgets函数的区别">2.<code>fgetws,fgets</code>函数的区别?</h4>
<p>参考<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/cpp/c-runtime-library/reference/fgets-fgetws?view=msvc-170">fgets、fgetws
| Microsoft Docs</a></p>
<p>相同点:</p>
<p>两个函数都有三个参数,从左向右分别为:数据存储位置,要读取的最大字符数,FILE结构体指针.</p>
<p>返回值都是实际读取到的字符数</p>
<p>不同点:</p>
<p><strong><code>fgetws</code></strong> 是
<strong><code>fgets</code></strong> 的宽字符版本。</p>
<h4 id="宽字符">宽字符?</h4>
<p>啥是宽字符?用多个<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/字节/1096318">字节</a>来代表的字符称之为宽字符。</p>
<p>unicode是宽字符之一,但是已经实际上成为了宽字符的具体实现方法,windows上的c语言宽字符就是unicode,用两个字节表示一个字符</p>
<p>ASCII码表用一共字节表示一个字符,一个字节的值有<code>2^8=256</code>种即ASCII码最多有256个,对于键盘上出现的所有字符已经足够了</p>
<p>但是对于汉字,法语,日语等等各种语言,ASCII能表示的字符数真的太逊了,</p>
<p>而unicode码两个字节表示一个字符,两个字节的值有<code>2^16&gt;60000</code>,</p>
<p>而相对比较复杂的汉字,大约就3000常用汉字,因此unicode是有能力表示地球上的各种字符的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504210716190.png"
alt="image-20220504210716190" />
<figcaption aria-hidden="true">image-20220504210716190</figcaption>
</figure>
<p>12345ABCDE一共10个字符,结尾还有一个'\0'字符,因此<code>char cstr</code>是11字节,<code>wchar_t wcstr</code>是22个字节</p>
<p>取<code>wchar_t</code>类型的数组长度的函数不是<code>strlen</code>,是<code>wcslen</code>,有多少个有意义的字符(不包括结尾'\0')wcslen函数就返回多少</p>
<p>宽字符类型的字符串字面量前需要有L修饰,不写会报错</p>
<p><code>[错误] cannot initialize array of 'wchar_t' 从 a string literal with type array of 'char'</code></p>
<p>unicode部分码表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align: left;">编码(十进制)</th>
<th>编码(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>小写字母(a~z)</td>
<td style="text-align: left;">97~122</td>
<td>61~7a</td>
</tr>
<tr>
<td>大写字母(A~Z)</td>
<td style="text-align: left;">65~90</td>
<td>41~5a</td>
</tr>
<tr>
<td>左右花括号{}</td>
<td style="text-align: left;">{123,125}</td>
<td>{7b,7d}</td>
</tr>
<tr>
<td>阿拉伯数字</td>
<td style="text-align: left;">48~57</td>
<td>30~39</td>
</tr>
</tbody>
</table>
<h4
id="事先存在的密文和密钥放在哪里access-denied等字样又放在那里">3.事先存在的密文和密钥放在哪里?<code>"Access denied"</code>等字样又放在那里?</h4>
<p>在authenticate函数里面双击s观察s的存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048AA8 ; const wchar_t s</span><br><span class="line">.rodata:08048AA8 s               db 3Ah                  ; DATA XREF: authenticate+11↑o</span><br><span class="line">.rodata:08048AA9                 db  14h</span><br><span class="line">.rodata:08048AAA                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AAB                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AAC                 dd 1436h</span><br><span class="line">.rodata:08048AB0                 db  37h ; 7</span><br><span class="line">.rodata:08048AB1                 db  14h</span><br><span class="line">.rodata:08048AB2                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AB3                 db    0</span><br><span class="line">.rodata:08048AB4                 db  3Bh ; ;</span><br><span class="line">.rodata:08048AB5                 db  14h</span><br><span class="line">.rodata:08048AB6                 db    0</span><br><span class="line">.rodata:08048AB7                 db    0</span><br><span class="line">.rodata:08048AB8                 db  80h</span><br><span class="line">.rodata:08048AB9                 db  14h</span><br><span class="line">.rodata:08048ABA                 db    0</span><br><span class="line">.rodata:08048ABB                 db    0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>.rodata</code>是常量区,在程序运行之前,在编译时就能确定</p>
<p>s是宽字符数组,每个元素都是<code>wchar_t</code>类型,占两个字节,小端存储的话就可以写为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1434 0000 0x1436 0000 0x1437....</span><br></pre></td></tr></table></figure>
<p>奇怪的是为什么其中会有很多0?为什么字符不能够紧凑存放?</p>
<p>能问出这种问题来属实是我c基础太差了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504235300627.png"
alt="image-20220504235300627" />
<figcaption aria-hidden="true">image-20220504235300627</figcaption>
</figure>
<p><code>sizeof('a')</code>和<code>sizeof(char)</code>的结果竟然不一样</p>
<p>查阅资料,<code>a</code>是<strong>字符常量</strong>,却以int四字节存储</p>
<p>因此对rodata段的s应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048AA8 s               db 3Ah                  ; DATA XREF: authenticate+11↑o</span><br><span class="line">.rodata:08048AA9                 db  14h</span><br><span class="line">.rodata:08048AAA                 db    0</span><br><span class="line">.rodata:08048AAB                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AAC                 db 36h</span><br><span class="line">.rodata:08048AAD                 db  14h</span><br><span class="line">.rodata:08048AAE                 db    0</span><br><span class="line">.rodata:08048AAF                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB0                 db  37h ; 7</span><br><span class="line">.rodata:08048AB1                 db  14h</span><br><span class="line">.rodata:08048AB2                 db    0</span><br><span class="line">.rodata:08048AB3                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB4                 db  3Bh ; ;</span><br><span class="line">.rodata:08048AB5                 db  14h</span><br><span class="line">.rodata:08048AB6                 db    0</span><br><span class="line">.rodata:08048AB7                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB8                 db  80h</span><br><span class="line">.rodata:08048AB9                 db  14h</span><br><span class="line">.rodata:08048ABA                 db    0</span><br><span class="line">.rodata:08048ABB                 db    0</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在IDA View视图上选中s的元素然后convert to array(DWORD)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504235955441.png"
alt="image-20220504235955441" />
<figcaption aria-hidden="true">image-20220504235955441</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x8048AA8</span> - <span class="number">0x8048B43</span> (<span class="number">155</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s[<span class="number">39</span>] = &#123;</span><br><span class="line">    <span class="number">0x0000143A</span>, <span class="number">0x00001436</span>, <span class="number">0x00001437</span>, <span class="number">0x0000143B</span>, <span class="number">0x00001480</span>, <span class="number">0x0000147A</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, </span><br><span class="line">    <span class="number">0x00001463</span>, <span class="number">0x00001466</span>, <span class="number">0x00001473</span>, <span class="number">0x00001467</span>, <span class="number">0x00001462</span>, <span class="number">0x00001465</span>, <span class="number">0x00001473</span>, <span class="number">0x00001460</span>, </span><br><span class="line">    <span class="number">0x0000146B</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001478</span>, </span><br><span class="line">    <span class="number">0x0000146E</span>, <span class="number">0x00001470</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x0000146E</span>, <span class="number">0x0000147B</span>, </span><br><span class="line">    <span class="number">0x00001476</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x0000147B</span>, <span class="number">0x00001480</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就得到了s数组</p>
<p>同样的道理another字符数组也位于.rodata区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x8048A90</span> - <span class="number">0x8048AA7</span> (<span class="number">23</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> another[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">0x00001401</span>, <span class="number">0x00001402</span>, <span class="number">0x00001403</span>, <span class="number">0x00001404</span>, <span class="number">0x00001405</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的道理,"Success..."等字样也位于.rodata区</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220505000407437.png"
alt="image-20220505000407437" />
<figcaption aria-hidden="true">image-20220505000407437</figcaption>
</figure>
<h3 id="解密">解密</h3>
<p>用c程序解密</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s[<span class="number">39</span>] = &#123;</span><br><span class="line">	<span class="number">0x0000143A</span>, <span class="number">0x00001436</span>, <span class="number">0x00001437</span>, <span class="number">0x0000143B</span>, <span class="number">0x00001480</span>, <span class="number">0x0000147A</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>,</span><br><span class="line">	<span class="number">0x00001463</span>, <span class="number">0x00001466</span>, <span class="number">0x00001473</span>, <span class="number">0x00001467</span>, <span class="number">0x00001462</span>, <span class="number">0x00001465</span>, <span class="number">0x00001473</span>, <span class="number">0x00001460</span>,</span><br><span class="line">	<span class="number">0x0000146B</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001478</span>,</span><br><span class="line">	<span class="number">0x0000146E</span>, <span class="number">0x00001470</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x0000146E</span>, <span class="number">0x0000147B</span>,</span><br><span class="line">	<span class="number">0x00001476</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x0000147B</span>, <span class="number">0x00001480</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> another[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">0x00001401</span>, <span class="number">0x00001402</span>, <span class="number">0x00001403</span>, <span class="number">0x00001404</span>, <span class="number">0x00001405</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++) &#123;</span><br><span class="line">		index = i % <span class="number">5</span>;</span><br><span class="line">		s[i] -= another[index];</span><br><span class="line">		swprintf(&amp;ans[i], <span class="string">L&quot;%s&quot;</span>, &amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ls&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9447&#123;you_are_an_international_mystery&#125;</span><br></pre></td></tr></table></figure>
<h2 id="csaw2013reversing2">011csaw2013reversing2</h2>
<h3 id="信息收集-3">信息收集</h3>
<p>运行程序之后直接弹窗,推测是一个win32API-messageBox</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506092936536.png"
alt="image-20220506092936536" />
<figcaption aria-hidden="true">image-20220506092936536</figcaption>
</figure>
<p>上面都是写的乱码,下面三个选择框都导致程序结束</p>
<h3 id="静态分析-2">静态分析</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/critical.png"
alt="critical" />
<figcaption aria-hidden="true">critical</figcaption>
</figure>
<p>正常运行时执行左侧逻辑,但是左侧逻辑就是用win32API-messageBox显示了一些乱码,没有卵用</p>
<p>因此应该审查调试运行时的逻辑,应该只要是调试运行就可以执行<code>sub_4001000</code>但是没有打印输出,估计调试器可以观察出某些变量的值,</p>
<p>但是我目前只会用gdb调试器,但是这个题给出的文件明显编译时没有-g选项,没有调试信息</p>
<p>还是从静态分析入手,分析解密函数<code>sub_401000</code></p>
<h3 id="解密函数sub_401000">解密函数<code>sub_401000</code></h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506095147714.png"
alt="image-20220506095147714" />
<figcaption aria-hidden="true">image-20220506095147714</figcaption>
</figure>
<p>解密算法就是把s字符数组四个字符按照小端规则看成一个双字去和双字类型的<code>key=0xDDCCAABB</code>按位异或,然后再将双字拆成四个ascii字符即得到flag</p>
<p>堆上的缓冲区s拷贝的是<code>unk_409B10</code>,将其转化为c双字数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506095859599.png"
alt="image-20220506095859599" />
<figcaption aria-hidden="true">image-20220506095859599</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unk_409B10[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">0xBCA0CCBB</span>, <span class="number">0xB8BED1DC</span>, <span class="number">0xAEBECFCD</span>, <span class="number">0x82ABC4D2</span>, <span class="number">0xB393D9D2</span>, <span class="number">0xA993DED4</span>, <span class="number">0x82B8CBD3</span>, <span class="number">0xB9BECBD3</span>, </span><br><span class="line">    <span class="number">0x00CCD79A</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解密程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IntAndChar4</span> &#123;</span></span><br><span class="line">protected:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inInt;<span class="comment">//inInt和inChar[4]共用四个字节</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> inChar[<span class="number">4</span>];</span><br><span class="line">public:</span><br><span class="line">	<span class="type">void</span> <span class="title function_">setInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> &#123;</span><br><span class="line">		inInt = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> inInt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> <span class="title function_">getString</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			s += inChar[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;os, <span class="type">const</span> IntAndChar4 &amp;iac4) &#123;</span><br><span class="line">		os &lt;&lt; iac4.getString();</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; iac4[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> key = <span class="number">0xDDCCAABB</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> encrypted[<span class="number">9</span>] = &#123;</span><br><span class="line">	<span class="number">0xBCA0CCBB</span>, <span class="number">0xB8BED1DC</span>, <span class="number">0xAEBECFCD</span>, <span class="number">0x82ABC4D2</span>, <span class="number">0xB393D9D2</span>, <span class="number">0xA993DED4</span>, <span class="number">0x82B8CBD3</span>, <span class="number">0xB9BECBD3</span>,</span><br><span class="line">	<span class="number">0x00CCD79A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">		iac4[i].setInt(key ^ encrypted[i]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iac4[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	decrypt();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;reversing_is_not_that_hard!&#125;</span><br></pre></td></tr></table></figure>
<h2 id="maze">012maze</h2>
<p>尽量不看源代码,用CSAPP第三章的方法,将汇编语言首先转化为带goto和label的伪代码,然后转为不带goto和label的伪代码</p>
<p>这个题的名字<code>maze</code>很有意思,迷宫,既体现在反汇编翻译成伪代码时分支众多,又体现在最后使用走迷宫的方法获得flag</p>
<h3 id="main">main</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006B0 ; int __fastcall main(int, char **, char **)</span><br><span class="line">;注意调用方式,所有局部变量的地址都基于栈顶指针rsp计算,不基于帧指针计算</span><br><span class="line">.text:00000000004006B0 main            proc near               ; DATA XREF: start+1D↑o</span><br><span class="line">.text:00000000004006B0</span><br><span class="line">.text:00000000004006B0 var_28          = dword ptr -28h</span><br><span class="line">.text:00000000004006B0 var_24          = dword ptr -24h</span><br><span class="line">.text:00000000004006B0</span><br><span class="line">.text:00000000004006B0 ; __unwind &#123;</span><br><span class="line"></span><br><span class="line">;开端,参数压栈,保存寄存器</span><br><span class="line">.text:00000000004006B0                 push    rbp</span><br><span class="line">.text:00000000004006B1                 push    r15</span><br><span class="line">.text:00000000004006B3                 push    r14</span><br><span class="line">.text:00000000004006B5                 push    rbx</span><br><span class="line">.text:00000000004006B6                 push    rax</span><br><span class="line"></span><br><span class="line">;栈上开了两个局部变量,var_24和var_28</span><br><span class="line">.text:00000000004006B7                 mov     [rsp+28h+var_24], 0</span><br><span class="line">.text:00000000004006BF                 mov     [rsp+28h+var_28], 0</span><br><span class="line"></span><br><span class="line">;提醒用户输入</span><br><span class="line">.text:00000000004006C6                 mov     edi, offset s   ; &quot;Input flag:&quot;</span><br><span class="line">.text:00000000004006CB                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取用户输入</span><br><span class="line">.text:00000000004006D0                 mov     edi, offset format ; &quot;%s&quot;</span><br><span class="line">.text:00000000004006D5                 mov     esi, offset s1;s1作为第一个参数传递给_scanf,作为缓冲区承载输入</span><br><span class="line">.text:00000000004006DA                 xor     eax, eax</span><br><span class="line">.text:00000000004006DC                 call    _scanf</span><br><span class="line"></span><br><span class="line">;获取输入字符串的长度并与18h=24字节进行比较</span><br><span class="line">.text:00000000004006E1                 mov     edi, offset s1  ; s</span><br><span class="line">.text:00000000004006E6                 call    _strlen</span><br><span class="line">.text:00000000004006EB                 mov     rbx, rax</span><br><span class="line">.text:00000000004006EE                 cmp     rbx, 18h</span><br><span class="line"></span><br><span class="line">;如果长度不够则跳转loc_400822报告失败</span><br><span class="line">.text:00000000004006F2                 jnz     loc_400822</span><br><span class="line"></span><br><span class="line">;否则即输入长度为18h=24字节,验证前五个字符和最后一个字符是否是nctf&#123;balabala&#125;这种结构</span><br><span class="line">.text:00000000004006F8                 mov     edi, offset s1  ; s1</span><br><span class="line">.text:00000000004006FD                 mov     esi, offset s2  ; &quot;nctf&#123;&quot;</span><br><span class="line">.text:0000000000400702                 mov     edx, 5          ; n</span><br><span class="line">.text:0000000000400707                 call    _strncmp</span><br><span class="line">.text:000000000040070C                 test    eax, eax</span><br><span class="line">.text:000000000040070E                 jnz     loc_400822</span><br><span class="line">.text:0000000000400714                 movzx   eax, ds:byte_6010BF[rbx]</span><br><span class="line">.text:000000000040071B                 cmp     eax, 7Dh ; &#x27;&#125;&#x27;</span><br><span class="line">.text:000000000040071E                 jnz     loc_400822</span><br><span class="line"></span><br><span class="line">;设定循环变量初始值</span><br><span class="line">.text:0000000000400724                 mov     edi, offset s1  ; s</span><br><span class="line">.text:0000000000400729                 call    _strlen</span><br><span class="line">.text:000000000040072E                 dec     rax			;strlen(s1)-1-&gt;rax指向s1的最后一个非0字符的下标</span><br><span class="line">.text:0000000000400731                 mov     ebx, 5		;从5开始是由于0到4这前五个字符已经判断过是nctf&#123;了,ebx将会作为循环变量i</span><br><span class="line">.text:0000000000400736                 cmp     rax, 5		;判断strlen(s1)-1和5的大小,即判断s1串除了nctf&#123;&#125;之外有无其他字符</span><br><span class="line">.text:000000000040073A                 jbe     loc_4007EE</span><br><span class="line"></span><br><span class="line">;其他循环体变量初始化</span><br><span class="line">.text:0000000000400740                 lea     r14, [rsp+28h+var_28];r14=&amp;var_28,一定要分清r14里面放的是var_28的地址</span><br><span class="line">.text:0000000000400744                 lea     r15, [rsp+28h+var_24];r25=&amp;var_24</span><br><span class="line">.text:0000000000400749                 nop     dword ptr [rax+00000000h];nop指令什么也不干</span><br><span class="line">.text:0000000000400750</span><br><span class="line"></span><br><span class="line">;下面进入循环体</span><br><span class="line">;始终注意:</span><br><span class="line">;r14=&amp;var_28</span><br><span class="line">;r15=&amp;var_24</span><br><span class="line">;rbx中放的是循环变量i</span><br><span class="line">;s1是输入的字符串</span><br><span class="line">;后来会用到的asc_601060是data区的一个全局字符数组,&#x27;  *******   *  **** * ****  * ***  *#  *** *** ***     *********&#x27;</span><br><span class="line">;rbx作为循环变量,用来遍历s1字符数组,s1[rbx]相当于s1[i]</span><br><span class="line">;后面专门摘出循环体进行分析</span><br><span class="line">.text:0000000000400750 loc_400750:                             ; CODE XREF: main+133↓j</span><br><span class="line">.text:0000000000400750                 movsx   eax, ds:s1[rbx]</span><br><span class="line">.text:0000000000400757                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400759                 cmp     eax, 4Eh ; &#x27;N&#x27;</span><br><span class="line">.text:000000000040075C                 jg      short loc_400780</span><br><span class="line">.text:000000000040075E                 movzx   eax, al</span><br><span class="line">.text:0000000000400761                 cmp     eax, 2Eh ; &#x27;.&#x27;</span><br><span class="line">.text:0000000000400764                 jz      short loc_4007A0</span><br><span class="line">.text:0000000000400766                 cmp     eax, 30h ; &#x27;0&#x27;</span><br><span class="line">.text:0000000000400769                 jnz     short loc_4007BB</span><br><span class="line">.text:000000000040076B                 mov     rdi, r14</span><br><span class="line">.text:000000000040076E                 call    sub_400680;小函数,作用是修改</span><br><span class="line">.text:0000000000400773                 jmp     short loc_4007B8</span><br><span class="line">.text:0000000000400773 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400775                 align 20h</span><br><span class="line">.text:0000000000400780</span><br><span class="line">.text:0000000000400780 loc_400780:                             ; CODE XREF: main+AC↑j</span><br><span class="line">.text:0000000000400780                 movzx   eax, al</span><br><span class="line">.text:0000000000400783                 cmp     eax, 4Fh ; &#x27;O&#x27;</span><br><span class="line">.text:0000000000400786                 jz      short loc_4007B0</span><br><span class="line">.text:0000000000400788                 cmp     eax, 6Fh ; &#x27;o&#x27;</span><br><span class="line">.text:000000000040078B                 jnz     short loc_4007BB</span><br><span class="line">.text:000000000040078D                 mov     rdi, r15</span><br><span class="line">.text:0000000000400790                 call    sub_400660</span><br><span class="line">.text:0000000000400795                 jmp     short loc_4007B8</span><br><span class="line">.text:0000000000400795 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400797                 align 20h</span><br><span class="line">.text:00000000004007A0</span><br><span class="line">.text:00000000004007A0 loc_4007A0:                             ; CODE XREF: main+B4↑j</span><br><span class="line">.text:00000000004007A0                 mov     rdi, r14</span><br><span class="line">.text:00000000004007A3                 call    sub_400670</span><br><span class="line">.text:00000000004007A8                 jmp     short loc_4007B8</span><br><span class="line">.text:00000000004007A8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004007AA                 align 10h</span><br><span class="line">.text:00000000004007B0</span><br><span class="line">.text:00000000004007B0 loc_4007B0:                             ; CODE XREF: main+D6↑j</span><br><span class="line">.text:00000000004007B0                 mov     rdi, r15</span><br><span class="line">.text:00000000004007B3                 call    sub_400650</span><br><span class="line">.text:00000000004007B8</span><br><span class="line">.text:00000000004007B8 loc_4007B8:                             ; CODE XREF: main+C3↑j</span><br><span class="line">.text:00000000004007B8                                         ; main+E5↑j ...</span><br><span class="line">.text:00000000004007B8                 mov     bpl, al</span><br><span class="line">.text:00000000004007BB</span><br><span class="line">.text:00000000004007BB loc_4007BB:                             ; CODE XREF: main+B9↑j</span><br><span class="line">.text:00000000004007BB                                         ; main+DB↑j</span><br><span class="line">.text:00000000004007BB                 mov     esi, [rsp+28h+var_24]</span><br><span class="line">.text:00000000004007BF                 mov     edx, [rsp+28h+var_28]</span><br><span class="line">.text:00000000004007C2                 mov     edi, offset asc_601060 ; &quot;  *******   *  **** * ****  * ***  *#  &quot;...</span><br><span class="line">.text:00000000004007C7                 call    sub_400690</span><br><span class="line">.text:00000000004007CC                 test    al, al</span><br><span class="line">.text:00000000004007CE                 jz      short loc_400822;此处也可能出循环,当al即sub_400690返回值为0则跳出循环</span><br><span class="line">.text:00000000004007D0                 inc     rbx</span><br><span class="line">.text:00000000004007D3                 mov     edi, offset s1  ; s</span><br><span class="line">.text:00000000004007D8                 call    _strlen</span><br><span class="line">.text:00000000004007DD                 dec     rax</span><br><span class="line">.text:00000000004007E0                 cmp     rbx, rax;判断rbx是否遍历完了s1字符串</span><br><span class="line">.text:00000000004007E3                 jb      loc_400750</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;出了循环体,下面判断bpl是否为0</span><br><span class="line">.text:00000000004007E9                 test    bpl, bpl</span><br><span class="line">.text:00000000004007EC                 jz      short loc_40080B</span><br><span class="line"></span><br><span class="line">;检查出循环时,var_24+8*var_28是否等于23h=35字节,如果是则报告成功</span><br><span class="line">.text:00000000004007EE</span><br><span class="line">.text:00000000004007EE loc_4007EE:                             ; CODE XREF: main+8A↑j</span><br><span class="line">.text:00000000004007EE                 movsxd  rax, [rsp+28h+var_24]</span><br><span class="line">.text:00000000004007F3                 movsxd  rcx, [rsp+28h+var_28]</span><br><span class="line">.text:00000000004007F7                 movzx   eax, byte ptr asc_601060[rax+rcx*8] ; &quot;  *******   *  **** * ****  * ***  *#  &quot;...</span><br><span class="line">.text:00000000004007FF                 cmp     eax, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:0000000000400802                 jnz     short loc_40080B</span><br><span class="line"></span><br><span class="line">;置成功</span><br><span class="line">.text:0000000000400804                 mov     edi, offset aCongratulation ; &quot;Congratulations!&quot;</span><br><span class="line">.text:0000000000400809                 jmp     short loc_400810</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;置失败</span><br><span class="line">.text:000000000040080B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040080B</span><br><span class="line">.text:000000000040080B loc_40080B:                             ; CODE XREF: main+13C↑j</span><br><span class="line">.text:000000000040080B                                         ; main+152↑j</span><br><span class="line">.text:000000000040080B                 mov     edi, offset aWrongFlag ; &quot;Wrong flag!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400810</span><br><span class="line">.text:0000000000400810 loc_400810:                             ; CODE XREF: main+159↑j</span><br><span class="line">.text:0000000000400810                 call    _puts;打印刚才存放在edi中的字符串地址指向的字符串,可能是失败或成功</span><br><span class="line"></span><br><span class="line">;函数尾声</span><br><span class="line">.text:0000000000400815                 xor     eax, eax</span><br><span class="line">.text:0000000000400817                 add     rsp, 8</span><br><span class="line">.text:000000000040081B                 pop     rbx</span><br><span class="line">.text:000000000040081C                 pop     r14</span><br><span class="line">.text:000000000040081E                 pop     r15</span><br><span class="line">.text:0000000000400820                 pop     rbp</span><br><span class="line">.text:0000000000400821                 retn</span><br><span class="line"></span><br><span class="line">;置失败</span><br><span class="line">.text:0000000000400822 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400822</span><br><span class="line">.text:0000000000400822 loc_400822:                             ; CODE XREF: main+42↑j</span><br><span class="line">.text:0000000000400822                                         ; main+5E↑j ...</span><br><span class="line">.text:0000000000400822                 mov     edi, offset aWrongFlag ; &quot;Wrong flag!&quot;</span><br><span class="line">.text:0000000000400827                 call    _puts</span><br><span class="line">.text:000000000040082C                 mov     edi, 0FFFFFFFFh ; status</span><br><span class="line">.text:0000000000400831                 call    _exit</span><br><span class="line">.text:0000000000400831 ; &#125; // starts at 4006B0</span><br><span class="line">.text:0000000000400831 main            endp</span><br><span class="line">.text:0000000000400831</span><br><span class="line">.text:0000000000400831 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400836                 align 20h</span><br></pre></td></tr></table></figure>
<h3 id="循环体分析-1">循环体分析</h3>
<p>循环体是本题关键</p>
<p>对于循环体,摘出来翻译成伪代码</p>
<p>其中一些sub_400680,sub_400670,sub_400660,sub_400650都是小函数,其作用是对var_24或var_28进行加一或者减一操作,然后根据他俩的值置bpl的值是否为0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506084842338.png"
alt="image-20220506084842338" />
<figcaption aria-hidden="true">image-20220506084842338</figcaption>
</figure>
<p>如果想要得到congratulations的结果,必须满足:</p>
<p>1.循环体每执行一遍,最后的时候都要满足<code>asc_601060[var_24+var_28*8]==' '||asc_601060[var_24+var_28*8]=='#'</code></p>
<p>2.出循环的时候<code>asc_601060[var_24+8*var_28]='#'</code>即<code>var_24+8*var_28=36</code>,并且bpl不能为0</p>
<h3 id="问题转化">问题转化</h3>
<p>而<code>asc_601060="  *******   *  **** * ****  * ***  *#  *** *** ***     *********"</code></p>
<p>其中空格字符的下标为<code>0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>如果要满足1的话,<code>var_24+var_28*8=0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>要满足2的话,最终结果<code>var_24+var_28*8=36</code>,bpl是一个循环中附带计算的值,现在不方便讨论其取值,</p>
<p>但是可以确定的是,如果出循环的时候<code>var_24或者var_28</code>有小于0或者大于8,则bpl一定为0,</p>
<p>那么可以<strong>粗略</strong>的认为<code>var_24,var_28</code>取值都在<code>[0,8]</code>之间(说粗略是因为有可能var_24,var_28在循环中可以越界但是后来又退进了[0,8])</p>
<h3 id="转化成一维状态转移">转化成一维状态转移</h3>
<p>将上述两点分析转化成一个深度优先搜索或者说动态规划的问题</p>
<p>把<code>var_24,var_28</code>的值表示为<code>(var_24,var_28)</code>的数对<code>(x,y)</code>,比如<code>(1,2)</code>就表示<code>var_24=1,var_28=2</code>,</p>
<p>一个数对与一个整数
建立映射关系<code>(var_24,var_28)-&gt;var_24+8*var_28</code></p>
<p>初始时状态为<code>(0,0)-&gt;0</code></p>
<p>结束时状态为<code>(x,y)-&gt;36</code></p>
<p>中间的合法状态映射成的整数值有<code>0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>状态转移有四种情况: <span class="math display">\[
(x,y)\rightarrow\begin{cases}
(x-1,y)\\
(x+1,y)\\
(x,y-1)\\
(x,y+1)\\
\end{cases}
\]</span></p>
<p>下面就找一条路径,使得这个映射值从0转移到36,中途的任何数对的映射值都应当落在合法值域中</p>
<p>可以写一深度优先搜索实现该问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; legal = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">42</span>, <span class="number">46</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLegal</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n)</span> </span>&#123;<span class="comment">//判断一个映射值是否输入legal合法映射值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : legal) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == n)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//记忆化搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Path</span> &#123;<span class="comment">//记录中途经过状态的结构体</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Path &amp;p) &#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; p.x + p.y * <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">		<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; path[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> directors[<span class="number">20</span>];<span class="comment">//移动方向</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">8</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//粗略条件剪枝</span></span><br><span class="line">	<span class="keyword">if</span> (visited[x][y])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//记忆化搜索剪枝</span></span><br><span class="line">	visited[x][y] = <span class="literal">true</span>;<span class="comment">//设置访问过</span></span><br><span class="line">	<span class="type">int</span> sum = x + <span class="number">8</span> * y;<span class="comment">//计算映射值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isLegal</span>(sum) == <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不合法,剪枝</span></span><br><span class="line">	path[depth].<span class="built_in">setCoordinate</span>(x, y);<span class="comment">//合法,记录路径</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">36</span>) &#123;<span class="comment">//判断映射值是否已经为终点值36</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向其他状态转移</span></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;o&#x27;</span>;<span class="comment">//方向数组,记录转义方向</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x + <span class="number">1</span>, y, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x, y + <span class="number">1</span>, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x - <span class="number">1</span>, y, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x, y - <span class="number">1</span>, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;<span class="comment">//从x=0,y=0,深度depth=0开始</span></span><br><span class="line">	<span class="comment">//如果成功da则打印方向数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">			cout &lt;&lt; directors[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o0oo00O000oooo..OO</span><br></pre></td></tr></table></figure>
<p>刚好18个字符,加上头尾的nctf{}之后</p>
<p><code>nctf&#123;o0oo00O000oooo..OO&#125;</code>刚好24个字符,满足所有限制条件,因此得到了flag</p>
<h3 id="转化为二维迷宫">转化为二维迷宫</h3>
<p>做完了看了别人的writeup才恍然大悟</p>
<p>考虑为什么<code>var_24+var_28*8</code>这里有一个*8?</p>
<p>如果将<code>asc_601060="  *******   *  **** * ****  * ***  *#  *** *** ***     *********"</code>以8字节为单位换行则得到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ******</span><br><span class="line">*   *  *</span><br><span class="line">*** * **</span><br><span class="line">**  * **</span><br><span class="line">*  *#  *</span><br><span class="line">** *** *</span><br><span class="line">**     *</span><br><span class="line">********</span><br></pre></td></tr></table></figure>
<p>星号,空格,井号的宽度不一样因此这里看上去对不齐</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506091352319.png"
alt="image-20220506091352319" />
<figcaption aria-hidden="true">image-20220506091352319</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506091523194.png"
alt="image-20220506091523194" />
<figcaption aria-hidden="true">image-20220506091523194</figcaption>
</figure>
<p>右下右右下下左下下下右右右右上上左左</p>
<p>翻译成oO0.四个字符就是<code>o0oo00O000oooo..OO</code></p>
<p>同样可以得到flag</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/04/28/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/" class="post-title-link" itemprop="url">调用约定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 16:27:00" itemprop="dateCreated datePublished" datetime="2022-04-28T16:27:00+08:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-17 23:54:52" itemprop="dateModified" datetime="2022-09-17T23:54:52+08:00">2022-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调用约定">调用约定</h1>
<p>为啥CSAPP第三章x86-64汇编学完了,但是看IDA的反汇编仍然是一头雾水?还得看一大堆东西,其中就有调用约定</p>
<p>为什么windows上和linux上,x86和x64上编译出来的代码有很多不同,为什么和CSAPP说的相差甚远?调用约定不同是一大原因</p>
<p>首先要说明的几点,也是实验中和查阅资料逐渐获得的几点</p>
<p>1.==各种调用约定是相对于x86而言的==,对x64无意义</p>
<blockquote>
<p>The keywords <code>_stdcall</code> and <code>_cdecl</code> specify
32-bit calling conventions. That's why they are not relevant for 64-bit
programs (i.e. x64). On x64, there is only the <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">standard
calling convention</a> and the extended <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_vectorcall"><code>__vectorcall</code></a>
calling convenction.</p>
<p>来自stackoverflow</p>
</blockquote>
<p>关键词<code>_stdcall</code>和<code>_cdecl</code>特指32位的调用约定.64位上不一样,64位上只有标准调用约定,还有其拓展<code>__vectorcall</code></p>
<p>即使在64位的函数前面用<code>__cdecl</code>或者<code>__stdcall</code>修饰,编译结果也是一样的</p>
<p>2.x86和x64汇编有较大出入,windows上和linux上的同一约定也有些许区别</p>
<h2 id="x86上的调用约定">x86上的调用约定</h2>
<p>微软给出的==x86系统==上的调用约定:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427184436835.png"
alt="image-20220427184436835" />
<figcaption aria-hidden="true">image-20220427184436835</figcaption>
</figure>
<p>一定注意是x86系统上的,而我们现在的笔记本大多数都是x64系统了,会有一些出入</p>
<h3 id="c调用约定__cdecl">c调用约定<code>__cdecl</code></h3>
<p>C Declaration</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; __cdecl &lt;func_name&gt;(para1,para2,...,paran);</span><br></pre></td></tr></table></figure>
<p>对于x86系统,微软官方文档是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427184750211.png"
alt="x86" />
<figcaption aria-hidden="true">x86</figcaption>
</figure>
<p>维基百科这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152115878.png"
alt="image-20220428152115878" />
<figcaption aria-hidden="true">image-20220428152115878</figcaption>
</figure>
<p>在gcc编译的时候加入-m32选项即可使用32位编译,编译成x86系统的程序</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _cdecl <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f,<span class="type">int</span> g,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _cdecl <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _cdecl <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 test.c -c -m32 -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br></pre></td></tr></table></figure>
<p>使用-m32编译之后然后反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_func&gt;:</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	89 e5                	mov    %esp,%ebp			;蜜汁操作,有esp为啥还要获取一个ebp作为拷贝?</span><br><span class="line">   3:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line">   6:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line">   9:	01 c2                	add    %eax,%edx</span><br><span class="line">   b:	8b 45 10             	mov    0x10(%ebp),%eax</span><br><span class="line">   e:	01 c2                	add    %eax,%edx</span><br><span class="line">  10:	8b 45 14             	mov    0x14(%ebp),%eax</span><br><span class="line">  13:	01 c2                	add    %eax,%edx</span><br><span class="line">  15:	8b 45 18             	mov    0x18(%ebp),%eax</span><br><span class="line">  18:	01 c2                	add    %eax,%edx</span><br><span class="line">  1a:	8b 45 1c             	mov    0x1c(%ebp),%eax</span><br><span class="line">  1d:	01 c2                	add    %eax,%edx</span><br><span class="line">  1f:	8b 45 20             	mov    0x20(%ebp),%eax</span><br><span class="line">  22:	01 c2                	add    %eax,%edx</span><br><span class="line">  24:	8b 45 24             	mov    0x24(%ebp),%eax</span><br><span class="line">  27:	01 d0                	add    %edx,%eax</span><br><span class="line">  29:	5d                   	pop    %ebp</span><br><span class="line">  2a:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">0000002b &lt;_show&gt;:</span><br><span class="line">  2b:	55                   	push   %ebp</span><br><span class="line">  2c:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  2e:	83 ec 20             	sub    $0x20,%esp			;申请0x20=32字节空间,刚好8个int参数×一个int是4个字节,但是蜜汁操作,为啥不用push逐次压栈,而是一次性申请空间</span><br><span class="line">  31:	c7 44 24 1c 08 00 00 	movl   $0x8,0x1c(%esp)		</span><br><span class="line">  38:	00 </span><br><span class="line">  39:	c7 44 24 18 07 00 00 	movl   $0x7,0x18(%esp)		;每个参数占用栈上4个字节,8个参数紧挨着</span><br><span class="line">  40:	00 </span><br><span class="line">  41:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)</span><br><span class="line">  48:	00 </span><br><span class="line">  49:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)</span><br><span class="line">  50:	00 </span><br><span class="line">  51:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)</span><br><span class="line">  58:	00 </span><br><span class="line">  59:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)</span><br><span class="line">  60:	00 </span><br><span class="line">  61:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)</span><br><span class="line">  68:	00 </span><br><span class="line">  69:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)			;栈顶一定存放的是最左侧的参数</span><br><span class="line">  70:	e8 8b ff ff ff       	call   0 &lt;_func&gt;</span><br><span class="line">  75:	c9                   	leave  						;蜜汁指令,CSAPP上没有见过leave指令</span><br><span class="line">  76:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000077 &lt;_main&gt;:</span><br><span class="line">  77:	55                   	push   %ebp</span><br><span class="line">  78:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  7a:	83 e4 f0             	and    $0xfffffff0,%esp</span><br><span class="line">  7d:	e8 00 00 00 00       	call   82 &lt;_main+0xb&gt;</span><br><span class="line">  82:	e8 a4 ff ff ff       	call   2b &lt;_show&gt;</span><br><span class="line">  87:	b8 00 00 00 00       	mov    $0x0,%eax			;返回值放在eax,rax寄存器中</span><br><span class="line">  8c:	c9                   	leave  						</span><br><span class="line">  8d:	c3                   	ret    </span><br><span class="line">  8e:	90                   	nop</span><br><span class="line">  8f:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>32位系统必定不会用到r开头的4字64位寄存器比如<code>rax,rdx,rsp</code>等等,最大用到e开头的寄存器,比如<code>eax,esp</code></p>
<p>可以发现show函数在调用func函数,传参的时候没有用到一个寄存器,全都是用的堆栈,还可以发现函数名都是由下划线前缀的<code>&lt;_main&gt;,&lt;_func&gt;,&lt;_show&gt;</code></p>
<p>在为函数参数申请栈空间的时候是一次性完成的,即有8个参数则直接在栈上申请0x20=32字节,然后分别用movl指令向栈上刚才申请的空间写入数据.</p>
<blockquote>
<p><strong>关于蜜汁操作参数的压栈方式,是一次性申请足够的空间然后mov还是逐次push?</strong></p>
<p>stackoverflow上的说法:</p>
<blockquote>
<blockquote>
<ol type="1">
<li>Why does x64 use <code>mov</code> rather than <code>push</code>? I
assume it's just more efficient and wasn't available in x86.</li>
</ol>
</blockquote>
<p>That is not the reason. Both of these instructions also exist in x86
assembly language.</p>
<p>效率并且是否可实现不是原因.这两种指令(push和mov)在x86汇编语言中都存在</p>
<p>The reason why your compiler is not emitting a <code>push</code>
instruction for the x64 code is probably because it must adjust the
stack pointer directly anyway, in order to create 32 bytes of "shadow
space" for the called function. See <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">this
link</a> (which was provided by <span class="citation"
data-cites="NateEldredge">@NateEldredge</span>) for further information
on "shadow space".</p>
<p>编译器对x64不使用push指令的原因是:他需要直接调整栈顶指针,给前四个参数的压栈预留"影子空间"</p>
<p>x86不需要寄存器传递参数但是x64需要寄存器并且在被调用函数的一开始会把寄存器中的参数也压栈,那么这些寄存器中的参数将会压入影子空间.具体见后文的实验</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作ebp(rbp)寄存器的作用</strong>:</p>
<p>行为:在每个函数开始时都会被压入栈中然后拷贝栈顶指针,在有些函数快要结束的时候又会从栈中获取先前压入栈中的值</p>
<p>比如一个典型的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2b:	55                   	push   %ebp</span><br><span class="line">2c:	89 e5                	mov    %esp,%ebp</span><br><span class="line">2e:	83 ec 20             	sub    $0x20,%esp</span><br></pre></td></tr></table></figure>
<p>查阅<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41912684/what-is-the-purpose-of-the-rbp-register-in-x86-64-assembler">stackoverflow</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427195841367.png"
alt="image-20220427195841367" />
<figcaption aria-hidden="true">image-20220427195841367</figcaption>
</figure>
<blockquote>
<p><code>rbp</code> is the frame pointer on x86_64. In your generated
code, it gets a snapshot of the stack pointer (<code>rsp</code>) so that
when adjustments are made to <code>rsp</code> (i.e. reserving space for
local variables or <code>push</code>ing values on to the stack), local
variables and function parameters are still accessible from a constant
offset from <code>rbp</code>.</p>
<p>A lot of compilers offer frame pointer omission as an optimization
option; this will make the generated assembly code access variables
relative to <code>rsp</code> instead and free up <code>rbp</code> as
another general purpose register for use in functions.</p>
<p>In the case of GCC, which I'm guessing you're using from the AT&amp;T
assembler syntax, that switch is <code>-fomit-frame-pointer</code>. Try
compiling your code with that switch and see what assembly code you get.
You will probably notice that when accessing values relative to
<code>rsp</code> instead of <code>rbp</code>, the offset from the
pointer varies throughout the function.</p>
</blockquote>
<p>rbp是x86_64上的栈帧指针.在我们的代码中,rbp寄存器获取栈顶指针rsp的快照.</p>
<p>当rsp改变时(比如为局部变量预留空间或者通过push指令压栈),我们仍然可以通过使用rbp+偏移量这种方式调用上一个函数(或者说调用者)的局部变量或者函数参数.</p>
<p>很多编译器的优化,会不用上述方式(rbp+偏移量)调用上一个函数的局部变量或者函数参数,而是只用rsp+偏移量.然后省出rbp寄存器去干其他事.对于GCC编译器,使用<code>-fomit-frame-pointer</code>编译选项达到上述目的</p>
<p>按照我的理解,rbp的作用就是调用者的rsp副本,然后rsp为被调用者服务,rbp为调用者服务.</p>
<p>rbp只是在被调用者嗲用调用者的局部变量时,令寻址更方便,完全可以只用rsp达到目的</p>
<blockquote>
<p>后来的实践证明我一开始的理解是错误的</p>
<p>rbp指向函数栈帧的高地址,即栈底,rsp指向函数栈帧的低地址,即栈顶</p>
<p>二者都是为当前函数服务的</p>
<p>函数的开端时会将上一个函数的rbp指针压栈保存,然后指向当前函数栈帧的栈底.函数尾声时会将上一个函数的rbp指针退栈还给rbp</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -fomit-frame-pointer test.c -c -m64 -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000000000d6 &lt;main&gt;:</span><br><span class="line">  d6:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  da:	e8 00 00 00 00       	callq  df &lt;main+0x9&gt;</span><br><span class="line">  df:	e8 ae ff ff ff       	callq  92 &lt;show&gt;</span><br><span class="line">  e4:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  e9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  ed:	c3                   	retq   </span><br><span class="line">  ee:	90                   	nop</span><br><span class="line">  ef:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用<code>-fomit-frame-pointer</code>编译选项之后确实ebp不踪影了</p>
<p>现在再看这个结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2b:	55                   	push   %ebp				;将上一个函数对上上个函数的ebp保存</span><br><span class="line">2c:	89 e5                	mov    %esp,%ebp		;ebp获取上一个函数esp的副本</span><br><span class="line">2e:	83 ec 20             	sub    $0x20,%esp		;esp为当前函数服务</span><br></pre></td></tr></table></figure>
<p>最后将栈中刚才压入的ebp又还给ebp是还原上个函数对上上个函数的esp副本</p>
</blockquote>
<blockquote>
<p><strong>关于蜜汁指令leave</strong>:</p>
<p>百度百科给出的解释:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427224030429.png"
alt="image-20220427224030429" />
<figcaption aria-hidden="true">image-20220427224030429</figcaption>
</figure>
<p>一定要注意,这里指令的源和目的操作数与我们通篇是相反的</p>
<p>这里百科给出的解释使用的是intel风格的汇编语言,<code>mov 目的操作数,源操作数</code></p>
<p>寄存器前面有百分号的是AT&amp;T风格的汇编语言,<code>movq 源操作数,目的操作数</code></p>
<p>leave指令在AT&amp;T风格下相当于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl %ebp,%esp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure>
<p>而这刚好和每个函数一开始的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   %ebp</span><br><span class="line">mov    %esp,%ebp</span><br></pre></td></tr></table></figure>
<p>恰好相反</p>
<p>因此leave指令就是还原栈的一个过程</p>
</blockquote>
<h3 id="标准调用约定__stdcall">标准调用约定<code>__stdcall</code></h3>
<p>微软官方文档给出的解释:</p>
<blockquote>
<p>The <strong><code>__stdcall</code></strong> calling convention is
used to call Win32 API functions. The callee cleans the stack, so the
compiler makes <code>vararg</code> functions
<strong><code>__cdecl</code></strong>. Functions that use this calling
convention require a function prototype. The
<strong><code>__stdcall</code></strong> modifier is
Microsoft-specific.</p>
</blockquote>
<p><code>__stdcall</code>用于修饰==Win32
API函数==.被调用者负责情理自己的函数栈,(因此编译器会把变参函数修饰为<code>__cdecl</code>(调用者清理栈容易实现变参)).使用<code>__stdcall</code>的函数需要一个函数原型(即接口)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return-type __stdcall function-name[( argument-list )]</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Element</th>
<th style="text-align: left;">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Argument-passing
order<br />参数传递顺序</td>
<td style="text-align: left;">Right to left.<br />从右向左</td>
</tr>
<tr>
<td style="text-align: left;">Argument-passing
convention<br />参数传递规则(值传递/引用传递)</td>
<td style="text-align: left;">By value, unless a pointer or reference
type is passed.<br />除非参数是指针或者引用类型,否则采用值传递</td>
</tr>
<tr>
<td style="text-align: left;">Stack-maintenance
responsibility<br />栈维护</td>
<td style="text-align: left;">Called function pops its own arguments
from the stack.<br />被调用者自己清理自己用到的栈</td>
</tr>
<tr>
<td style="text-align: left;">Name-decoration
convention<br />命名修饰规则</td>
<td style="text-align: left;">An underscore (<code>_</code>) is prefixed
to the name. The name is followed by the at sign (<code>@</code>)
followed by the number of bytes (in decimal) in the argument list.
Therefore, the function declared as
<code>int func( int a, double b )</code> is decorated as follows:
<code>_func@12</code><br />下划线开头,然后@,然后是十进制表示的参数表字节大小.<br />因此<code>int func(int a,double b)</code>将会被修饰为<code>_func@12</code>(int四个字节+double八个字节)</td>
</tr>
<tr>
<td style="text-align: left;">Case-translation
convention<br />大小写转换规定</td>
<td style="text-align: left;">None<br />无</td>
</tr>
<tr>
<td style="text-align: left;">返回值位置</td>
<td style="text-align: left;">放在eax,rax寄存器中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用ida打开一个win32程序,其Winmain函数是这样分析的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00401000 __stdcall WinMain(x, x, x, x) proc near ; CODE XREF: start+C9↓p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 hInstance       = dword ptr  4</span><br><span class="line">.text:00401000 hPrevInstance   = dword ptr  8</span><br><span class="line">.text:00401000 lpCmdLine       = dword ptr  0Ch</span><br><span class="line">.text:00401000 nShowCmd        = dword ptr  10h</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+hInstance]</span><br><span class="line">.text:00401004                 push    0               ; dwInitParam</span><br><span class="line">.text:00401006                 push    offset DialogFunc ; lpDialogFunc</span><br><span class="line">.text:0040100B                 push    0               ; hWndParent</span><br><span class="line">.text:0040100D                 push    65h ; &#x27;e&#x27;       ; lpTemplateName</span><br><span class="line">.text:0040100F                 push    eax             ; hInstance</span><br><span class="line">.text:00401010                 mov     hInstance, eax</span><br><span class="line">.text:00401015                 call    ds:DialogBoxParamA</span><br><span class="line">.text:0040101B                 xor     eax, eax</span><br><span class="line">.text:0040101D                 retn    10h				;retn指令可以带参数</span><br><span class="line">.text:0040101D __stdcall WinMain(x, x, x, x) endp</span><br></pre></td></tr></table></figure>
<p>可以明显观察到,参数只使用栈传递,从右向左压栈,Winmain函数的栈帧:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428092006441.png"
alt="image-20220428092006441" />
<figcaption aria-hidden="true">image-20220428092006441</figcaption>
</figure>
<p>有一点与<code>__cdecl</code>不同的是<code>retn 10h</code>,并且貌似与官方文档不同的是,被调用者没有自己清理自己的堆栈,比如Winmain到结束了也没有看见退栈指令.</p>
<p>实际上这就是<code>retn 10h</code>要做的事情</p>
<p><code>10h=16字节</code>然而四个参数刚好每个4字节,即<code>retn XXh</code>就是被调用者的退栈指令,和返回指令合并成一条指令了</p>
<p>如此减少了清理堆栈需要使用的指令</p>
</blockquote>
<p>还是<code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _stdcall <span class="title function_">func</span><span class="params">(<span class="type">short</span> a,<span class="type">short</span> b,<span class="type">short</span> c,<span class="type">short</span> d,<span class="type">short</span> e,<span class="type">short</span> f,<span class="type">short</span> g,<span class="type">short</span> h)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _stdcall <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _stdcall <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc,objdump,vscode</code>素质三连</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; gcc test.c -O0 -m32 -c -o test.o</span><br><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; objdump test.o -d &gt;test.s</span><br><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; code test.s</span><br></pre></td></tr></table></figure>
<p>反汇编如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test.o:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_func@32&gt;:										;函数名&lt;_func@32&gt;下划线,@,参数表大小(单位:字节)</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	89 e5                	mov    %esp,%ebp</span><br><span class="line">   3:	57                   	push   %edi					;寄存器临时压栈保存,为后来的运算做准备,最后还要弹栈复原</span><br><span class="line">   4:	56                   	push   %esi</span><br><span class="line">   5:	53                   	push   %ebx</span><br><span class="line">   6:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line">   9:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line">   c:	8b 4d 0c             	mov    0xc(%ebp),%ecx</span><br><span class="line">   f:	8b 5d 10             	mov    0x10(%ebp),%ebx</span><br><span class="line">  12:	89 5d d0             	mov    %ebx,-0x30(%ebp)</span><br><span class="line">  15:	8b 75 14             	mov    0x14(%ebp),%esi</span><br><span class="line">  18:	89 75 cc             	mov    %esi,-0x34(%ebp)</span><br><span class="line">  1b:	8b 7d 18             	mov    0x18(%ebp),%edi</span><br><span class="line">  1e:	8b 75 1c             	mov    0x1c(%ebp),%esi</span><br><span class="line">  21:	8b 5d 20             	mov    0x20(%ebp),%ebx</span><br><span class="line">  24:	8b 55 24             	mov    0x24(%ebp),%edx</span><br><span class="line">  27:	66 89 45 f0          	mov    %ax,-0x10(%ebp)</span><br><span class="line">  2b:	89 c8                	mov    %ecx,%eax</span><br><span class="line">  2d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)</span><br><span class="line">  31:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax</span><br><span class="line">  35:	66 89 45 e8          	mov    %ax,-0x18(%ebp)</span><br><span class="line">  39:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax</span><br><span class="line">  3d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)</span><br><span class="line">  41:	89 f8                	mov    %edi,%eax</span><br><span class="line">  43:	66 89 45 e0          	mov    %ax,-0x20(%ebp)</span><br><span class="line">  47:	89 f0                	mov    %esi,%eax</span><br><span class="line">  49:	66 89 45 dc          	mov    %ax,-0x24(%ebp)</span><br><span class="line">  4d:	89 d8                	mov    %ebx,%eax</span><br><span class="line">  4f:	66 89 45 d8          	mov    %ax,-0x28(%ebp)</span><br><span class="line">  53:	89 d0                	mov    %edx,%eax</span><br><span class="line">  55:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)</span><br><span class="line">  59:	0f bf 55 f0          	movswl -0x10(%ebp),%edx</span><br><span class="line">  5d:	0f bf 45 ec          	movswl -0x14(%ebp),%eax</span><br><span class="line">  61:	01 c2                	add    %eax,%edx</span><br><span class="line">  63:	0f bf 45 e8          	movswl -0x18(%ebp),%eax</span><br><span class="line">  67:	01 c2                	add    %eax,%edx</span><br><span class="line">  69:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax</span><br><span class="line">  6d:	01 c2                	add    %eax,%edx</span><br><span class="line">  6f:	0f bf 45 e0          	movswl -0x20(%ebp),%eax</span><br><span class="line">  73:	01 c2                	add    %eax,%edx</span><br><span class="line">  75:	0f bf 45 dc          	movswl -0x24(%ebp),%eax</span><br><span class="line">  79:	01 c2                	add    %eax,%edx</span><br><span class="line">  7b:	0f bf 45 d8          	movswl -0x28(%ebp),%eax</span><br><span class="line">  7f:	01 c2                	add    %eax,%edx</span><br><span class="line">  81:	0f bf 45 d4          	movswl -0x2c(%ebp),%eax</span><br><span class="line">  85:	01 d0                	add    %edx,%eax</span><br><span class="line">  87:	83 c4 28             	add    $0x28,%esp</span><br><span class="line">  8a:	5b                   	pop    %ebx							;对应函数开始时将寄存器压栈保存,现在退栈复原</span><br><span class="line">  8b:	5e                   	pop    %esi</span><br><span class="line">  8c:	5f                   	pop    %edi</span><br><span class="line">  8d:	5d                   	pop    %ebp</span><br><span class="line">  8e:	c2 20 00             	ret    $0x20						;被调用者自行清理自己的栈</span><br><span class="line"></span><br><span class="line">00000091 &lt;_show@0&gt;:</span><br><span class="line">  91:	55                   	push   %ebp</span><br><span class="line">  92:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  94:	83 ec 20             	sub    $0x20,%esp				;一次性分配0x20=32字节空间然后使用mov指令将参数压栈</span><br><span class="line">  97:	c7 44 24 1c 08 00 00 	movl   $0x8,0x1c(%esp)</span><br><span class="line">  9e:	00 </span><br><span class="line">  9f:	c7 44 24 18 07 00 00 	movl   $0x7,0x18(%esp)</span><br><span class="line">  a6:	00 </span><br><span class="line">  a7:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)</span><br><span class="line">  ae:	00 </span><br><span class="line">  af:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)</span><br><span class="line">  b6:	00 </span><br><span class="line">  b7:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)</span><br><span class="line">  be:	00 </span><br><span class="line">  bf:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)</span><br><span class="line">  c6:	00 </span><br><span class="line">  c7:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)</span><br><span class="line">  ce:	00 </span><br><span class="line">  cf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)</span><br><span class="line">  d6:	e8 25 ff ff ff       	call   0 &lt;_func@32&gt;</span><br><span class="line">  db:	83 ec 20             	sub    $0x20,%esp				</span><br><span class="line">  de:	c9                   	leave  </span><br><span class="line">  df:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">000000e0 &lt;_main@0&gt;:</span><br><span class="line">  e0:	55                   	push   %ebp</span><br><span class="line">  e1:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  e3:	83 e4 f0             	and    $0xfffffff0,%esp</span><br><span class="line">  e6:	e8 00 00 00 00       	call   eb &lt;_main@0+0xb&gt;</span><br><span class="line">  eb:	e8 a1 ff ff ff       	call   91 &lt;_show@0&gt;</span><br><span class="line">  f0:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  f5:	c9                   	leave  </span><br><span class="line">  f6:	c3                   	ret    </span><br><span class="line">  f7:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>&lt;<ida权威指南>&gt;上给出的建议</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428092612932.png"
alt="image-20220428092612932" />
<figcaption aria-hidden="true">image-20220428092612932</figcaption>
</figure>
<h3 id="微软__fastcall">微软<code>__fastcall</code></h3>
<p>&lt;<ida权威指南>&gt;是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428154840944.png"
alt="image-20220428154840944" />
<figcaption aria-hidden="true">image-20220428154840944</figcaption>
</figure>
<p>微软官方文档:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428155346372.png"
alt="image-20220428155346372" />
<figcaption aria-hidden="true">image-20220428155346372</figcaption>
</figure>
<p>同样的程序,除了main函数之外,其他函数都用<code>_fastcall</code>修饰</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _fastcall <span class="title function_">func</span><span class="params">(<span class="type">short</span> a,<span class="type">short</span> b,<span class="type">short</span> c,<span class="type">short</span> d,<span class="type">short</span> e,<span class="type">short</span> f,<span class="type">short</span> g,<span class="type">short</span> h)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _fastcall <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;<span class="comment">//如果main也用_fastcall修饰则报错没有入口点</span></span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用MSVC编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135\Desktop\reverse\test_call&gt;cl test.c</span><br><span class="line">用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30139 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">test.c</span><br><span class="line">Microsoft (R) Incremental Linker Version 14.29.30139.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:test.exe</span><br><span class="line">test.obj</span><br></pre></td></tr></table></figure>
<p>然后反编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump test.obj -d &gt;test.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test.obj:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text$mn:</span><br><span class="line"></span><br><span class="line">00000000 &lt;@func@32&gt;:									;函数命名规则是@函数名@参数字节数</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	8b ec                	mov    %esp,%ebp</span><br><span class="line">   3:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">   6:	66 89 55 f8          	mov    %dx,-0x8(%ebp)</span><br><span class="line">   a:	66 89 4d fc          	mov    %cx,-0x4(%ebp)</span><br><span class="line">   e:	0f bf 45 fc          	movswl -0x4(%ebp),%eax</span><br><span class="line">  12:	0f bf 4d f8          	movswl -0x8(%ebp),%ecx</span><br><span class="line">  16:	03 c1                	add    %ecx,%eax</span><br><span class="line">  18:	0f bf 55 08          	movswl 0x8(%ebp),%edx</span><br><span class="line">  1c:	03 c2                	add    %edx,%eax</span><br><span class="line">  1e:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx</span><br><span class="line">  22:	03 c1                	add    %ecx,%eax</span><br><span class="line">  24:	0f bf 55 10          	movswl 0x10(%ebp),%edx</span><br><span class="line">  28:	03 c2                	add    %edx,%eax</span><br><span class="line">  2a:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx</span><br><span class="line">  2e:	03 c1                	add    %ecx,%eax</span><br><span class="line">  30:	0f bf 55 18          	movswl 0x18(%ebp),%edx</span><br><span class="line">  34:	03 c2                	add    %edx,%eax</span><br><span class="line">  36:	0f bf 4d 1c          	movswl 0x1c(%ebp),%ecx</span><br><span class="line">  3a:	03 c1                	add    %ecx,%eax</span><br><span class="line">  3c:	8b e5                	mov    %ebp,%esp</span><br><span class="line">  3e:	5d                   	pop    %ebp</span><br><span class="line">  3f:	c2 18 00             	ret    $0x18				;被调用者清理自己的栈</span><br><span class="line">  42:	cc                   	int3   </span><br><span class="line">  43:	cc                   	int3   </span><br><span class="line">  44:	cc                   	int3   </span><br><span class="line">  45:	cc                   	int3   </span><br><span class="line">  46:	cc                   	int3   </span><br><span class="line">  47:	cc                   	int3   </span><br><span class="line">  48:	cc                   	int3   </span><br><span class="line">  49:	cc                   	int3   </span><br><span class="line">  4a:	cc                   	int3   </span><br><span class="line">  4b:	cc                   	int3   </span><br><span class="line">  4c:	cc                   	int3   </span><br><span class="line">  4d:	cc                   	int3   </span><br><span class="line">  4e:	cc                   	int3   </span><br><span class="line">  4f:	cc                   	int3   </span><br><span class="line"></span><br><span class="line">00000050 &lt;@show@0&gt;:</span><br><span class="line">  50:	55                   	push   %ebp</span><br><span class="line">  51:	8b ec                	mov    %esp,%ebp</span><br><span class="line">  53:	6a 08                	push   $0x8</span><br><span class="line">  55:	6a 07                	push   $0x7</span><br><span class="line">  57:	6a 06                	push   $0x6</span><br><span class="line">  59:	6a 05                	push   $0x5</span><br><span class="line">  5b:	6a 04                	push   $0x4</span><br><span class="line">  5d:	6a 03                	push   $0x3</span><br><span class="line">  5f:	ba 02 00 00 00       	mov    $0x2,%edx					;顶多有两个参数放在寄存器传递,其余都用栈</span><br><span class="line">  64:	b9 01 00 00 00       	mov    $0x1,%ecx</span><br><span class="line">  69:	e8 00 00 00 00       	call   6e &lt;@show@0+0x1e&gt;</span><br><span class="line">  6e:	5d                   	pop    %ebp</span><br><span class="line">  6f:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000070 &lt;_main&gt;:</span><br><span class="line">  70:	55                   	push   %ebp</span><br><span class="line">  71:	8b ec                	mov    %esp,%ebp</span><br><span class="line">  73:	e8 00 00 00 00       	call   78 &lt;_main+0x8&gt;</span><br><span class="line">  78:	33 c0                	xor    %eax,%eax</span><br><span class="line">  7a:	5d                   	pop    %ebp</span><br><span class="line">  7b:	c3                   	ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="微软__thiscall">微软<code>__thiscall</code></h3>
<p>微软官方文档:</p>
<blockquote>
<p>The <strong>Microsoft-specific</strong>
<strong><code>__thiscall</code></strong> calling convention is used on
C++ class member functions on the x86 architecture. It's the default
calling convention used by member functions that don't use variable
arguments (<code>vararg</code> functions).</p>
<p>微软特有的<code>__thiscall</code>调用约定用于x86体系上C++的成员函数.定参函数默认使用该种调用约定</p>
<p>Under <strong><code>__thiscall</code></strong>, the callee cleans the
stack, which is impossible for <code>vararg</code> functions. Arguments
are pushed on the stack from right to left. The
<strong><code>this</code></strong> pointer is passed via register ECX,
and not on the stack.</p>
<p>如果函数有<code>__thiscall</code>修饰则被调用者清理自己的栈,因此变参函数难以实现.</p>
<p>函数参数从右向左压栈.this指针通过ECX寄存器传递</p>
<p>On ARM, ARM64, and x64 machines,
<strong><code>__thiscall</code></strong> is accepted and ignored by the
compiler. That's because they use a register-based calling convention by
default.</p>
<p>在ARM,ARM64还有x64机器上,<code>__thiscall</code>会被编译器直接忽略.因为编译器默认使用一种基于寄存器的调用约定</p>
</blockquote>
<p>&lt;<ida权威指南>&gt;</p>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220428161940071.png"
alt="image-20220428161940071" />
<figcaption aria-hidden="true">image-20220428161940071</figcaption>
</figure>
<h2 id="x64上的调用约定">x64上的调用约定</h2>
<h3 id="microsoft-x64-calling-convention">Microsoft x64 calling
convention</h3>
<p><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">微软x64调用约定</a></p>
<blockquote>
<p>The Microsoft x64 calling convention[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-ms-18">18]</a>[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-19">19]</a>
is followed on <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_(operating_system)">Windows</a>
and pre-boot <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UEFI">UEFI</a> (for
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> on <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>). The first four
arguments are placed onto the registers. That means RCX, RDX, R8, R9 for
integer, struct or pointer arguments (in that order), and XMM0, XMM1,
XMM2, XMM3 for floating point arguments. Additional arguments are pushed
onto the stack (right to left). Integer return values (similar to x86)
are returned in RAX if 64 bits or less. Floating point return values are
returned in XMM0. Parameters less than 64 bits long are not zero
extended; the high bits are not zeroed.</p>
<p>微软x64调用约定适用于Windows和UEFI.</p>
<p>前四个参数,如果是整数或者结构体或者指针类型,则放在寄存器RCX,RDX,R8,R9寄存器里,如果是浮点数则放在XMM0到XMM3里</p>
<p>额为的参数放在栈里(从右向左压栈)</p>
<p>返回值如果小于等于64位则放在RAX寄存器里(类似于x86的情形)</p>
<p>浮点返回值放在XMM0里</p>
<p>小于64位的参数进行有符号拓展</p>
<p>Structs and unions with sizes that match integers are passed and
returned as if they were integers. Otherwise they are replaced with a
pointer when used as an argument. When an oversized struct return is
needed, another pointer to a caller-provided space is prepended as the
first argument, shifting all other arguments to the right by one
place.[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-20">20]</a></p>
<p>结构体和联合体如果大小与整形匹配则被当作整形进行参数传递还有返回.否则,当他们作为参数时,会被一个指针替代</p>
<p>当需要一个超大的结构体需要返回时，指向调用方提供的空间的另一个指针将作为第一个参数，将所有其他参数向右移动一个位置</p>
<p>When compiling for the x64 architecture in a Windows context (whether
using Microsoft or non-Microsoft tools), stdcall, thiscall, cdecl, and
fastcall all resolve to using this convention.</p>
<p>不管使用的编译器是不是微软的工具,对于x64体系,stdcall,thiscall,cdecl,fastcall都会被忽略,然后使用上述方法处理</p>
<p>In the Microsoft x64 calling convention, it is the caller's
responsibility to allocate 32 bytes of "shadow space" on the stack right
before calling the function (regardless of the actual number of
parameters used), and to pop the stack after the call. The shadow space
is used to spill RCX, RDX, R8, and R9,[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-21">21]</a>
but must be made available to all functions, even those with fewer than
four parameters.</p>
<p>在微软x64调用约定中,调用者在调用其他函数之前,有义务在栈上分配32字节的"影子空间",并且忽略实际上参数占用的大小,并且在调用结束后由调用者清理被调用者的堆栈.</p>
<p>影子空间的作用是用于将来存放RCX,RDX,R8,R9中的前四个参数,但是即使是没有不够四个参数的函数,也会预留一个32字节的影子空间</p>
<p>The registers RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile
(caller-saved).[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-Caller/Callee_Saved_Registers-22">22]</a></p>
<p>RAX, RCX, RDX, R8, R9, R10, R11这些寄存器都是volatile修饰的</p>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220428101247431.png"
alt="image-20220428101247431" />
<figcaption aria-hidden="true">image-20220428101247431</figcaption>
</figure>
<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are
considered nonvolatile (callee-saved).[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-Caller/Callee_Saved_Registers-22">22]</a></p>
<p>RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15不用volatile修饰</p>
<p>For example, a function taking 5 integer arguments will take the
first to fourth in registers, and the fifth will be pushed on top of the
shadow space. So when the called function is entered, the stack will be
composed of (in ascending order) the return address, followed by the
shadow space (32 bytes) followed by the fifth parameter.</p>
<p>举个例子,一个有5参数的
函数,其前四个参数将会被放在寄存器里然后第五个参数竟会别压入栈顶,并且在影子空间之上.</p>
<p>因此当进入被调用函数时,栈中的组成按照从栈顶到栈底将是:返回值,影子空间,第五个参数</p>
<p>这里影子空间就是给前四个参数腾空,前四个参数使用寄存器传递之后在被调用者中会被重新压栈,即压入这个预留的影子空间</p>
</blockquote>
<p>维基百科这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152348161.png"
alt="image-20220428152348161" />
<figcaption aria-hidden="true">image-20220428152348161</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Archimedes/p/15044277.html">x86
x64调用约定及传参顺序 - 一瓶怡宝 - 博客园 (cnblogs.com)</a></p>
<p>同样的程序<code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f,<span class="type">int</span> g,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令<code>gcc -O0 test.c -c -o test.o|objdump -d test.o &gt; t.s|code t.s</code></p>
<p>首先不用编译优化,将<code>test.c</code>编译成目标文件<code>test.o</code>,</p>
<p>然后使用<code>objdump</code>反编译得到反汇编代码<code>t.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format pe-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp			</span><br><span class="line">   4:	89 4d 10             	mov    %ecx,0x10(%rbp)		;蜜汁操作,将ecx中存放的参数也压入栈中</span><br><span class="line">   7:	89 55 18             	mov    %edx,0x18(%rbp)</span><br><span class="line">   a:	44 89 45 20          	mov    %r8d,0x20(%rbp)</span><br><span class="line">   e:	44 89 4d 28          	mov    %r9d,0x28(%rbp)</span><br><span class="line">  12:	8b 55 10             	mov    0x10(%rbp),%edx</span><br><span class="line">  15:	8b 45 18             	mov    0x18(%rbp),%eax</span><br><span class="line">  18:	01 c2                	add    %eax,%edx</span><br><span class="line">  1a:	8b 45 20             	mov    0x20(%rbp),%eax</span><br><span class="line">  1d:	01 c2                	add    %eax,%edx</span><br><span class="line">  1f:	8b 45 28             	mov    0x28(%rbp),%eax</span><br><span class="line">  22:	01 c2                	add    %eax,%edx</span><br><span class="line">  24:	8b 45 30             	mov    0x30(%rbp),%eax</span><br><span class="line">  27:	01 c2                	add    %eax,%edx</span><br><span class="line">  29:	8b 45 38             	mov    0x38(%rbp),%eax</span><br><span class="line">  2c:	01 c2                	add    %eax,%edx</span><br><span class="line">  2e:	8b 45 40             	mov    0x40(%rbp),%eax</span><br><span class="line">  31:	01 c2                	add    %eax,%edx</span><br><span class="line">  33:	8b 45 48             	mov    0x48(%rbp),%eax</span><br><span class="line">  36:	01 d0                	add    %edx,%eax</span><br><span class="line">  38:	5d                   	pop    %rbp</span><br><span class="line">  39:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000003a &lt;show&gt;:</span><br><span class="line">  3a:	55                   	push   %rbp					</span><br><span class="line">  3b:	48 89 e5             	mov    %rsp,%rbp			</span><br><span class="line">  3e:	48 83 ec 40          	sub    $0x40,%rsp			;为子函数申请栈空间,但是蜜汁操作,8个int参数,一个int占4字节,理论上需要0x20=32字节空间,却申请了0x40=64字节的空间</span><br><span class="line">  42:	c7 44 24 38 08 00 00 	movl   $0x8,0x38(%rsp)		 ;将立即数8放在栈中rsp+0x38位置</span><br><span class="line">  49:	00 </span><br><span class="line">  4a:	c7 44 24 30 07 00 00 	movl   $0x7,0x30(%rsp)		;将7放在栈中rsp+0x30位置</span><br><span class="line">  51:	00 	</span><br><span class="line">  52:	c7 44 24 28 06 00 00 	movl   $0x6,0x28(%rsp)		;0x30-0x28=48-40=8,蜜汁操作,相邻两个参数在栈上距离8字节</span><br><span class="line">  59:	00 </span><br><span class="line">  5a:	c7 44 24 20 05 00 00 	movl   $0x5,0x20(%rsp)</span><br><span class="line">  61:	00 </span><br><span class="line">  62:	41 b9 04 00 00 00    	mov    $0x4,%r9d			;立即数4放在r9d寄存器中</span><br><span class="line">  68:	41 b8 03 00 00 00    	mov    $0x3,%r8d			</span><br><span class="line">  6e:	ba 02 00 00 00       	mov    $0x2,%edx</span><br><span class="line">  73:	b9 01 00 00 00       	mov    $0x1,%ecx			;立即数1放在ecx寄存器中</span><br><span class="line">  78:	e8 83 ff ff ff       	callq  0 &lt;func&gt;				</span><br><span class="line">  7d:	48 83 c4 40          	add    $0x40,%rsp</span><br><span class="line">  81:	5d                   	pop    %rbp</span><br><span class="line">  82:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000083 &lt;main&gt;:</span><br><span class="line">  83:	55                   	push   %rbp</span><br><span class="line">  84:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  87:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  8b:	e8 00 00 00 00       	callq  90 &lt;main+0xd&gt;		;蜜汁操作,90行就在下面,为啥要call一下</span><br><span class="line">  90:	e8 a5 ff ff ff       	callq  3a &lt;show&gt;</span><br><span class="line">  95:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  9a:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  9e:	5d                   	pop    %rbp</span><br><span class="line">  9f:	c3                   	retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.函数名没有下划线前缀</p>
<p>2.show和main函数都有固定的格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push %rbp			;rbp是被调用者保存的寄存器,当前函数可以使用,但是最后结束的时候要还原rbp的状态,因此压栈存储先前状态</span><br><span class="line">mov  %rsp,%rbp		 ;将先前的栈顶指针存放在刚刚腾出空闲的rbp寄存器中</span><br><span class="line">sub  %0x..,%rsp		 ;栈顶指针下降,在栈上为将要调用的子函数申请栈空间</span><br><span class="line">callq &lt;..&gt;			;调用函数</span><br><span class="line">..;处理返回值		;通常返回值在eax寄存器中,进行一些处理</span><br><span class="line">add  %0x..,%rsp		 ;子函数已经执行结束了,为其申请的栈帧不需要再存在了,复原栈顶指针位置 </span><br><span class="line">pop  %rbp			;将被调用者有义务保存的寄存器rbp还原</span><br><span class="line">retq				;本函数返回</span><br></pre></td></tr></table></figure>
<p>3.关于show函数在调用具有8个参数的func函数时,参数如何安排</p>
<blockquote>
<p><strong>关于蜜汁操作参数安排</strong></p>
<p>1.后面第5到8个参数使用栈传递,5位于0x20+rsp,8位于0x38+rsp,即约靠左的参数越靠近栈顶rsp</p>
<p>2.前面1到4个参数==使用寄存器传递==</p>
<p>3.在进入被调用者函数后,将刚才调用者通过寄存器传递的参数也放进栈里,</p>
<p>并且x64上调用者在为子函数申请栈空间的时候也会有意申请很大,为待会儿寄存器中的参数也压栈做准备</p>
<p>实际上这三条都完成之后和x86上的结果是相同的,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(p1 ,p2 ,p3, p4 ,p5           ,...,plast	   );</span><br><span class="line">func(ecx,edx,r8d,r9d,远离栈顶的地方,...,靠近栈顶的地方);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作四字节的int在栈上分配8字节空间</strong>:</p>
<p>在64位不管是windows还是linux系统上int都是4字节的,long
long都是8字节的</p>
<p>上面这段程序中各个参数改成short,int,long,long
long类型之后反编译得到的汇编语言,在为子函数申请栈空间的时候都是0x40=64个字节</p>
<p>即参数不管什么类型都是以8字节传递的,这一点可以从使用r9d寄存器传递int参数看出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">62:	41 b9 04 00 00 00    	mov    $0x4,%r9d			;立即数4放在r9d寄存器中</span><br><span class="line">68:	41 b8 03 00 00 00    	mov    $0x3,%r8d	</span><br></pre></td></tr></table></figure>
<p>r开头的寄存器都是4字寄存器,理论上是放long long
的,但是这里int也用了r9d传递</p>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作就在下一行的指令还要call</strong></p>
<p>案发现场:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">8b:	e8 00 00 00 00       	callq  90 &lt;main+0xd&gt;		;蜜汁操作,90行就在下面,为啥要call一下</span><br><span class="line">90:	e8 a5 ff ff ff       	callq  3a &lt;show&gt;</span><br><span class="line">95:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>写一个更短的程序观察这个事</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">foo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -c -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br><span class="line">不开任何编译优化,反汇编</span><br></pre></td></tr></table></figure>
<p>反编译得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;foo&gt;:</span><br><span class="line">0:	55                   	push   %rbp</span><br><span class="line">1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">4:	90                   	nop</span><br><span class="line">5:	5d                   	pop    %rbp</span><br><span class="line">6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000007 &lt;main&gt;:</span><br><span class="line">7:	55                   	push   %rbp</span><br><span class="line">8:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">b:	48 83 ec 20          	sub    <span class="variable">$0x20</span>,%rsp</span><br><span class="line">f:	e8 00 00 00 00       	callq  14 &lt;main+0xd&gt;	</span><br><span class="line">14:	e8 e7 ff ff ff       	callq  0 &lt;foo&gt;</span><br><span class="line">19:	b8 00 00 00 00       	mov    <span class="variable">$0x0</span>,%eax	</span><br><span class="line">1e:	48 83 c4 20          	add    <span class="variable">$0x20</span>,%rsp</span><br><span class="line">22:	5d                   	pop    %rbp</span><br><span class="line">23:	c3                   	retq   </span><br><span class="line">24:	90                   	nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>main+0xf</code>处的callq,将下一条指令也就是<code>main+0x14</code>压栈,然后修改程序计数器为<code>main+0xf</code>,即执行<code>jmp main+0xf</code></p>
<p><code>main+0x14</code>处的callq,将下一条指令地址也就是<code>main+0x19</code>压栈,然后修改程序计数器为<code>foo</code>地址,即执行<code>jmp foo</code></p>
<p><code>foo</code>执行到最后有一个<code>retq</code>作用是将栈顶刚才压入的<code>main+0x19</code>还给程序计数器rip,然后退栈,即<code>pop %rip</code></p>
<p>这样看起来程序已经出错了,栈顶还有一个<code>main+0xf</code>没有弹出,但是<code>main+0x22</code>处有一个退栈将位于栈顶<code>main+0xf</code>弹给了<code>%rbp</code>寄存器,然而实际上<code>%rbp</code>寄存器应当获取次栈顶的值,即在<code>main+0x7</code>压入的值</p>
<p>出错的原因是<code>main+0xf</code>处的call指令调用的不是一个函数,没有与该call指令相对应的<code>ret</code>指令,这导致了call前压栈但是call后不退栈.</p>
<p>下面正向编译观察这个事情</p>
<p>使用<code>gcc -S</code>选项正向编译成汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	call	__main</span><br><span class="line">	call	show</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident	&quot;GCC: (tdm64-1) 9.2.0&quot;</span><br></pre></td></tr></table></figure>
<p>第9行有一个<code>call __main</code></p>
<p>stackoverflow上的说法</p>
<blockquote>
<p>Calls the _<strong>main function which will do initializing stuff
that gcc needs. Call will push the current instruction pointer on the
stack and jump to the address of </strong>_main</p>
</blockquote>
<p>调用<code>__main</code>函数,初始化gcc需要的材料.该调用将当前程序计数器压栈然后跳转__main函数</p>
<p>显然我们<code>gcc -c</code>生成的目标文件.o是没有<code>__main</code>函数的
,该函数应当是链接阶段加上去的</p>
<p>那么我们编译成exe文件之后再反编译进行观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000401633 &lt;main&gt;:</span><br><span class="line">  401633:	55                   	push   %rbp</span><br><span class="line">  401634:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  401637:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  40163b:	e8 c0 00 00 00       	callq  401700 &lt;__main&gt;	;此call确实调用了__main函数</span><br><span class="line">  401640:	e8 a5 ff ff ff       	callq  4015ea &lt;show&gt;	;此call调用了show函数</span><br><span class="line">  401645:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40164a:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  40164e:	5d                   	pop    %rbp</span><br><span class="line">  40164f:	c3                   	retq   </span><br><span class="line">0000000000401700 &lt;__main&gt;:</span><br><span class="line">  401700:	8b 05 2a 59 00 00    	mov    0x592a(%rip),%eax        # 407030 &lt;initialized&gt;</span><br><span class="line">  401706:	85 c0                	test   %eax,%eax</span><br><span class="line">  401708:	74 06                	je     401710 &lt;__main+0x10&gt;</span><br><span class="line">  40170a:	c3                   	retq   						;有ret语句</span><br><span class="line">  40170b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  401710:	c7 05 16 59 00 00 01 	movl   $0x1,0x5916(%rip)        # 407030 &lt;initialized&gt;</span><br><span class="line">  401717:	00 00 00 </span><br><span class="line">  40171a:	e9 71 ff ff ff       	jmpq   401690 &lt;__do_global_ctors&gt;</span><br><span class="line">  40171f:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>此时可以看到,两个call都是调用的函数,并且调用的函数都有ret语句与call匹配</p>
</blockquote>
<p>还要补充的是关于对齐:申请栈空间时要按照16字节对齐申请</p>
<h3 id="system-v-amd64-abi">System V AMD64 ABI</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152425649.png"
alt="image-20220428152425649" />
<figcaption aria-hidden="true">image-20220428152425649</figcaption>
</figure>
<p>CSAPP写道,参数传递时可以用到六个寄存器,多余的参数用栈传递,是指在64位linux环境下,</p>
<p>而windows上只能用四个寄存器传递参数,多余的用栈传递</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427223059552.png"
alt="image-20220427223059552" />
<figcaption aria-hidden="true">image-20220427223059552</figcaption>
</figure>
<p>还是刚才的c程序,在ubuntu上的情况</p>
<p><code>main.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int _cdecl func(int a,int b,int c,int d,int e,int f,int g,int h)&#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line">int _cdecl show()&#123;</span><br><span class="line">    return func(1,2,3,4,5,6,7,8);</span><br><span class="line">&#125;</span><br><span class="line">int _cdecl main()&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其反汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64						;蜜汁指令</span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   89 7d fc                mov    %edi,-0x4(%rbp)		;寄存器传递的参数也压栈,这与windows上相同</span><br><span class="line">   b:   89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">   e:   89 55 f4                mov    %edx,-0xc(%rbp)		</span><br><span class="line">  11:   89 4d f0                mov    %ecx,-0x10(%rbp)</span><br><span class="line">  14:   44 89 45 ec             mov    %r8d,-0x14(%rbp)</span><br><span class="line">  18:   44 89 4d e8             mov    %r9d,-0x18(%rbp)</span><br><span class="line">  1c:   8b 55 fc                mov    -0x4(%rbp),%edx</span><br><span class="line">  1f:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  22:   01 c2                   add    %eax,%edx</span><br><span class="line">  24:   8b 45 f4                mov    -0xc(%rbp),%eax</span><br><span class="line">  27:   01 c2                   add    %eax,%edx</span><br><span class="line">  29:   8b 45 f0                mov    -0x10(%rbp),%eax</span><br><span class="line">  2c:   01 c2                   add    %eax,%edx</span><br><span class="line">  2e:   8b 45 ec                mov    -0x14(%rbp),%eax</span><br><span class="line">  31:   01 c2                   add    %eax,%edx</span><br><span class="line">  33:   8b 45 e8                mov    -0x18(%rbp),%eax</span><br><span class="line">  36:   01 c2                   add    %eax,%edx</span><br><span class="line">  38:   8b 45 10                mov    0x10(%rbp),%eax</span><br><span class="line">  3b:   01 c2                   add    %eax,%edx</span><br><span class="line">  3d:   8b 45 18                mov    0x18(%rbp),%eax</span><br><span class="line">  40:   01 d0                   add    %edx,%eax</span><br><span class="line">  42:   5d                      pop    %rbp</span><br><span class="line">  43:   c3                      retq</span><br><span class="line"></span><br><span class="line">0000000000000044 &lt;show&gt;:</span><br><span class="line">  44:   f3 0f 1e fa             endbr64</span><br><span class="line">  48:   55                      push   %rbp</span><br><span class="line">  49:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4c:   6a 08                   pushq  $0x8					</span><br><span class="line">  4e:   6a 07                   pushq  $0x7</span><br><span class="line">  50:   41 b9 06 00 00 00       mov    $0x6,%r9d			;确实使用了6个寄存器传递参数</span><br><span class="line">  56:   41 b8 05 00 00 00       mov    $0x5,%r8d</span><br><span class="line">  5c:   b9 04 00 00 00          mov    $0x4,%ecx</span><br><span class="line">  61:   ba 03 00 00 00          mov    $0x3,%edx</span><br><span class="line">  66:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  6b:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  70:   e8 00 00 00 00          callq  75 &lt;show+0x31&gt;		</span><br><span class="line">  75:   48 83 c4 10             add    $0x10,%rsp</span><br><span class="line">  79:   c9                      leaveq						</span><br><span class="line">  7a:   c3                      retq</span><br><span class="line"></span><br><span class="line">000000000000007b &lt;main&gt;:</span><br><span class="line">  7b:   f3 0f 1e fa             endbr64</span><br><span class="line">  7f:   55                      push   %rbp</span><br><span class="line">  80:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  83:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  88:   e8 00 00 00 00          callq  8d &lt;main+0x12&gt;</span><br><span class="line">  8d:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  92:   5d                      pop    %rbp</span><br><span class="line">  93:   c3                      retq</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(para1,para2,para3,para4,para5,para6,para7,...,paran)</span><br><span class="line">func(edi,esi,edx,ecx,r8d,r9d,栈上远离栈顶,...,栈上靠近栈顶)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/04/22/gdb%E8%B0%83%E8%AF%95%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/gdb%E8%B0%83%E8%AF%95%E5%99%A8/" class="post-title-link" itemprop="url">gbd调试器的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-22 19:57:20" itemprop="dateCreated datePublished" datetime="2022-04-22T19:57:20+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 16:14:03" itemprop="dateModified" datetime="2023-09-20T16:14:03+08:00">2023-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gbd调试器的使用">gbd调试器的使用</h1>
<p>环境:Win11+Kali子系统</p>
<h2 id="启动">启动</h2>
<h3 id="启动gdb">启动<code>gdb</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# gdb</span><br><span class="line">GNU gdb (Debian 10.1-2+b1) 10.1.90.20210103-git</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>看到命令提示符号变成<code>(gdb)</code>则启动成功</p>
<h3 id="安静启动gdb--q">安静启动<code>gdb -q</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# gdb --silent</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--silent也可以写成-q,-quiet</span><br></pre></td></tr></table></figure>
<h3 id="分屏启动gdb--tui">分屏启动<code>gdb -tui</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -tui</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421202637748.png"
alt="image-20220421202637748" />
<figcaption aria-hidden="true">image-20220421202637748</figcaption>
</figure>
<p>上方窗口是源代码窗口,下方是gbd命令行窗口</p>
<p>这样启动不需要另开一个终端观察源代码</p>
<p>并且当程序在端点停下的时候上方窗口也会显示当前程序停止的位置</p>
<p>上方的源代码窗口使用上下箭头移动视野</p>
<h3
id="分屏安静指定调试程序gdb--tui--q-prog_name">分屏+安静+指定调试程序<code>gdb -tui -q &lt;prog_name&gt;</code></h3>
<p>注意使用gdb调试的文件必须是可执行文件(windows上的.exe或者linux上的.out等)</p>
<p>并且在编译该可执行文件的时候==必须加入-g选项==生成gbd调试信息</p>
<blockquote>
<p>如果不使用-g生成了.out文件然后使用gdb调试则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gcc main.c -Og -o  main.out</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb --silent main.out</span><br><span class="line">Reading symbols from main.out...</span><br><span class="line">(No debugging symbols found <span class="keyword">in</span> main.out)			<span class="comment">#报告没有调试信息</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>使用-tui打开,源代码都看不到</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421203357054.png"
alt="image-20220421203357054" />
<figcaption aria-hidden="true">image-20220421203357054</figcaption>
</figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gcc main.c -Og -g -o main.out				<span class="comment">#使用-g选项生成调试信息</span></span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -tui --silent main.out</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421203550729.png"
alt="image-20220421203550729" />
<figcaption aria-hidden="true">image-20220421203550729</figcaption>
</figure>
<h4
id="带参数启动--args-程序-参数1-参数2...">带参数启动<code>--args  &lt;程序&gt; &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q -tui --args main.out 1 2 3 4</span><br></pre></td></tr></table></figure>
<p>这里指定的参数1 2 3
4将会作为<code>main.out</code>执行时的命令行参数</p>
<h2 id="启动后运行前">启动后运行前</h2>
<p>加载需要调试的程序</p>
<p>当在命令行直接使用gdb命令打开gdb调试器时,此时是没有指定需要调试的程序的</p>
<h3 id="工作目录pwd">工作目录<code>pwd</code></h3>
<p>默认工作目录是打开gdb的位置,gdb启动后也可以使用<code>pwd</code>命令观察当前工作目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/kali/mydir.</span><br></pre></td></tr></table></figure>
<h3
id="指定调试程序位置file-prog_name">指定调试程序位置<code>file &lt;prog_name&gt;</code></h3>
<p>对于当前目录下的程序可以直接使用程序名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">ls</span> -l|gdb -q</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;total&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rw-r--r--&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rwxr-xr-x&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rw-r--r--&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) quit</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root   139 Apr 21 20:23 main.c</span><br><span class="line">-rwxr-xr-x 1 root root 17672 Apr 21 20:35 main.out</span><br><span class="line">-rw-r--r-- 1 root root    25 Apr 21 20:38 r.txt</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q</span><br><span class="line">(gdb) file main.out</span><br><span class="line">Reading symbols from main.out...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>对于其他目录下的可以使用绝对或者相对位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file /home/kali/mydir/main.out</span><br><span class="line">Load new symbol table from <span class="string">&quot;/home/kali/mydir/main.out&quot;</span>? (y or n) y</span><br><span class="line">Reading symbols from /home/kali/mydir/main.out...</span><br></pre></td></tr></table></figure>
<h3 id="查看信息">查看信息</h3>
<h4 id="查看当前工作目录pwd">查看当前工作目录<code>pwd</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/kali/mydir.</span><br></pre></td></tr></table></figure>
<h4
id="查看是否找到目标程序文件list">查看是否找到目标程序文件<code>list</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br><span class="line">1       <span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">2       <span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5       int main(int argc,char **argv)&#123;</span><br><span class="line">6               <span class="keyword">for</span>(int i=0;i&lt;argc;++i)&#123;</span><br><span class="line">7                       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,argv[i]);</span><br><span class="line">8               &#125;</span><br><span class="line">9               <span class="built_in">return</span> 0;</span><br><span class="line">10      &#125;</span><br></pre></td></tr></table></figure>
<h4
id="查看调试程序语言show-language">查看调试程序语言<code>show language</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show language</span><br><span class="line">The current <span class="built_in">source</span> language is <span class="string">&quot;auto; currently c&quot;</span>.</span><br></pre></td></tr></table></figure>
<h4
id="查看源文件信息info-source">查看源文件信息<code>info source</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is main.c</span><br><span class="line">Compilation directory is /home/kali/mydir</span><br><span class="line">Located <span class="keyword">in</span> /home/kali/mydir/main.c</span><br><span class="line">Contains 10 lines.</span><br><span class="line">Source language is c.</span><br><span class="line">Producer is GNU C17 11.2.0 -mtune=generic -march=x86-64 -g -Og -fasynchronous-unwind-tables.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br></pre></td></tr></table></figure>
<h4
id="查看可以设置的程序语言set-language">查看可以设置的程序语言<code>set language</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> language</span><br><span class="line">Requires an argument. Valid arguments are auto, <span class="built_in">local</span>, unknown, ada, asm, c, c++, d, fortran, go, minimal, modula-2, objective-c, opencl, pascal, rust.</span><br></pre></td></tr></table></figure>
<h4
id="查看程序运行状态info-program">查看程序运行状态<code>info program</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info prog</span><br><span class="line">The program being debugged is not being run.</span><br></pre></td></tr></table></figure>
<h3 id="设置信息">设置信息</h3>
<h4
id="设置命令行参数set-args-参数1-参数2...">设置命令行参数<code>set args &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args 1 2 3</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;1 2 3&quot;.</span><br></pre></td></tr></table></figure>
<p>如果在启动时有指定参数,此时再用set指定参数则会覆盖启动时设置的参数</p>
<h4 id="设置语言set-language">设置语言'set language <语言>'</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> language c</span><br></pre></td></tr></table></figure>
<h2 id="运行">运行</h2>
<h3 id="运行程序run">运行程序<code>run</code></h3>
<p>命令行参数使用启动时指定的参数或者set
args设置的参数,如果都没有给定则无参数执行</p>
<p>如果有断点则程序在第一个断点处停止,否则直接运行完.</p>
<h4
id="带参数运行run-参数1-参数2...">带参数运行<code>run &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<p>此参数将会直接作为运行参数,覆盖前面设置的参数</p>
<h3 id="main停止运行start">main停止运行<code>start</code></h3>
<p><code>start</code>相当于在main函数处下了断点然后<code>run</code>,自动在main开始前停下</p>
<h2 id="运行时">运行时</h2>
<h3 id="断点">断点</h3>
<h4 id="设置断点b-行号">设置断点<code>b &lt;行号&gt;</code></h4>
<p>断点可以运行前设置也可以运行时设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 6 at 0x555555555142: file main.c, line 6.</span><br></pre></td></tr></table></figure>
<p>如果以-tui分屏打开,则设置好的断点会显示在行号左侧,大写的B+&gt;意味当前程序暂停的断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421213142314.png"
alt="image-20220421213142314" />
<figcaption aria-hidden="true">image-20220421213142314</figcaption>
</figure>
<h5
id="b-函数名直接给函数下断点"><code>b &lt;函数名&gt;</code>直接给函数下断点</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 10 at 0x555555555139: file main.c, line 5.</span><br></pre></td></tr></table></figure>
<h4 id="删除断点-delete-断点编号">删除断点
<code>delete &lt;断点编号&gt;</code></h4>
<p>注意端点编号不是行号</p>
<p>删除全部断点则不指定编号,直接<code>delete</code></p>
<h5
id="删除指定行上的断点clear-行号">删除指定行上的断点<code>clear &lt;行号&gt;</code></h5>
<h4 id="条件断点b-if-条件">条件断点<code>b if &lt;条件&gt;</code></h4>
<p>比如如果没有输入命令行参数时才给main函数下断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main <span class="keyword">if</span> argc==1					<span class="comment">#用户没有输入时argc=1,第一个参数是当前程序位置</span></span><br><span class="line">Breakpoint 11 at 0x555555555139: file main.c, line 5.</span><br></pre></td></tr></table></figure>
<h4
id="查看断点信息info-b-断点号">查看断点信息<code>info b &lt;断点号&gt;</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 11 at 0x555555555139: file main.c, line 5.</span><br><span class="line">(gdb) info b 11</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">11      breakpoint     keep y   0x0000555555555139 <span class="keyword">in</span> main at main.c:5</span><br><span class="line">        stop only <span class="keyword">if</span> argc==1</span><br></pre></td></tr></table></figure>
<h5 id="info-b查看所有断点信息"><code>info b</code>查看所有断点信息</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">11      breakpoint     keep y   0x0000555555555139 <span class="keyword">in</span> main at main.c:5</span><br><span class="line">        stop only <span class="keyword">if</span> argc==1</span><br><span class="line">12      breakpoint     keep y   0x0000555555555142 <span class="keyword">in</span> main at main.c:6</span><br><span class="line">13      breakpoint     keep y   0x0000555555555149 <span class="keyword">in</span> main at main.c:7</span><br></pre></td></tr></table></figure>
<h3 id="查看信息-1">查看信息</h3>
<h4 id="print命令">print命令</h4>
<h5
id="查看函数信息p-函数名">查看函数信息<code>p &lt;函数名&gt;</code></h5>
<p>函数信息也可以在运行前查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p main</span><br><span class="line"><span class="variable">$6</span> = &#123;int (int, char **)&#125; 0x555555555139 &lt;main&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;返回值类型(参数1类型,参数2类型)&#125; 函数地址 &lt;函数名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis main</span><br><span class="line">type = int (int, char **)</span><br><span class="line">(gdb) ptype main</span><br><span class="line">type = int (int, char **)</span><br></pre></td></tr></table></figure>
<h5
id="查看变量信息p-变量名">查看变量信息<code>p &lt;变量名&gt;</code></h5>
<p>查看变量信息必须是程序在该变量下文的断点处停下</p>
<p>即当前程序的运行位置必须已经经过变量,并且变量没有消亡</p>
<p>比如函数中的局部变量在函数返回之后就会消亡,只能在函数中断点然后查看断点之前的变量</p>
<p>如图调试一个用循环计算阶乘的函数,将断点下在第10行<code>result*=n</code>处</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422175357420.png"
alt="image-20220422175357420" />
<figcaption aria-hidden="true">image-20220422175357420</figcaption>
</figure>
<p>当程序第一次执行到次时会停在<code>result*=n</code>==执行前==的状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422175511240.png"
alt="image-20220422175511240" />
<figcaption aria-hidden="true">image-20220422175511240</figcaption>
</figure>
<p>如图第一次在第10行停下,打印result=1</p>
<h5
id="查看寄存器信息p-寄存器名">查看寄存器信息<code>p $&lt;寄存器名&gt;</code></h5>
<p>对于刚才的fact循环求阶乘函数,最后返回值是result,可想而知,该值是存放在rax寄存器中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result*=n;</span><br><span class="line">                --n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面调试程序验证猜想</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180106540.png"
alt="image-20220422180106540" />
<figcaption aria-hidden="true">image-20220422180106540</figcaption>
</figure>
<p>还是将断点下到第10行while循环中</p>
<p>逐次进行循环,观察rax寄存器中的值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180159934.png"
alt="image-20220422180159934" />
<figcaption aria-hidden="true">image-20220422180159934</figcaption>
</figure>
<p>与result的变化是一致的</p>
<p><strong>也可以查看程序计数器<code>rip</code>中的值,观察程序当前进行位置</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180413841.png"
alt="image-20220422180413841" />
<figcaption aria-hidden="true">image-20220422180413841</figcaption>
</figure>
<p>用objdump反编译然后观察fact+13处的指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180540637.png"
alt="image-20220422180540637" />
<figcaption aria-hidden="true">image-20220422180540637</figcaption>
</figure>
<p><code>fact+13=0x1139+0x13=0x114c</code>,该位置是一个<code>test %edi,%edi</code>指令,而n作为第一个参数是存放在edi寄存器中的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180821161.png"
alt="image-20220422180821161" />
<figcaption aria-hidden="true">image-20220422180821161</figcaption>
</figure>
<p>紧接着114e处<code>jg 1146</code>意味如果<code>R[%edi]=n&gt;0</code>则跳转1146位置,</p>
<p>而1146位置在114e上方,相当于跳进了循环,</p>
<p>也就是说0x114c处相当于循环判断<code>while(n&gt;0)</code></p>
<p>即程序在第10行的断点停下时rip中是第9行中的条件判断指令</p>
<h4 id="x-检查字节或者字">x/<大小> <位置>检查字节或者字</h4>
<h5
id="x20b-fact检查fact函数的前20个字节"><code>x/20b fact</code>检查fact函数的前20个字节</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181438589.png"
alt="image-20220422181438589" />
<figcaption aria-hidden="true">image-20220422181438589</figcaption>
</figure>
<p>与objdump得到的反汇编是一样的</p>
<h5 id="x2g-0x555555555139-检查从0x555555555139地址开始的双字">x/2g
0x555555555139 检查从0x555555555139地址开始的双字</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181756825.png"
alt="image-20220422181756825" />
<figcaption aria-hidden="true">image-20220422181756825</figcaption>
</figure>
<h4 id="info命令">info命令</h4>
<h5
id="查看所有寄存器信息info-registers">查看所有寄存器信息<code>info registers</code></h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181858252.png"
alt="image-20220422181858252" />
<figcaption aria-hidden="true">image-20220422181858252</figcaption>
</figure>
<p>其中<code>rax</code>存放result,<code>rdi</code>存放n</p>
<h5 id="查看栈帧info-frame">查看栈帧'info frame'</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182024087.png"
alt="image-20220422182024087" />
<figcaption aria-hidden="true">image-20220422182024087</figcaption>
</figure>
<h4 id="disas命令">disas命令</h4>
<h5
id="反汇编当前程序暂停的函数disas">反汇编当前程序暂停的函数<code>disas</code></h5>
<p>首先要在函数里下断点,然后程序在该断点暂停时使用disas可以观察当前函数的反汇编信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182255390.png"
alt="image-20220422182255390" />
<figcaption aria-hidden="true">image-20220422182255390</figcaption>
</figure>
<p>可见反汇编信息中也会有当前断点位置信息</p>
<p>如此就不用再开一个终端使用objdump观察了</p>
<h5
id="反汇编指定名称的函数disas-函数名">反汇编指定名称的函数<code>disas &lt;函数名&gt;</code></h5>
<p>此方法不需要在函数中下断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas fact</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182507141.png"
alt="image-20220422182507141" />
<figcaption aria-hidden="true">image-20220422182507141</figcaption>
</figure>
<h5
id="反汇编某个地址附近的函数disas-地址">反汇编某个地址附近的函数<code>disas &lt;地址&gt;</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disas 0x000055555555514c</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182706003.png"
alt="image-20220422182706003" />
<figcaption aria-hidden="true">image-20220422182706003</figcaption>
</figure>
<h3 id="继续执行">继续执行</h3>
<p>执行有多种情况,通常会与断点或者一些逻辑结构联合使用,</p>
<p>比如在断点处停下或者不停下</p>
<p>在循环处,在函数中都有特殊的命令决定如何执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">源代码层面</span><br><span class="line">next		单步执行,不进入函数,但是函数会执行然后返回值</span><br><span class="line">next n		单步执行n行,均不进入函数</span><br><span class="line"></span><br><span class="line">step		单步执行,进入函数</span><br><span class="line">step n		单步执行n行,均进入函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span>	恢复执行,直到预见下一个断点</span><br><span class="line"><span class="built_in">continue</span> n	恢复执行,并忽略下面的n个断点</span><br><span class="line"></span><br><span class="line">finish		一直运行直到当前函数返回后停止,忽略断点</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span>		放弃后面的执行直接<span class="built_in">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">机器码层面(或者说汇编代码层面)</span><br><span class="line">stepi		单步执行一条指令,进入函数</span><br><span class="line">stepi n</span><br><span class="line"></span><br><span class="line">nexti		单步执行一条指令,不进入函数(不会call)</span><br><span class="line">nexti n</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span>		一直运行当前循环,在出循环之后的第一条语句停下,如果循环内有断点则在断点停下</span><br><span class="line">			实际上在机器码层面上,一直运行直到一个内存地址比当前更大的指令处停下</span><br></pre></td></tr></table></figure>
<h4 id="源代码层面">源代码层面</h4>
<p>以一个递归求阶乘的程序为例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">cat</span> main.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fact(int n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;0)<span class="built_in">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==0)<span class="built_in">return</span> 1;</span><br><span class="line">        <span class="built_in">return</span> n*fact(n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">        int ans=123456;</span><br><span class="line">        ans=fact(9);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="next单步步过">next单步步过</h5>
<p>在main函数处下断点,使得程序上来先停一下,让我们有机会一行一行地执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 3 at 0x55555555515a: file main.c, line 13.</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422185956239.png"
alt="image-20220422185956239" />
<figcaption aria-hidden="true">image-20220422185956239</figcaption>
</figure>
<p>第一个n命令使得程序断在<code>15:ans=fact(123456)</code></p>
<p>第二个n命令使得程序断在<code>16:printf("%d",ans)</code></p>
<p>此时使用print命令观察ans的值发现其确实是9的阶乘,即第15行是自动执行然后返回了值的,单步步过只是忽略了执行细节,只要函数的执行后果</p>
<h5 id="step单步步入">step单步步入</h5>
<p>还是在main函数处下断点,然后使用step</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190333043.png"
alt="image-20220422190333043" />
<figcaption aria-hidden="true">image-20220422190333043</figcaption>
</figure>
<p>第一个step命令会让程序断在<code>15:ans=fact(9)</code>这与next是相同的</p>
<p>但是下一个step会进入step并在都5行停下</p>
<h5 id="continue执行到下一个断点">continue执行到下一个断点</h5>
<p>在main函数开始(line 13)和main函数中打印ans前(line16)各打一个断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190554335.png"
alt="image-20220422190554335" />
<figcaption aria-hidden="true">image-20220422190554335</figcaption>
</figure>
<p>run运行之后会在13行停下,然后在输入c命令则会直接在16行停下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190646915.png"
alt="image-20220422190646915" />
<figcaption aria-hidden="true">image-20220422190646915</figcaption>
</figure>
<p>此时print命令打印ans值发现为362880确实是9的阶乘,即两个断点之间的所有程序都被执行过了</p>
<h5 id="finish一直运行到当前函数返回">finish一直运行到当前函数返回</h5>
<p>分两种情况,有没有进入函数</p>
<p>使用step命令让程序在第一层递归函数==入口前==停下,此时使用finish</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422191432439.png"
alt="image-20220422191432439" />
<figcaption aria-hidden="true">image-20220422191432439</figcaption>
</figure>
<p>发现程序直接返回到了main函数中,并且带着返回值<code>362880</code>恰好是9的阶乘,说明递归函数各层都执行了</p>
<p>现在让程序在第一层递归函数的==内部==停下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192218738.png"
alt="image-20220422192218738" />
<figcaption aria-hidden="true">image-20220422192218738</figcaption>
</figure>
<p>发现进入的递归函数的第二层</p>
<h5 id="return-放弃函数未执行的部分直接返回到调用者">return
放弃函数未执行的部分,直接返回到调用者</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192641695.png"
alt="image-20220422192641695" />
<figcaption aria-hidden="true">image-20220422192641695</figcaption>
</figure>
<p>fact(6)返回到fact(7)</p>
<p>然后一直使用finish命令返回main函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192818544.png"
alt="image-20220422192818544" />
<figcaption aria-hidden="true">image-20220422192818544</figcaption>
</figure>
<p>发现ans值并没有被正确地计算</p>
<p>即return会放弃下文</p>
<h4 id="机器码层面">机器码层面</h4>
<h5
id="until-在循环体的机器码的最高地址时挑出循环到第一条高于循环地址的指令">until
在循环体的机器码的最高地址时挑出循环到第一条高于循环地址的指令</h5>
<p>调试一个使用循环计算阶乘的函数fact</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─<span class="meta"># cat main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result*=n;</span><br><span class="line">                --n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">123456</span>;</span><br><span class="line">        ans=fact(<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数打一个断点方便单步调试</p>
<p>一直使用step单步步入命令,直到第一次到达while条件判断的时候,使用disas观察反汇编代码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194448277.png"
alt="image-20220422194448277" />
<figcaption aria-hidden="true">image-20220422194448277</figcaption>
</figure>
<p>此时对应指令fact+19位置</p>
<p>此时再使用一次单步步入,进入循环,<code>line 12:result*=n</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194622378.png"
alt="image-20220422194622378" />
<figcaption aria-hidden="true">image-20220422194622378</figcaption>
</figure>
<p>对应指令fact+13位置</p>
<p>即源代码的执行顺序和机器码相反</p>
<p>显然是由于刚才的fact+21的jg条件跳转满足,跳到了fact+13</p>
<p>此时使用until只是相当于step命令,因为until只会在循环的机器码层面的最大地址处才会有快速执行循环的作用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194902282.png"
alt="image-20220422194902282" />
<figcaption aria-hidden="true">image-20220422194902282</figcaption>
</figure>
<p>继续disas观察反汇编发现<code>line13:--n</code>对应反汇编的fact+16</p>
<p>此时再使用u</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195028273.png"
alt="image-20220422195028273" />
<figcaption aria-hidden="true">image-20220422195028273</figcaption>
</figure>
<p>源代码层面进行循环条件判断,对应机器码层面test判断,而fact+19就是循环体在机器层面的最高地址</p>
<p>此时再使用u</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195116698.png"
alt="image-20220422195116698" />
<figcaption aria-hidden="true">image-20220422195116698</figcaption>
</figure>
<p>直接返回了main函数,这是因为fact函数中while循环结束立刻就返回了,对应机器码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195301219.png"
alt="image-20220422195301219" />
<figcaption aria-hidden="true">image-20220422195301219</figcaption>
</figure>
<p>第23行是循环外首条高于循环的地址,该条指令又是返回,因此返回了main函数</p>
<p>返回main后打印ans值发现是362880是9的阶乘,证明until指令会执行循环体剩下的部分</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/impossible/page/9/">9</a><a class="extend next" rel="next" href="/impossible/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
